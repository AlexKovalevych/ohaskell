<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Три кита типизации | О Haskell по-человечески</title>
        
        <link rel="stylesheet" type="text/css" href="../../css/default.css" />
        <link rel="icon" type="image/x-icon" href="../../images/favicon.ico" />
    </head>
    <body>
        <div id="wrapper">

            <div class="ribbon">
                <a href="https://github.com/denisshevchenko/ohaskell">Живу на GitHub</a>
            </div>

            <div id="wrapper_2">
            <div id="header">
                <div id="logo">
                    <a href="../../ru/index.html" title="Домой">О Haskell по-человечески</a><span class="logo-note">для обыкновенных программистов</span>
                </div>
                <div id="navigation">
                    <a href="../../ru/chapters.html">ОГЛАВЛЕНИЕ</a>
                </div>
            </div>

            

            <div id="content">
                <h1>Три кита типизации</h1>

                <div style="padding-top: 10px;"></div>

<div id="prev_arrow">
    <a href="../../ru/about-haskell/pure-functionality.html">❮</a>
</div>

<div id="next_arrow">
    <a href="../../ru/about-haskell/immutability.html">❯</a>
</div>

<p>К типам у Haskell отношение очень серьёзное. Его система типов зиждется на трёх китах:</p>
<ol style="list-style-type: decimal">
<li>статическая проверка,</li>
<li>строгость,</li>
<li>автоматическое выведение.</li>
</ol>
<h2 id="кит-первый">Кит первый</h2>
<p>Статическая проверка типов - это проверка типа каждого выражения, выполняемая на стадии компиляции. И если компилятору что-то не понравится в типе какого-либо выражения, компиляция будет прервана с ошибкой.</p>
<p>Соответственно, если компиляция кода на Haskell прошла успешно, мы можем утверждать, что с типами у нас всё в порядке, потому что у нас есть второй кит.</p>
<h2 id="кит-второй">Кит второй</h2>
<p>Строгость типов - это требование соответствия того, что мы ожидаем, тому, что мы получаем.</p>
<p>Например, в языке C мы можем написать такую функцию:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> coefficient() {
    return <span class="fl">12.9</span>;
}</code></pre>
<p>Это пример неявного приведения типов. Мы ожидаем значение типа <code>int</code>, но фактически получаем значение типа <code>double</code>. Однако компилятор языка C спокойно проглотит это, при этом аккуратно отбросив дробную часть возвращаемого значения, ведь тип этого значения будет незримо приведён к <code>int</code>.</p>
<p>В Haskell подобный код не имеет ни малейших шансов пройти компиляцию, потому что в этом языке не существует неявного приведения типов: если мы ожидаем целое число - будь добр предоставить именно целое число.</p>
<p>Впрочем, явное приведение типов в Haskell тоже очень ограничено. В том же C++ мы можем написать так:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main() {
    std::cout &lt;&lt; (<span class="dt">int</span>)<span class="st">'1'</span> &lt;&lt; std::endl;
}</code></pre>
<p>Взяли значение типа <code>char</code> - и грубо переделали его в значение типа <code>int</code>. Компилятор - молчок. Последствия такого рода ошибок уже стали притчею во языцех…</p>
<p>В Haskell мы можем явно указать тип некоторого значения, но только если этот тип ассоциативен со значением. То есть если это число 1, мы можем явно указать лишь “числовой” тип (такой, как <code>Integer</code> или <code>Double</code>). А вот фокусы с приведением символа к целочисленному значению, как это было продемонстрировано выше, в Haskell невозможны.</p>
<h2 id="кит-третий">Кит третий</h2>
<p>Автоматическое выведение типов - это способность компилятора понять тип выражения по самому этому выражению.</p>
<p>Например, в языке C мы обязаны указывать тип явно:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">double</span> i = <span class="fl">10.34</span>;</code></pre>
<p>В Haskell этого делать не нужно. Мы просто пишем:</p>
<pre><code>i = 10.34 </code></pre>
<p>Компилятор проанализирует значение <code>10.34</code> и сам поймёт, что тип <code>i</code> - это <code>Double</code>. Впрочем, как уже было сказано, мы <em>можем</em> указать тип выражения явно (а иногда <em>должны</em> это сделать). Вскоре я продемонстрирую это.</p>

<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'ohaskell'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
 

            </div>
            
            <div id="footer">
                <div id="social">
                    © Денис Шевченко 2013-2014
                </div>
                <div id="hakyll_mark">
                    Книга создана с помощью <a href="http://jaspervdj.be/hakyll">Hakyll</a>
                </div>
            </div>

            <div id="search_form">
                <script>
                  (function() {
                    var cx = '007697214108744450483:au850gpbupm';
                    var gcse = document.createElement('script');
                    gcse.type = 'text/javascript';
                    gcse.async = true;
                    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
                        '//www.google.com/cse/cse.js?cx=' + cx;
                    var s = document.getElementsByTagName('script')[0];
                    s.parentNode.insertBefore(gcse, s);
                  })();
                </script>
                <gcse:search></gcse:search>
            </div>
            </div>
        </div>
    </body>
</html>
