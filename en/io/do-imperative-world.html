<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>do: imperative world | О Haskell по-человечески</title>
        
        <link rel="stylesheet" type="text/css" href="../../css/default.css" />
        <link rel="icon" type="image/x-icon" href="../../images/favicon.ico" />
    </head>
    <body>
        <div id="wrapper">

            <div class="ribbon">
                <a href="https://github.com/denisshevchenko/ohaskell">Live on GitHub</a>
            </div>

            <div id="wrapper_2">
            <div id="header">
                <div id="logo">
                    <a href="../../en/index.html" title="Домой">About Haskell humanly</a><span class="logo-note">for ordinary developers</span>
                </div>
                <div id="navigation">
                    <a href="../../en/chapters.html">CONTENTS</a>
                </div>
            </div>

            <div id="content">
                <h1>do: imperative world</h1>

                <div style="padding-top: 10px;"></div>

<div id="prev_arrow">
    <a href="../../en/io/IO-a.html">❮</a>
</div>

<div id="next_arrow">
    <a href="../../en/io/exceptions-handling.html">❯</a>
</div>

<p>You got it right: imperative world. Despite that Haskell is a purely functional language, we can write imperative code when we need. Such necessity constantly arises when we work with the outside world.</p>
<p>As you know, imperative approach implies that the execution of instructions goes strictly in the specified order. With pure functions such approach is excessive, that’s why in the case of pure function the order in which expressions are evaluated doesn’t matter.</p>
<p>Recall our example of working with stdin and stdout:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    putStrLn <span class="st">&quot;Input your text, please:&quot;</span>
    lineFromUser <span class="ot">&lt;-</span> getLine               
    putStrLn <span class="fu">$</span> <span class="st">&quot;Not bad: &quot;</span> <span class="fu">++</span> lineFromUser   </code></pre>
<p>Three steps are done.</p>
<ol style="list-style-type: decimal">
<li>print a greeting string;</li>
<li>wait for the user input;</li>
<li>print the final line.</li>
</ol>
<p>Obviously, we expect that these steps would be done exactly in <em>that</em> order. That would be odd if the final string was printed before we got the string from the user. While working with the outside world a particular order of steps is always implied. For example, when server gets request from client it first must process it, then generate the response, and only then send it to the client.</p>
<p>That’s what the keyword <code>do</code> exists for: it binds our actions into a consecutive chain. When discussing that keyword, term “do-notation” is usually used.</p>
<h2 id="not-only-the-main">Not only the main</h2>
<p>We can use do-notation in any function with side-effects. For example:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">obtainUserText ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span>
obtainUserText prompt <span class="fu">=</span> <span class="kw">do</span>
    putStrLn prompt  <span class="co">-- Print prompt to input the string</span>
    getLine          <span class="co">-- Get some string from user</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    firstText <span class="ot">&lt;-</span> obtainUserText <span class="st">&quot;Enter your text, please: &quot;</span>
    secondText <span class="ot">&lt;-</span> obtainUserText <span class="st">&quot;One more, please: &quot;</span>
    putStrLn <span class="fu">$</span> <span class="st">&quot;You said '&quot;</span> <span class="fu">++</span> firstText <span class="fu">++</span> <span class="st">&quot;' and '&quot;</span> <span class="fu">++</span> secondText <span class="fu">++</span> <span class="st">&quot;'&quot;</span></code></pre>
<p>Function <code>obtainUserText</code> includes two consecutive steps, that’s why the keyword <code>do</code> is used. We expect that the certain prompt would be printed first and only then the action created by function <code>getLine</code> would be send to the outside world and would bring back the string which is typed by user.</p>
<h2 id="about-function-return">About function “return”</h2>
<p>C language has a keyword <code>return</code> it defines the point of function’s return. Haskell doesn’t have such keyword, but has such function. To demonstrate its usage we consider another example:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">obtainTwoTextsFromUser ::</span> <span class="dt">IO</span> <span class="dt">String</span>
obtainTwoTextsFromUser <span class="fu">=</span> <span class="kw">do</span>
    putStrLn <span class="st">&quot;Enter your text, please: &quot;</span>
    firstText <span class="ot">&lt;-</span> getLine
    putStrLn <span class="st">&quot;One more, please: &quot;</span>
    secondText <span class="ot">&lt;-</span> getLine
    <span class="st">&quot;'&quot;</span> <span class="fu">++</span> firstText <span class="fu">++</span> <span class="st">&quot;' and '&quot;</span> <span class="fu">++</span> secondText <span class="fu">++</span> <span class="st">&quot;'&quot;</span> <span class="co">-- Normal string??</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    twoTexts <span class="ot">&lt;-</span> obtainTwoTextsFromUser
    putStrLn <span class="fu">$</span> <span class="st">&quot;You said &quot;</span> <span class="fu">++</span> twoTexts</code></pre>
<p>Function <code>obtainTwoTextsFromUser</code> takes the responsibility to consecutively get two texts from user and return their concatenation. Unfortunately such code wouldn’t compile, as function should return an action, but last instruction is absolutely not an action, it’s a normal string. Here the standard function <code>return</code> would assist us.</p>
<p>Rewrite that function:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">obtainTwoTextsFromUser ::</span> <span class="dt">IO</span> <span class="dt">String</span>
obtainTwoTextsFromUser <span class="fu">=</span> <span class="kw">do</span>
    putStrLn <span class="st">&quot;Enter your text, please: &quot;</span>
    firstText <span class="ot">&lt;-</span> getLine
    putStrLn <span class="st">&quot;One more, please: &quot;</span>
    secondText <span class="ot">&lt;-</span> getLine
    return <span class="fu">$</span> <span class="st">&quot;'&quot;</span> <span class="fu">++</span> firstText <span class="fu">++</span> <span class="st">&quot;' and '&quot;</span> <span class="fu">++</span> secondText <span class="fu">++</span> <span class="st">&quot;'&quot;</span></code></pre>
<p>Looks imperativish, isn’t it? Do not forget that such notation has nothing to do with <code>return</code> from the C language.</p>
<p>Function <code>return</code> takes a value and wraps it into the action which returns that value. In our case we passed it a string, concatenated from user’s texts and got an action which returns that string. Now our code successfully compiles.</p>
<p>By the way, to prove you that function <code>return</code> has nothing to do with C-like keyword <code>return</code>, I’ll show you a small trick.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">obtainTwoTextsFromUser ::</span> <span class="dt">IO</span> <span class="dt">String</span>
obtainTwoTextsFromUser <span class="fu">=</span> <span class="kw">do</span>
    putStrLn <span class="st">&quot;Enter your text, please: &quot;</span>
    firstText <span class="ot">&lt;-</span> getLine
    putStrLn <span class="st">&quot;One more, please: &quot;</span>
    secondText <span class="ot">&lt;-</span> getLine
    return <span class="fu">$</span> <span class="st">&quot;'&quot;</span> <span class="fu">++</span> firstText <span class="fu">++</span> <span class="st">&quot;' and '&quot;</span> <span class="fu">++</span> secondText <span class="fu">++</span> <span class="st">&quot;'&quot;</span>
    putStrLn <span class="st">&quot;And third text, please: &quot;</span> <span class="co">-- We still going!!!!</span>
    getLine</code></pre>
<p>That might confuse programmers who are experienced with imperative programming, but as said above, function <code>return</code> simply wraps a value into action, which returns that value. It doesn’t stop the flow of actions and if any actions follow it they simply continue the execution. In fact, in this tricky function we’ll lose first two user’s texts and return an action which only brings the third text.</p>
<h2 id="so">So</h2>
<ul>
<li>Keyword <code>do</code> binds action into a consecutive chain.</li>
<li>Function <code>return</code> wraps value into an IO-action. Do not confuse it with a keyword <code>return</code> in C-like languages.</li>
</ul>
<p>Done. Now you know about the keyword <code>do</code>. However, you still do not know the most interesting part, Soon I’ll show it to you.</p>

<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'ohaskell'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
 

            </div>
            
            <div id="footer">
                <div id="social">
                    © Denis Shevchenko 2013-2014
                </div>
                <div id="hakyll_mark">
                    Created by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
                </div>
            </div>

            <div id="search_form">
                <script>
                  (function() {
                    var cx = '007697214108744450483:py6mcdzwavw';
                    var gcse = document.createElement('script');
                    gcse.type = 'text/javascript';
                    gcse.async = true;
                    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
                        '//www.google.com/cse/cse.js?cx=' + cx;
                    var s = document.getElementsByTagName('script')[0];
                    s.parentNode.insertBefore(gcse, s);
                  })();
                </script>
                <gcse:search></gcse:search>
            </div>
            </div>
        </div>
    </body>
</html>
