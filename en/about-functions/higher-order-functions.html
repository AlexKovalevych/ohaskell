<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="description" content="About Haskell humanly. A book about amazing programming language. For real programmers.">
        <meta name="author" content="Denis Shevchenko">
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0" />
        
        <link rel="icon" href="../../static/images/favicon.ico">

        <title>Higher-order functions</title>

        <link rel="stylesheet" href="../../static/fonts/font-awesome/css/font-awesome.min.css">

        <script src="../../static/js/jquery-2.1.4.min.js"></script>

        <!-- Compiled and minified CSS -->
        <link rel="stylesheet" href="../../static/css/materialize.min.css">

        <!-- Compiled and minified JavaScript -->
        <script src="../../static/js/materialize.min.js"></script>
        
        <!-- Own css and js -->
        <link href="../../static/css/default.css" rel="stylesheet">
        <script src="../../static/js/default.js"></script>

        <script>
          window.___gcfg = {
            lang: 'ru'
          };
        </script>

        <script src="https://apis.google.com/js/platform.js" async defer>
        </script>
    </head>

    <body>
        <div class="navbar-fixed">
            <nav>
                <div class="nav-wrapper">
                    <a href="../../en/index.html" class="brand-logo center">
                        #ohaskell
                    </a>

                    <a href="#" data-activates="mobile-demo" class="button-collapse show-on-large" style="padding-left: 15px;">
                        <!-- <i class="material-icons">toc</i> -->
                        <i class="fa fa-list-ul" style="font-size: 30px;"></i>
                    </a>

                    <ul class="side-nav" id="mobile-demo">
                        <li><a href="../../en/intro/index.html">Лирическое вступление</a></li>
                          <li><a href="../../en/intro/who.html">Кто</a></li>
                          <li><a href="../../en/intro/why.html">Почему</a></li>
                          <li><a href="../../en/intro/what-for.html">Зачем</a></li>
                          <li><a href="../../en/intro/for-whom.html">Для кого</a></li>
                        
                        <li><a href="../../en/prepare/index.html">Готовимся к работе</a></li>
                          <li><a href="../../en/prepare/create-project.html">Создаём проект</a></li>
                          <li><a href="../../en/prepare/about-modules-minimum.html">О модулях, минимум</a></li>
                          <li><a href="../../en/prepare/about-hackage.html">О Hackage</a></li>
                          <li><a href="../../en/prepare/about-sandbox.html">О песочнице</a></li>

                        <li><a href="../../en/about-haskell/index.html">Несколько слов о Haskell</a></li>
                          <li><a href="../../en/about-haskell/pure-functionality.html">Чистая функциональность</a></li>
                          <li><a href="../../en/about-haskell/types-three-foundations.html">Три кита типизации</a></li>
                          <li><a href="../../en/about-haskell/immutability.html">Неизменность данных</a></li>
                          <li><a href="../../en/about-haskell/laziness.html">Лень</a></li>
                          <li><a href="../../en/about-haskell/where.html">Где его использовать</a></li>

                        <li><a href="../../en/about-functions/index.html">О функциях</a></li>
                          <li><a href="../../en/about-functions/pure-functions.html">Чистые функции</a></li>
                          <li><a href="../../en/about-functions/lambda-functions.html">λ-функции</a></li>
                          <li><a href="../../en/about-functions/higher-order-functions.html">Функции высшего порядка</a></li>
                          <li><a href="../../en/about-functions/functional-chains.html">Функциональные цепочки</a></li>
                          <li><a href="../../en/about-functions/functions-and-operators.html">Функции и операторы</a></li>

                        <li><a href="../../en/about-lists/index.html">О списках</a></li>
                          <li><a href="../../en/about-lists/lists-at-a-glance.html">Списки &mdash; одним взглядом</a></li>
                          <li><a href="../../en/about-lists/ranges.html">Диапазоны</a></li>
                          <li><a href="../../en/about-lists/tuples.html">Кортежи</a></li>
                          <li><a href="../../en/about-lists/list-comprehension.html">Генераторы списков</a></li>

                        <li><a href="../../en/about-user-types/index.html">О пользовательских типах</a></li>
                          <li><a href="../../en/about-user-types/types-at-a-glance.html">Типы &mdash; одним взглядом</a></li>
                          <li><a href="../../en/about-user-types/about-value-constructors.html">О конструкторах значений</a></li>
                          <li><a href="../../en/about-user-types/type-context.html">Контекст типа</a></li>
                          <li><a href="../../en/about-user-types/composite-types.html">Составные типы</a></li>
                          <li><a href="../../en/about-user-types/deriving.html">Наследуемые типы</a></li>
                          <li><a href="../../en/about-user-types/own-type-classes.html">Собственные классы типов</a></li>
                          <li><a href="../../en/about-user-types/newtype.html">Новый тип</a></li>

                        <li><a href="../../en/io/index.html">Ввод и вывод</a></li>
                          <li><a href="../../en/io/functions-with-side-effects.html">Побочные эффекты</a></li>
                          <li><a href="../../en/io/IO-a.html">IO a</a></li>
                          <li><a href="../../en/io/do-imperative-world.html">do: императивный мир</a></li>
                          <li><a href="../../en/io/exceptions-handling.html">Обработка исключений</a></li>
                          <li><a href="../../en/io/own-exceptions.html">Собственные исключения</a></li>

                        <li><a href="../../en/delicious/index.html">Деликатесы</a></li>
                          <li><a href="../../en/delicious/monads-essence.html">Монады: суть</a></li>
                          <li><a href="../../en/delicious/monads-IO.html">Монады: на примере IO</a></li>
                          <li><a href="../../en/delicious/monads-practice.html">Монады: практика</a></li>
                          <li><a href="../../en/delicious/maybe.html">Может быть</a></li>
                          <li><a href="../../en/delicious/functors.html">Функторы</a></li>
                          <li><a href="../../en/delicious/applicative-functors.html">Аппликативные функторы</a></li>
                          <li><a href="../../en/delicious/transformers-first-meeting.html">Трансформеры: начало</a></li>
                          <li><a href="../../en/delicious/transformers-reader.html">Трансформеры: читатель</a></li>
                          <li><a href="../../en/delicious/transformers-writer.html">Трансформеры: писатель</a></li>
                          <li><a href="../../en/delicious/transformers-state.html">Трансформеры: состояние</a></li>
                          <li><a href="../../en/delicious/transformers-error.html">Трансформеры: ошибка</a></li>

                        <li><a href="../../en/miscellaneous/index.html">Разное</a></li>
                          <li><a href="../../en/miscellaneous/about-modules.html">О модулях</a></li>
                          <li><a href="../../en/miscellaneous/pattern-matching.html">Сравнение с образцом</a></li>
                          <li><a href="../../en/miscellaneous/map.html">Контейнеры: словарь</a></li>
                          <li><a href="../../en/miscellaneous/set.html">Контейнеры: множество</a></li>
                          <li><a href="../../en/miscellaneous/recursive-functions.html">Рекурсивные функции</a></li>
                          <li><a href="../../en/miscellaneous/about-apostrophe.html">Про апостроф</a></li>
                          <li><a href="../../en/miscellaneous/about-formatting.html">О форматировании</a></li>
                          <li><a href="../../en/miscellaneous/about-hlint.html">Про hlint</a></li>

                        <li><a href="../../en/integration/index.html">Интеграция</a></li>
                          <li><a href="../../en/integration/c-from-haskell.html">C из Haskell</a></li>

                        <li><a href="../../en/end/index.html">Заключение</a></li>
                          <li><a href="../../en/end/is-this-end.html">И что, это всё??</a></li>
                          <li><a href="../../en/end/gratitudes.html">Благодарности</a></li>
                    </ul>

                    <ul id="nav-mobile" class="right">
                        <li><a href="https://github.com/denisshevchenko/ohaskell" target="_blank"><span class="fa fa-github"></span></a></li>
                    </ul>
                </div>
            </nav>
        </div>

        <div class="container">
            <h1>Higher-order functions</h1>

            <p>Higher-order functions are very important in Haskell. From previous chapters you have learnt that pure functions are in fact values. Therefore you can, first of all, pass pure functions as arguments to other functions, and, second, return them from other functions.</p>
<p>A higher-order function is a function, which takes another function as an argument and/or returns another function.</p>
<h2 id="exposing-functions">Exposing functions</h2>
<p>As you remember, in the chapter about pure functions I’ve mentioned, that they can take one or more arguments. It’s time to say that I deceived you, as the truth is:</p>
<blockquote>
<p><strong>Pure functions in Haskell always take one argument</strong></p>
</blockquote>
<p>But how could we declare functions taking two or event three arguments?</p>
<p>The trick is so called “currying”. This name comes from Haskell Curry. Currying is a transformation of function taking multiple arguments to a function taking them one by one.</p>
<p>Let’s define a function to divide two numbers:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">divide ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
divide arg1 arg2 <span class="fu">=</span> arg1 <span class="fu">/</span> arg2</code></pre></div>
<p>This function takes two values of standart type <code>Double</code> and returns the result of dividing the first argument by the second. That is simple. But if we look inside this function call:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> print (divide <span class="fl">10.03</span> <span class="fl">2.1</span>)</code></pre></div>
<p>then we’ll know, that this call occurs in two steps:</p>
<ol style="list-style-type: decimal">
<li>Function <code>divide</code> is applied to the first argument <code>10.03</code> and - attention! - returns the function of the type <code>Double -&gt; Double</code>.</li>
<li>This returned function, in turn, is applied to the second argument <code>2.1</code> and returns the final value <code>4.77</code>.</li>
</ol>
<p>We can explicitly state this two steps by rewriting the function call:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(divide <span class="fl">10.03</span>) <span class="fl">2.1</span></code></pre></div>
<p>The function is applied only to one value: first to <code>10.03</code>, next the function returned by the first call is applied to <code>2.1</code>.</p>
<p>It is because of these two steps the <code>divide</code> definition contains two arrows instead of one:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">divide ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></code></pre></div>
<p>From the conceptual point of view this declaration sounds like: “The function <code>divide</code> takes two values of type <code>Double</code> and returns a value of type <code>Double</code>.” But the more correct way to read this will be: “The function <code>divide</code> is applied to the first <code>Double</code> value and returns a function of type <code>Double -&gt; Double</code>, which is applied to the second <code>Double</code> value and returns the final value of type <code>Double</code>.”</p>
<p>The correct way of reading can be shown in the declaration:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">divide ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> (<span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>)</code></pre></div>
<p>Now we clearly see, that on the first step we have a call of the function of one argument, which returns a function of the type <code>Double -&gt; Double</code>, and on the second step we have a call of the second function, returned on step one.</p>
<p>Similarly, if we have a function which takes three arguments:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">totalSum ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
totalSum arg1 arg2 arg3 <span class="fu">=</span> arg1 <span class="fu">+</span> arg2 <span class="fu">+</span> arg3</code></pre></div>
<p>then its call:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> print (totalSum <span class="fl">10.03</span> <span class="fl">2.1</span> <span class="fl">45.7</span>)</code></pre></div>
<p>would occur in three steps and, to reflect this, we can rewrite this function’s declaration as:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">totalSum ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> (<span class="dt">Double</span> <span class="ot">-&gt;</span> (<span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>))</code></pre></div>
<p>and its call as:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">((totalSum <span class="fl">10.03</span>) <span class="fl">2.1</span>) <span class="fl">45.7</span></code></pre></div>
<p>And, to clarify things completely, let’s study one important thing.</p>
<h2 id="partial-application">Partial application</h2>
<p>In spite of the two-step nature of <code>divide</code> function call, its body will be executed only once. A single call, just divided into two steps. And to understand the nature of these steps, let’s study <strong><em>partial application</em></strong> of functions.</p>
<p>The function is called partially applied, if the number of arguments, to which it is applied, is less than the number expected by this function. Already familiar λ-functions will be useful here.</p>
<p>Let’s apply the function <code>divide</code> to just a single argument:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span>
    <span class="kw">let</span> temporaryFunction <span class="fu">=</span> divide <span class="fl">10.03</span>  <span class="co">-- Remember first value</span>
    <span class="kw">in</span>
    print (temporaryFunction <span class="fl">2.1</span>)         <span class="co">-- Now we can complete the job</span></code></pre></div>
<p>Now everything is in its place. We can clearly see, what does this expression mean:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(divide <span class="fl">10.03</span>) <span class="fl">2.1</span></code></pre></div>
<p>We can’t get the result of the division as a result of the first call, because we don’t have the second argument yet! Instead we got a temporary λ-function, which we associated with the expression <code>temporaryFunction</code> just for clarity. This temporary λ-function kind of remembered the first argument, and only when we apply it to the second argument, we will get the result of the division.</p>
<p>Similarly, the <code>totalSum</code> function call, which occurs in three steps, can be described as:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">let</span> firstFunction <span class="fu">=</span> totalSum <span class="fl">1.0</span>        <span class="co">-- Remember the first</span>
    secondFunction <span class="fu">=</span> firstFunction <span class="fl">2.0</span>  <span class="co">-- Remember the second</span>
<span class="kw">in</span>
print (secondFunction <span class="fl">3.0</span>)              <span class="co">-- Now perform the addition</span></code></pre></div>
<p>During the call we got two temporary λ-functions, each of which was applied to the next argument and remembered it. Only when the second temporary function λ-function was applied to the third argument, we got the sum.</p>
<h2 id="why-do-we-need-it">Why do we need it</h2>
<p>In most cases you don’t need this information about currying and partial application. The main advantage of the approach, when one function of multiple arguments is decomposed into a chain of functions of one argument, lies in the academical plane: it is easier to do mathematical proofs, if you agree that every function takes strictly one argument and returns strictly one value.</p>
<p>But we, as programmers-practitioners, are more interested in the practical aspect. That’s why we return to considering higher-order functions (HOFs).</p>
<p>Formally <code>divide</code> and <code>totalSum</code> are HOFs because of those intermediate λ-functions. In fact all functions that take more than one argument are HOFs. But all these intermediate λ-functions are nothing more than internal business, they are hidden from us. The “real” HOFs, which are declared as taking functional values or returning functional values, are more interesting.</p>
<p>Consider a small example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Login</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">Password</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">AvatarURL</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">UserId</span> <span class="fu">=</span> <span class="dt">Integer</span>

<span class="ot">userInfo ::</span> <span class="dt">Login</span> <span class="ot">-&gt;</span> <span class="dt">Password</span> <span class="ot">-&gt;</span> <span class="dt">AvatarURL</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
userInfo login password avatarURL userId <span class="fu">=</span>
    <span class="st">&quot;Full info about user @&quot;</span> <span class="fu">++</span> (show userId) <span class="fu">++</span> <span class="st">&quot;:&quot;</span>  <span class="fu">++</span>
    <span class="st">&quot;\n login: &quot;</span> <span class="fu">++</span> login <span class="fu">++</span>
    <span class="st">&quot;\n password: &quot;</span> <span class="fu">++</span> password <span class="fu">++</span>
    <span class="st">&quot;\n avatar URL: &quot;</span> <span class="fu">++</span> avatarURL

<span class="kw">type</span> <span class="dt">EmptyInfo</span> <span class="fu">=</span> <span class="dt">Login</span> <span class="ot">-&gt;</span> <span class="dt">Password</span> <span class="ot">-&gt;</span> <span class="dt">AvatarURL</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">WithLogin</span> <span class="fu">=</span>          <span class="dt">Password</span> <span class="ot">-&gt;</span> <span class="dt">AvatarURL</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">AndWithPassword</span> <span class="fu">=</span>                <span class="dt">AvatarURL</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">AndWithAvatarURL</span> <span class="fu">=</span>                            <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">String</span>

<span class="ot">storeLoginIn ::</span> <span class="dt">EmptyInfo</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">WithLogin</span>
storeLoginIn emptyInfo userId <span class="fu">=</span>
    emptyInfo <span class="st">&quot;denis&quot;</span>
    <span class="co">{- in real project we should get the login</span>
<span class="co">       according to the passed userId -}</span>

<span class="ot">storePasswordIn ::</span> <span class="dt">WithLogin</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">AndWithPassword</span>
storePasswordIn infoWithLogin userId <span class="fu">=</span>
    infoWithLogin <span class="st">&quot;123456789abc&quot;</span>
    <span class="co">{- in real project we should get the password</span>
<span class="co">    	according to the passed userId -}</span>

<span class="ot">storeAvatarURLIn ::</span> <span class="dt">AndWithPassword</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">AndWithAvatarURL</span>
storeAvatarURLIn infoWithPassword userId <span class="fu">=</span>
    infoWithPassword <span class="st">&quot;http://dshevchenko.biz/denis_avatar.png&quot;</span>
    <span class="co">{- in real project we should get the URL</span>
<span class="co">    	according to the passed userId -}</span>

main <span class="fu">=</span>
    <span class="kw">let</span> userId <span class="fu">=</span> <span class="dv">1234</span>
        infoWithLogin <span class="fu">=</span> storeLoginIn userInfo userId
        infoWithPassword <span class="fu">=</span> storePasswordIn infoWithLogin userId
        infoWithAvatarURL <span class="fu">=</span> storeAvatarURLIn infoWithPassword userId
        fullInfoAboutUser <span class="fu">=</span> infoWithAvatarURL userId
    <span class="kw">in</span>
    putStrLn fullInfoAboutUser</code></pre></div>
<p>Now let’s deconstruct this into pieces.</p>
<p>First of all, a new construction appeared:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Login</span> <span class="fu">=</span> <span class="dt">String</span></code></pre></div>
<p>The keyword <code>type</code> adds an alias for an already known type. Now we can use <code>Login</code> instead of <code>String</code>.</p>
<p>Next, we declared a function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">userInfo ::</span> <span class="dt">Login</span> <span class="ot">-&gt;</span> <span class="dt">Password</span> <span class="ot">-&gt;</span> <span class="dt">AvatarURL</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">String</span></code></pre></div>
<p>This is simple: the function <code>userInfo</code> expects a login, a password, an avatar URL and a user ID and returns a string with description. Pay attention to the double plus sign:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="st">&quot;\n login: &quot;</span> <span class="fu">++</span> login</code></pre></div>
<p>This is a string concatenation operator.</p>
<p>Now the interesting stuff begins. We assume that we only have a user ID and we need to get the corresponding login, password and avatar URL from somewhere. Fortunately we have three functions, each of which knows, where to find login, password and avatar URL correspondingly. And each of them is an HOF.</p>
<p>Let’s consider aliases:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">EmptyInfo</span> <span class="fu">=</span> <span class="dt">Login</span> <span class="ot">-&gt;</span> <span class="dt">Password</span> <span class="ot">-&gt;</span> <span class="dt">AvatarURL</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">WithLogin</span> <span class="fu">=</span>          <span class="dt">Password</span> <span class="ot">-&gt;</span> <span class="dt">AvatarURL</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">AndWithPassword</span> <span class="fu">=</span>                <span class="dt">AvatarURL</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">AndWithAvatarURL</span> <span class="fu">=</span>                            <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">String</span></code></pre></div>
<p>Each of them introduces a simple name for a functional type, which is formed by cutting the type of <code>userInfo</code> function. Note, that the next type expects one argument less that the previous one. These aliases name types for each intermediate λ-function, which are, as you have already guessed, used for partial application of <code>userInfo</code> function.</p>
<p>Consider the first call:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">infoWithLogin <span class="fu">=</span> storeLoginIn userInfo userId</code></pre></div>
<p>Here we pass <code>userInfo</code> function as a first argument of function <code>storeLoginIn</code>, inside which we apply passed function <code>userInfo</code> to the only argument, namely login. Respectively, at <code>storeLoginIn</code> function exit we receive the first intermediate λ-function, in which we saved the login value (that’s why this λ-function type is associated with the word <code>WithLogin</code>).</p>
<p>Next is the call:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">infoWithPassword <span class="fu">=</span> storePasswordIn infoWithLogin userId</code></pre></div>
<p>Here we pass our intermediate λ-function as the first argument of the function <code>storePasswordIn</code>. This function, in turn, applies the λ-function passed to it to the only argument, namely the password. So at <code>storePasswordIn</code> function exit we have the second intermediate λ-function, in which two values are saved: login, received during the previous call and the password from this call.</p>
<p>The same is true for the next call:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">infoWithAvatarURL <span class="fu">=</span> storeAvatarURLIn infoWithPassword userId</code></pre></div>
<p>At <code>storeAvatarURLIn</code> function exit we receive the third λ-function, in which three values are saved: login, password and path to the avatar.</p>
<p>As a result we apply the third λ-function to the last necessary argument, namely the user identifier:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fullInfoAboutUser <span class="fu">=</span> infoWithAvatarURL userId</code></pre></div>
<p>Here occurs the “full” call of function <code>userInfo</code>, as a result of which we receive the string with description:</p>
<pre><code>Full info about user@1234:
 login: denis
 password: 123456789abc
 avatar URL: http://dshevchenko.biz/denis_avatar.png</code></pre>
<p>Thus the function <code>userInfo</code> was partially applied three times, receiving one argument each time, and it received all necessary arguments during the fourth call. This can be compared to conveyor belt, at every step of which the function received the next argument.</p>
<p>But why do we need such complications? We can simply pass just <code>userId</code> to each of these functions and return not the intermediate λ-function, but directly login, password and path to the avatar correspondingly. For example, instead of <code>storeLoginIn</code> function we could define <code>obtainLogin</code> function like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">obtainLogin ::</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">Login</span>
obtainLogin userId <span class="fu">=</span>
    <span class="co">-- obtain login from somewhere and return it</span></code></pre></div>
<p>But what if we don’t want to return login explicitly? Because in case of the partial application we pack the login into the intermediate λ-function (so in fact we hide the login inside it), and in this case we return it and show it to everyone. The first solution might be more suitable.</p>
<p>Or the other example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">UserId</span> <span class="fu">=</span> <span class="dt">Integer</span>
<span class="kw">type</span> <span class="dt">Prefix</span> <span class="fu">=</span> <span class="dt">String</span>

<span class="ot">obtainLogin ::</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> (<span class="dt">Prefix</span> <span class="ot">-&gt;</span> <span class="dt">String</span>)
obtainLogin userId <span class="fu">=</span>
    loginStorage <span class="st">&quot;denis&quot;</span>   <span class="co">-- we assume that the login is somehow obtained</span>
        <span class="kw">where</span> loginStorage login prefix <span class="fu">=</span> prefix <span class="fu">++</span> <span class="st">&quot;: &quot;</span> <span class="fu">++</span> login

main <span class="fu">=</span>
    <span class="kw">let</span> userId <span class="fu">=</span> <span class="dv">1234</span>
    <span class="kw">in</span>
    putStrLn ((obtainLogin userId) <span class="st">&quot;My login&quot;</span>)</code></pre></div>
<p>Let’s learn more about <code>obtainLogin</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">obtainLogin ::</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> (<span class="dt">Prefix</span> <span class="ot">-&gt;</span> <span class="dt">String</span>)
obtainLogin userId <span class="fu">=</span>
    loginStorage <span class="st">&quot;denis&quot;</span>
        <span class="kw">where</span> loginStorage login prefix <span class="fu">=</span> prefix <span class="fu">++</span> <span class="st">&quot;: &quot;</span> <span class="fu">++</span> login</code></pre></div>
<p>Here we obtain the login from somewhere based on the passed user identificator and hide it inside the λ-function created here by us. As a result <code>obtainLogin</code> returns partially applied function, which we apply to the prefix string - and in the end we get the final result.</p>
<pre><code>My login: denis</code></pre>
<p>You might be interested why have I said about λ-functions? Because we don’t have a familiar backslash here:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">where</span> loginStorage login prefix <span class="fu">=</span> prefix <span class="fu">++</span> <span class="st">&quot;: &quot;</span> <span class="fu">++</span> login</code></pre></div>
<p>But it doesn’t matter, as this notation is identical to the λ-form:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">where</span> loginStorage <span class="fu">=</span> \login prefix <span class="ot">-&gt;</span> prefix <span class="fu">++</span> <span class="st">&quot;: &quot;</span> <span class="fu">++</span> login</code></pre></div>
<p>Remember I said earlier that it is better to define a trivial function without declaration? This is the exact same case.</p>
<p>It’s done. Now you know about higher-order functions. It’s because of functions in Haskell can be used as values, we can make flexible combinations from those.</p>

<div style="padding-top: 30px;"><div>
<div class="row">
    <div class="col s6">
        <div class="left">
            <a href="../../en/about-functions/lambda-functions.html" class="btn waves-effect waves-light chapter-arrow">
                <span class="fa fa-angle-double-left"></span>
            </a>
        </div>
    </div>
    
    <div class="col s6">
        <div class="right">
            <a href="../../en/about-functions/functional-chains.html" class="btn waves-effect waves-light chapter-arrow">
                <span class="fa fa-angle-double-right"></span>
            </a>
        </div>
    </div>
</div>
<div style="padding-top: 40px;"><div>

<!--
<div>
    <script>
      (function() {
        var cx = '007697214108744450483:au850gpbupm';
        var gcse = document.createElement('script');
        gcse.type = 'text/javascript';
        gcse.async = true;
        gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
            '//cse.google.com/cse.js?cx=' + cx;
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(gcse, s);
      })();
    </script>
    <gcse:search></gcse:search>
</div>
-->

<!--
<div>
    <div class="row">
        <form class="col s12" 
              id="searchbox_007697214108744450483:au850gpbupm" 
              action="http://www.google.com/cse">
          <div class="row">
            <div class="input-field col s6">
              <i class="material-icons prefix">search</i>

              <input value="007697214108744450483:au850gpbupm" name="cx" type="hidden"/>
              <input value="FORID:11" name="cof" type="hidden"/>

              <input id="icon_prefix" name="q" type="text"/>
              <label for="icon_prefix">Что ищем?</label>
            </div>
          </div>
        </form>
    </div>
</div>
-->

<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'ohaskell'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
 

        </div>
    </body>
</html>