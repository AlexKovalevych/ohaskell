Where we can use it
-------------------

Почти везде. Haskell, будучи универсальным языком, прекрасно подходит для самых разных сегментов ПО. Это и клиент-серверное программирование, и консольные утилиты, и десктопные приложения с GUI, и мобильные приложения, и даже веб-разработка. Причём Haskell не просто *может* использоваться в этих областях, но использоваться *эффективно*.

### Почему

#### Высокоуровневый синтаксис

Haskell-код сопоставим с кодом на скриптовых языках. Поэтому его весьма легко читать, а следовательно, и сопровождать. Скоро вы и сами в этом убедитесь. Разумеется, на Haskell можно написать и совершенно нечитабельный хлам, однако это справедливо для любого языка программирования.

#### Автоматическое управление памятью

На дворе 2014 год, и при всём моём уважении к старому доброму C, думать о том, как, где и когда выделить N байтов памяти - это каменный век. Haskell избавляет разработчика от жонглирования байтиками, беря на себя выделение и освобождение памяти.

#### Строгая статическая типизация

В силу того, что ошибки с типами отлавливаются на этапе компиляции, мы получаем более надёжный код. Впрочем, не рассматривайте это как камень в огород динамических языков (межъязыковые войны выходят за рамки этой книги).

#### Компилируемость

Код, написанный на Haskell, компилируется в обыкновенный, канонический исполняемый файл. Мы получаем быстрое приложение, не зависящее ни от интерпретаторов, ни от дополнительных runtime environments.

#### Готовые решения

Для Haskell существует множество готовых свободных библиотек. Нет, не все они идеальны, но есть и множество таких, которые давно и успешно испытаны в реальных проектах. Так что изобретать велосипед не придётся.

#### Параллельный мир

На страницах этой книги мы не будем рассматривать параллельное и многопоточное программирование, поскольку это обширная тема, которой посвящена [отдельная книга](http://chimera.labs.oreilly.com/books/1230000000929). Скажу лишь, что, в силу чисто-функциональной природы Haskell, распараллеливать код на нём [значительно проще](https://www.fpcomplete.com/blog/2012/04/the-downfall-of-imperative-programming), чем на императивных языках. 

### Главное ограничение

Да, есть одна область не для Haskell. Речь идёт о низкоуровневой разрабтке, приближенной к железу. Там, где критически важна скорость выполнения кода, там, где требуется ручное управление памятью по причине малого её объёма, там, где размер исполняемого файла ограничен десятками килобайт - там Haskell не подходит. Поэтому если вам нужно написать какой-нибудь высокопроизводительный драйвер или часть ядра операционной системы - посмотрите в сторону других языков.

Ну а теперь - начнём наше изучение.

