----
title: Составные типы
prevChapter: /en/about-user-types/type-context.html
nextChapter: /en/about-user-types/deriving.html
----

вспомним наш демонстрационный тип `IPAddress`, который мы использовали до сих пор:

```haskell
data IPAddress = IPAddress String
```

Даже столь простой тип может быть весьма полезен в реальных проектах. И всё же очень часто нам нужны более сложные типы. О них и поговорим в этой главе.

## Поля

Определим тип User:

```haskell
data User = User { firstName :: String
                 , lastName :: String
                 , email :: String
                 }
``` 

Это уже значительно интереснее. Перед нами - классический составной тип. Он очень похож на структуру в языке C, однако это впечатление обманчиво. Рассмотрим вот эту конструкцию:

```haskell
firstName :: String
```

Перед нами - поле. Впрочем, при кажущейся простоте, оно как шляпа фокусника, с двойным дном. С одной стороны, это значение типа `String`. С другой стороны - это (автоматически создаваемая компилятором) функция, позволяющая получить доступ к этому значению. Поэтому при создании значения типа `User` мы сначала инициализируем все три его поля, а потом сможем получить доступ к значениям этих полей. Вот так:

```haskell
main =
    print $ firstName user ++ " " ++
            lastName user ++ ", " ++
            email user
    where user = User { firstName = "Denis"
                      , lastName = "Shevchenko"
                      , email = "me@dshevchenko.biz"
                      }
```

Вывод:

```haskell
"Denis Shevchenko, me@dshevchenko.biz"
```

Применяя каждую из "полевых" функций к значению типа `User`, мы получаем доступ к соответствующему "полевому" содержимому, заданному при инициализации. Разумеется, все три значения константны.

## Что с ними можно делать

Как обычно: создавать, сохранять, использовать, изменять. Стоп... Я сказал "изменять"? Так значит, поле можно изменить??

Конечно нет. Когда мы пишем:

```haskell
email = "me@dshevchenko.biz"
```

мы тем самым объявляем: "Всё! С этого мгновения и до конца времён функция `email`, применённая к этому значению типа `User`, будет возвращать значение `"me@dshevchenko.biz"` и никакое другое". Однако есть один способ, создающий _впечатление_ изменяемости поля. Смотрите:

```haskell
changeEmail :: User -> String -> User
changeEmail user newEmail = user { email = newEmail }
```

Эта функция меняет текущее значение поля `email` на значение `newEmail`, используя тот же синтаксис фигурных скобок, что и при создании `user`. Однако, сказав об отсутствии присваивания в Haskell, я не обманул вас. Поэтому значение поля `email` у аргумента `user` конечно же не изменится.

Обратите внимание на сигнатуру этой функции:

```haskell
changeEmail :: User -> String -> User
```

Мы возвращаем значение типа `User`, но это уже не то значение, которое идёт первым аргументом. Здесь мы говорим: "Возьми аргумент `user` и создай на его основе такое же значение, но лишь с тем исключением, что значение поля `email` в этом новом значении будет равным `newEmail`". И теперь мы можем написать так:

```haskell
main =
    let userWithNewEmail = changeEmail user "shev.denis@gmail.com"
    in
    print $ email userWithNewEmail
    where user = User { firstName = "Denis"
                      , lastName = "Shevchenko"
                      , email = "me@dshevchenko.biz"
                      }
```

Вывод будет таким:

```haskell
"shev.denis@gmail.com"
```

## Укороченная запись типов полей

Мы должны явно указывать типы всех наших полей. Однако если эти типы одинаковы, можно использовать сокращённую запись.

Вспомним наш тип:

```haskell
data User = User { firstName :: String
                 , lastName :: String
                 , email :: String
                 }
```

Все три поля имеют одинаковый тип, мы можем переписать объявление так:

```haskell
data User = User { firstName
                 , lastName
                 , email :: String
                 }
```

Перечисляем поля и в конце указываем их тип. Кроме того, поля могут объединяться и по нескольким типовым группам:

```haskell
data User = User { firstName
                 , lastName
                 , email :: String
                 , account
                 , uid :: Integer
                 }
```

Здесь у нас появились два новых поля, и мы опять использовали сокращённую типовую запись: группа из первых трёх полей имеет тип `String`, в то время как группа из полей `account` и `uid` имеет тип `Integer`.

## Конструктор типа

Помните, мы уже говорили о конструкторах? Но там речь шла о конструкторах значений, а теперь поговорим о конструкторах типов. Различаются они так: конструктор значения используется при создании значений, а конструктор типа - при создании типов.

Добавим в тип `User` чуток гибкости:

```haskell
data User y = User { firstName          -- строка
                   , lastName           -- опять строка
                   , email :: String    -- ещё одна строка
                   , yearOfBirth :: y   -- а это что??
                   , account            -- целое число
                   , uid :: Integer     -- тоже целое число
                   }
```

Вот эта строка:

```haskell
data User y = ...
``` 

говорит нам о том, что перед нами конструктор типа (type constructor). Тип поля `yearOfBirth` задан полиморфным типом `y`. Это позволит нам инициализировать это поле как числом `1981`, так и, например, строкой `"1981"`.

Однако нас поджидает один неприятный сюрприз, ведь функция `changeEmail` наотрез откажется работать с типом `User`. Но не ругайтесь на неё, она поступает абсолютно правильно. Вспомним её объявление:

```haskell
changeEmail :: User -> String -> User
```

Она ожидает, что первым аргументом идет значение типа `User`, но ведь `User` - это уже не тип, а конструктор типа. Теперь мы должны любезно попросить его сконструировать для нас конкретный тип. Чтобы это сделать, мы должны применить конструктор типа к типу. Если функция применяется к значению, то конструктор типа применяется непосредственно к типу. Прямо так и пишем:

```haskell
User String
```

В результате применения конструктора `User` к типу `String` был создан тип, аналогичный такому:

```haskell
data User = User { firstName      
                 , lastName  
                 , email
                 , yearOfBirth :: String
                 , account
                 , uid :: Integer
                 }
```

Больше нет никакого полиморфного типа `y`, потому что тип поля `yearOfBirth` теперь равен типу `String`.

Следовательно, чтобы наша функция `changeEmail` смогла работать с типами, сконструированными конструктором `User`, это нужно явно указать в её объявлении:

```haskell
changeEmail :: User String -> String -> User String
```

Можно написать и так:

```haskell
changeEmail :: (User String) -> String -> (User String)
``` 

Мы говорим нашей функции: "Первым аргументом ты теперь принимаешь значение типа, сконструированного путём применения конструктора `User` к типу `String`. Возвращаешь то же самое".

Разумеется, мы можем воспользоваться полиморфным типом и здесь:

```haskell
changeEmail :: User a -> String -> User a
```

Теперь мы говорим этой функции: "Теперь в качестве аргумента ты принимаешь значение типа, который был создан конструктором `User`, применённым к некоторому типу `a`". Такой подход удобен в том случае, если мы не знаем заранее, какой конкретный тип будет подставлен вместо полиморфного.

## В сухом остатке

* Тип может содержать в себе одно или несколько полей.
* Поле - это и константное значение, и автоматически создаваемый компилятором getter для этого значения.
* Синтаксис фигурных скобок используется как для инициализирования полей, так и для их "изменения".
* Тип поля может быть указан как индивидуально, так и в составе группы полей.
* Тип поля может быть полиморфным. В этом случае составной тип превращается в конструктор типа - в конструкцию, способную порождать бесчисленное множество конкретных типов.

