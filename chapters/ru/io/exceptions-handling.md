----
title: Обработка исключений
prevChapter: /ru/io/do-imperative-world.html
nextChapter: /ru/io/own-exceptions.html
----

Мы все стремимся создавать программные системы, свободные от ошибок. И всё же иногда они появляются, а значит, нам приходится иметь с ними дело. Поговорим об исключениях, тем более что знать о них необходимо: многие пакеты из Hackage содержат код, кидающийся этими самыми исключениями.

Прежде всего, нам понадобится модуль `Control.Exception`:

```haskell
import Control.Exception
```

Этот стандартный модуль предназначен для кидания и ловли исключений, причём как стандартных, так и наших собственных. Важно отметить: мы можем бросить исключение как из чистых функций, так и из функций с побочными эффектами, однако поймать его в чистой функции мы не сможем.

## Проблема с файлом

Чаще всего мы будем сталкиваться с исключениями, брошенными из функций, взаимодействующих с внешним миром. Канонический пример: мы хотим прочесть содержимое файла, который отсутствует:

```haskell
main :: IO ()
main = do
    fileContent <- readFile "Users/shevchenko/test.c"  -- Неверный путь...
    putStrLn fileContent
```

Вывод будет таким:

```bash
Real: Users/shevchenko/test.c: openFile: does not exist (No such file or directory)
```

Функция `readFile` бросила исключение, ведь сообщить о проблеме с файлом она может только так. Исключение, не найдя преград на своём пути, было поймано уже на самом верхнем уровне приложения, после чего сообщение об ошибке было выведено нам, а само приложение скоропостижно скончалось.

## Ловим

Итак:

```haskell
import Control.Exception 

tryToOpenFile :: FilePath -> IO String
tryToOpenFile path =
    readFile path `catch` possibleErrors
    where
        possibleErrors :: IOException -> IO String
        possibleErrors error = return $ show error

main :: IO ()
main = do
    fileContent <- tryToOpenFile "Users/shevchenko/test.c"
    putStrLn fileContent
```

Теперь у нас есть функция `tryToOpenFile`, которая открывает файл по заданному пути, но делает это осторожно, используя функцию `catch`. Как вы уже поняли, функция catch, определённая в модуле `Control.Exception`, умеет ловить исключения. Вот её объявление:

```haskell
catch :: Exception e => IO a -> (e -> IO a) -> IO a
```

Функция принимает два аргумента: первым идёт `IO`-действие, вторым идёт функция-обработчик. Если действие бросило исключение, отражённое полиморфным типом `e`, это исключение будет передано обработчику.

Обратите внимание: тип исключения входит в контекст класса Exception, определённого в том же модуле `Control.Exception`. Любое исключение в вашем приложении обязано входить в контекст этого класса.

Для большей читабельности мы используем инфиксную запись функции `catch`, с которой гармонирует имя нашего обработчика:

```haskell
readFile path `catch` possibleErrors
```

Если при чтении файла возникла проблема, соответствующее исключение поступает на вход нашего обработчика:

```haskell
possibleErrors :: IOException -> IO String
possibleErrors error = return $ show error
```

Обработчик принимает значение типа `IOException`. В теле обработчика мы стрингифицируем полученное исключение, а затем готовую строку, содержащую описание произошедшей ошибки, заворачиваем в действие `IO String`. Если же нас не устраивает уже имеющееся сообщение об ошибке - предоставим своё:

```haskell
possibleErrors error = return "Unable to open this file. Please check it."
```

Это сообщение и будет выведено на экран в случае возникновения проблемы.

## Ловим наоборот

Перепишем нашу функцию:

```haskell
tryToOpenFile :: FilePath -> IO String
tryToOpenFile path =
    handle possibleErrors (readFile path)  -- То же самое, но наоборот.
    where
        possibleErrors :: IOException -> IO String
        possibleErrors error = return "Aaaaa!!! Please check file."
```

Мы заменили функцию `catch` на функцию `handle`. Никакой разницы между этими функциями нет, за исключением порядка следования аргументов: `catch` принимает обработчик вторым по счёту, а `handle` - первым. Таким образом, `catch` читабельнее в инфиксной форме, а `handle` - в простой. Так что выбирайте на вкус.

## Пытаемся

Стандартная функция `try` использует иной подход. Вот пример:

```haskell
import Control.Exception

main :: IO ()
main = do
    result <- try $ readFile path :: IO (Either IOException String)
    case result of
        Left exception -> putStrLn $ "Fault: " ++ show exception
        Right content -> putStrLn content
    where path = "Users/dshevchenko/test.c"
```

Разберём по полочкам.

Объявление функции `try` выглядит так:

```haskell
try :: Exception e => IO a -> IO (Either e a)
```

Эта функция принимает наше `IO`-действие, а возвращает другое `IO`-действие, которое в свою очередь возвращает значение стандартного типа `Either e a`. `Either` - это конструктор типа, предназначенный для хранения одного из двух значений, каждое из которых соответствует хорошему результату и плохому. Обратите внимание, мы явно указали тип значения, возвращённого функцией `try`:

```haskell
try $ readFile path :: IO (Either IOException String)
```

Мы сказали: "Пусть действие, возвращённое функцией `try`, вернёт нам значение типа `Either IOException String`, в котором будет лежать либо значение типа `IOException` (в случае, если при чтении файла что-то случилось), либо значение типа `String` с содержимым файла".

Далее смотрим, получилось ли у нас:

```haskell
case result of
    Left exception -> putStrLn $ "Fault: " ++ show exception
    Right content -> putStrLn content
```

Тип `Either` имеет два конструктора, `Left` и `Right`. В нашем случае это можно изобразить так:

    Either IOException String
           |           |
           Left        Right

Используя эти два конструктора, мы можем понять, что же произошло. Конструкция `case-of` поможет нам. Мы говорим: "Если `result` соответствует левому значению - это значение типа `IOException`. Что-то пошло не так, выводим исключение на экран! Ну а если `result` соответствует правому значению - перед нами `String`. Всё прошло успешно, выводим на экран содержимое прочитанного файла".

## В чистом мире

Иногда нам нужно поймать исключение, брошенное из чистой функции. Например:

```haskell
import Control.Exception

main :: IO ()
main = do
    result <- try $ 2 `div` 0 :: IO (Either SomeException Integer)
    case result of
        Left exception -> putStrLn $ "Fault: " ++ show exception
        Right value -> print value
```

Здесь мы попытались проверить результат деления числа 2 на ноль. К сожалению, этот код не пройдёт компиляцию. Ведь функция `try` ожидает на вход `IO`-действие, однако стандартная функция `div` чиста и возвращает обыкновенное число. Следовательно, нам нужен маленький трюк:

```haskell
import Control.Exception

main :: IO ()
main = do
    result <- try $ evaluate $ 2 `div` 0
                    :: IO (Either SomeException Integer)
    case result of
        Left exception -> putStrLn $ "Fault: " ++ show exception
        Right value -> print value
```

Мы обернули вызов функции `div` в стандартную функцию `evaluate`. Теперь всё скомпилируется, и при запуске мы получим ожидаемое нами гневное сообщение:

```bash
Fault: divide by zero
```

Функция `evaluate` объявлена так:

```haskell
evaluate :: a -> IO a
```

Эта функция играет роль адаптера: она как бы превращает результат в `IO`-действие, возвращающее этот результат. И после того, как функция `div` вернула нам обыкновенное число, функция `evaluate` обернула это число в действие, ожидаемое функцией `try`.

## В сухом остатке

1. Исключение может быть брошено из любой функции, но обработать его мы сможем только в IO-функции.
2. Функция `catch` ловит исключение и передаёт его обработчику.
3. Функция `handle` - зеркальная сестра функции `catch`.
4. Функция `try` работает в сотрудничестве с конструктором типа `Either`. Анализируя порождённое этим типом значение, мы поймём, возникла ли проблема в интересующей нас функции, или всё прошло гладко.
5. Для работы с `try` чистую функцию следует поместить в `evaluate`-обёртку.

Почти готово. Но наше рассмотрение исключений не было бы полным без изучения наших собственных исключений.

