----
title: do: императивный мир
prevChapter: /ru/io/IO-a.html
nextChapter: /ru/io/exceptions-handling.html
----

Вы прочли правильно: императивный мир. Несмотря на то, что Haskell является чисто функциональным языком, в случае необходимости мы можем написать императивный код. А при работе с внешним миром такая необходимость возникает постоянно.

Как вы знаете, императивный подход подразумевает выполнение программных инструкций в чётко указанном порядке. В чистых функциях такой подход излишен, потому что в них неважен порядок вычисления выражений. Однако в функциях, взаимодействующих с внешним миром, ситуация кардинально меняется.

Вспомним наш пример работы со стандартными вводом и выводом:

```haskell
main :: IO ()
main = do
    putStrLn "Input your text, please:"
    lineFromUser <- getLine               
    putStrLn $ "Not bad: " ++ lineFromUser   
```

Здесь мы делаем три шага:

1.  выводим на экран приветственную строку;
2.  дожидаемся, пока пользователь введёт свой текст;
3.  выводим на экран итоговую строку.

Разумеется, мы ожидаем, что эти три шага будут выполнены именно в _таком_ порядке. Согласитесь, было бы странно выводить на экран итоговую строку, не дождавшись введённого пользователем текста. При работе с внешним миром мы всегда подразумеваем определённый порядок наших шагов. Например, сервер, получив запрос от клиента, должен сначала его обработать, потом сформировать ответ, и только потом отправить его клиенту.

Именно для этой цели и введено ключевое слово `do`: оно связывает наши действия в последовательную цепочку. Говоря об этом ключевом слове, обычно используют термин "do-нотация".

## Не только main

Мы можем использовать do-нотацию в любой функции с побочными эффектами. Например:

```haskell
obtainUserText :: String -> IO String
obtainUserText prompt = do
    putStrLn prompt  -- Выведи приглашение ввести строку.
    getLine          -- Получи от пользователя некую строку.

main :: IO ()
main = do
    firstText <- obtainUserText "Enter your text, please: "
    secondText <- obtainUserText "One more, please: "
    putStrLn $ "You said '" ++ firstText ++ "' and '" ++ secondText ++ "'"
```

Функция `obtainUserText` заключает в себе два последовательных шага, поэтому в ней тоже используется слово `do`. Мы ожидаем, что сначала будет выведено соответствующее приглашение на экран, и только после этого действие, порождённое функцией `getLine`, отправится во внешний мир и вернётся оттуда с введённой пользователем строкой.

## О функции return

В языке C есть ключевое слово `return`, задающее точку возврата из функции. В Haskell нет такого ключевого слова, зато есть такая функция. И чтобы продемонстрировать её назначение, рассмотрим другой пример:

```haskell
obtainTwoTextsFromUser :: IO String
obtainTwoTextsFromUser = do
    putStrLn "Enter your text, please: "
    firstText <- getLine
    putStrLn "One more, please: "
    secondText <- getLine
    "'" ++ firstText ++ "' and '" ++ secondText ++ "'" -- Простая строка??

main :: IO ()
main = do
    twoTexts <- obtainTwoTextsFromUser
    putStrLn $ "You said " ++ twoTexts
```

Функция `obtainTwoTextsFromUser` берёт на себя ответственность последовательно получить от пользователя два текста и вернуть составленную из них строку. Но, к сожалению, такой код не пройдёт компиляцию, ибо эта функция возвращает действие, однако последней по счёту инструкцией идёт вовсе не действие, а обыкновенная строка. Тут-то и приходит нам на помощь стандартная функция `return`.

Перепишем эту функцию:

```haskell
obtainTwoTextsFromUser :: IO String
obtainTwoTextsFromUser = do
    putStrLn "Enter your text, please: "
    firstText <- getLine
    putStrLn "One more, please: "
    secondText <- getLine
    return $ "'" ++ firstText ++ "' and '" ++ secondText ++ "'"
```

Императивно выглядит, не правда ли? Только не забывайте, что с ключевым словом `return` в языке C такая запись не имеет ничего общего.

Функция `return` берёт значение и оборачивает его в действие, возвращающее это значение. В нашем случае мы передали ей строку, составленную из пользовательских текстов, а на выходе получили действие, возвращающее эту строку. Поэтому теперь наш код успешно скомпилируется.

Кстати, чтобы доказать вам, что функция `return` действительно не имеет никакого отношения к ключевому слову `return` в C-подобных языках, я позволю себе небольшое хулиганство:

```haskell
obtainTwoTextsFromUser :: IO String
obtainTwoTextsFromUser = do
    putStrLn "Enter your text, please: "
    firstText <- getLine
    putStrLn "One more, please: "
    secondText <- getLine
    return $ "'" ++ firstText ++ "' and '" ++ secondText ++ "'"
    putStrLn "And third text, please: " -- Мы всё ещё продолжаем наш диалог!
    getLine
```

Это может сбить с толку программистов, имеющих опыт в императивном программировании, но, как уже и было сказано выше, функция `return` всего лишь оборачивает значение в действие, возвращающее это значение. Она не прерывает ход наших действий, и если за ней есть другие действия, они спокойно продолжат выполняться. Фактически, в этой хулиганской функции мы потеряем два первых пользовательских текста и вернём действие, которое принесёт нам только третий текст.

## В сухом остатке

1. `do` связывает действия в последовательную цепочку.
2. Функция `return` оборачивает значение в IO-действие. Не путайте эту функцию с ключевым словом `return` в C-подобных языках.

Готово. Теперь вы знаете о ключевом слове `do`. Впрочем, пока вы не знаете о нём самого интересного, но это чуть позже.

