----
title: IO a
prevChapter: /ru/io/functions-with-side-effects.html
nextChapter: /ru/io/do-imperative-world.html
----

Итак, для работы с внешним миром нам нужны действия. А действие представляет собой значение типа `IO a`, где `IO` - это стандартный тип действия, а `a` - это полиморфный тип значения, возвращённого этим действием. Как вы уже поняли, `IO` - это конструктор типа. Поэтому тип действия, возвращающего строку, будет `IO String`.

С логической точки зрения, действие - это наш посол, который по нашей просьбе уходит во внешний мир, делает там какую-то работу, а потом приносит нам из внешнего мира что-нибудь интересное. Впрочем, иногда он может вернуться из внешнего мира и с пустыми руками.

## Стандартные ввод и вывод

Начнём со стандартных каналов stdout и stdin. Выведем строку на экран:
 
```haskell
main = putStrLn "Hi Haskeller!"
```

Взглянем на объявление функции `putStrLn`:

```haskell
putStrLn :: String -> IO ()
```

Перед нами `IO`, а значит, данная функция имеет побочное действие. На входе у нас строка, а на выходе - действие. Рассмотрим его поближе:

```haskell
IO ()
```

Одинокие круглые скобки говорят нам о пустом кортеже. Следовательно, перед нами действие, которое, сделав во внешнем мире свою работу, ничего нам не принесёт. Мы, посылая это действие во внешний мир, говорим ему: "Пойди и просто напечатай на экране компьютера переданную тебе строку". Но раз уж создатели Haskell договорились о том, что действие обязано что-то вернуть - пусть оно возвращает пустой кортеж. Это как `void`-функция в языке C: можно сказать, что она не возвращает ничего, а можно сказать, что она возвращает `void`.

Теперь взглянем на объявление функции `getLine`, получающей строку со стандартного ввода:

```haskell
getLine :: IO String
```

Тут противоположная ситуация. Эта функция ничего не принимает от нас, потому что нам нечего ей дать, и порождённое этой функцией действие идёт во внешний мир с пустыми руками. Мы говорим ему: "Пойди, получи со стандартного ввода строку и принеси её нам".

## Объявляем main

Теперь мы наконец-то можем взглянуть на объявление главной функции приложения:

```haskell
main :: IO ()
```

Функция `main` тоже совершает действие - работу всего нашего приложения. Она ничего не возвращает в приложение, ведь при её завершении заканчивается всё. Разумеется, все действия в нашем приложении спят крепким сном и ничего не делают до тех пор, пока не будет запущено действие функции `main`.

Мы до сих пор не писали объявление этой функции, потому что только сейчас узнали об `IO`. Но, строго говоря, мы должны это делать. Хотя бы для порядка.

## Совместная работа

Вот она:

```haskell
main :: IO ()
main = do
    putStrLn "Input your text, please:"
    lineFromUser <- getLine
    putStrLn $ "Not bad: " ++ lineFromUser
```

Тут всё предельно понятно, за исключением двух новых вещей.

Во-первых, обратная стрелочка `<-`. Взглянем на неё:

```haskell
lineFromUser <- getLine
```

Это - ассоциация. Мы говорим действию, порождённому функцией `getLine`: "Пойди, получи введённую пользователем строку, принеси её нам и привяжи (bind) её к идентификатору `lineFromUser`, чтобы мы cмогли прочесть эту строку".

Во-вторых, мы увидели новое ключевое слово `do`. И о нём стоит поговорить отдельно, что мы и сделаем в следующей главе.

