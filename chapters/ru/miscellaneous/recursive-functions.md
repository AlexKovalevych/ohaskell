----
title: Рекурсивные функции
prevChapter: /ru/miscellaneous/set.html
nextChapter: /ru/miscellaneous/about-apostrophe.html
----

В языке Haskell нет циклических конструкций. Никаких `for`, никаких `while`. Единственный способ явно организовать цикл - рекурсивные функции.

Вы спросите, почему о них не было рассказано раньше, в разделе о функциях? Да потому что в реальных проектах вам редко придётся иметь дело с рекурсивными функциями, ведь почти все повторяющиеся действия вы будете делать без них.

Например, самый распространённый случай циклического действия - итерирование всей последовательности элементов. На практике это будет проход некоторой функцией по всем элементам списка. Но вы уже знаете, что для этого есть функции `map`, `filter` и подобные им. А для итерирования последовательности с условием(ями) вы сможете использовать уже известные вам list comprehensions. А о таких простых вещах, как получение суммы или произведения элементов списка, и говорить нечего.

Иными словами, в большинстве случаев вы и не вспомните о рекурсивных функциях. И всё-таки знать о них полезно, тем более что в некоторых случаях они вам понадобятся.

## Сама себя

Рекурсивной называется функция, в теле которой присутствует вызов её самой. Конечно, мы будем говорить только о простой рекурсии, косвенную же мы рассматривать не будем. Рекурсию называют простой, когда функция `f` вызывает функцию `f`. Если же функция `f` вызывает функцию `g`, вызывающую функцию `f`, говорят о косвенной рекурсии.

Итак:

```haskell
makeListFrom :: a -> Int -> [a]  
makeListFrom value howMany =
    if howMany > 0
    then value : makeListFrom value (howMany - 1)
    else []
```

Эта функция строит список, элементами которого будут значения `value`, количество же элементов будет равным `howMany`. И если мы вызовем её так:

```haskell
main :: IO ()
main = print $ makeListFrom 2 3
```

на выходе получим список из трёх двоек:

```bash
[2,2,2]
```

## Основное правило

Всё, что имеет начало, имеет и конец. Когда рекурсия запущена, нам нужен способ остановить её. Поэтому тело рекурсивной функции должно содержать не только зацикливающий код, но и код, обеспечивающий выход из этого цикла.

Рассмотрим тело нашей функции:

```haskell
if howMany > 0
then value : makeListFrom value (howMany - 1)  -- Запускаю цикл.
else []                                        -- Останавливаю цикл.
```

Перед нами условие, приводящее нас в одну из логических ветвей. Первая ветвь запускает цикл, вторая ветвь останавливает его. Рассмотрим совместную работу этих двух ветвей.

## Погружаемся

Разберём вызов:

```haskell
makeListFrom 2 3
```

В самом начале мы заходим в эту функцию с аргументами `2` и `3`. Следовательно, на этом шаге внутренности данной функции вот такие:

```haskell
makeListFrom 2 3 =
    if 3 > 0
    then 2 : makeListFrom 2 (3 - 1)
    else []
```

Поскольку условие `3 > 0` выполняется, мы попадаем в первую логическую ветвь:

```haskell
2 : makeListFrom 2 (3 - 1)
```

Здесь используется оператор `:`, добавляющий левый операнд в начало списка, выступающего правым операндом. То есть мы хотим добавить значение `2` в начало списка, порождённого правым выражением. Но этим правым выражением идёт повторный вызов нашей функции. Следовательно, запускается цикл, и мы погружаемся.

Взглянем на внутренности нашей функции во время второго вызова:

```haskell
makeListFrom 2 2 =
    if 2 > 0
    then 2 : makeListFrom 2 (2 - 1)
    else []
```

Условие `2 > 0` опять выполняется, значит, мы опять попадаем в первую логическую ветвь:

```haskell
2 : makeListFrom 2 (2 - 1)
```

Только мы собрались добавить значение `2` в начало списка, порождённого правым выражением - и тут опять входим в очередной вызов нашей функции. Её внутренности такие:

```haskell
makeListFrom 2 1 =
    if 1 > 0
    then 2 : makeListFrom 2 (1 - 1)
    else []
```

И снова условие `1 > 0` выполняется, поэтому мы опять входим в первую ветвь:

```haskell
2 : makeListFrom 2 (1 - 1)
```

И вновь мы, желая добавить значение `2` в начало списка, порождённого правым выражением, погружаемся в очередной вызов нашей функции. Вот что внутри:

```haskell
makeListFrom 2 0 =
    if 0 > 0
    then 2 : makeListFrom 2 (0 - 1)
    else []
```

Условие `0 > 0` уже не выполнится, поэтому мы окажемся во второй логической ветви. А в ней - пустой список. Всё, мы дошли до дна, наша рекурсия остановилась.

## Всплываем

Теперь начинается "обратная логическая раскрутка" наших вложенных вызовов. Именно в процессе это обратной раскрутки и происходит вся работа, ведь до тех пор, пока мы не дошли до "рекурсивного дна", никакой работы мы ещё не сделали. Мы каждый раз собирались добавить значение в начало списка - и тут же погружались в очередной вызов. Поэтому формирование готового списка начинается с того самого пустого списка, который был возвращён последним вызовом нашей функции.

Схематично наше всплытие можно изобразить так:

```haskell
makeListFrom 2 3                  -- Зашли в функцию впервые.
    2 : makeListFrom 2 2          -- Первый рекурсивный вызов.
        2 : makeListFrom 2 1      -- Второй рекурсивный вызов.
            2 : makeListFrom 2 0  -- Третий рекурсивный вызов.
                []                -- Последний рекурсивный вызов.
```

Четвёртый вызов вернул пустой список, поэтому всплытие приобрело следующий вид:

```haskell
makeListFrom 2 3  
    2 : makeListFrom 2 2      -- Первый рекурсивный вызов.
        2 : makeListFrom 2 1  -- Второй рекурсивный вызов.
            2 : []            -- Третий рекурсивный вызов.
```

Наша функция на третьем рекурсивном вызове получила пустой список и добавила в его начало значение `2`, в результате чего появится список с одним значением.

Далее будет так:

```haskell
makeListFrom 2 3  
    2 : makeListFrom 2 2  -- Первый рекурсивный вызов.
        2 : [2]           -- Второй рекурсивный вызов.
```

На втором рекурсивном вызове функция получила список, состоящий из одного значения, и добавила в его начало значение `2`, в результате чего появился список уже с двумя значениями.

Следующая ступень:

```haskell
makeListFrom 2 3  
    2 : [2,2]  -- Первый рекурсивный вызов.
```

На первом рекурсивном вызове мы получаем уже список, состоящий из двух значений, и опять добавляем в его начало значение `2`.

Таким образом, завершив наше всплытие с "рекурсивного дна", в месте вызова нашей функции

```haskell
makeListFrom 2 3
```

мы получим наш итоговый список:

```bash
[2,2,2]
```

## В сухом остатке

1. Рекурсивная функция вызывает саму себя, обеспечивая цикличность.
2. Тело рекурсивной функции обязано содержать точку выхода из рекурсивного цикла.
3. Рекурсия немного выворачивает мозг программисту, привыкшему к `for`, но, как заметил один из корифеев программирования Laurence Peter Deutsch, "итерация свойственна человеку, а рекурсия божественна".

