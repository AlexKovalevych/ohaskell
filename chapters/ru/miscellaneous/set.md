----
title: Контейнеры: множество
prevChapter: /ru/miscellaneous/map.html
nextChapter: /ru/miscellaneous/recursive-functions.html
----

Этот контейнер используется почти столь же часто, как и `Map`. Он отражает математическое понятие "множество" и гарантирует, что все хранящиеся в нём значения уникальны. Можете воспринимать `Set` как список, в котором не может быть одинаковых элементов. Рассмотрим работу с этим контейнером.

## Проверяем дубляж

Этот пример - воистину канонический:

```haskell
module Main where

import Data.List.Split (splitOn)
import qualified Data.Set as S

main :: IO ()
main = do
    putStrLn "Please input some unique numbers separated by commas:"
    userNumbers <- getLine
    let numbers = splitOn "," userNumbers
        numbersQuantity = length numbers
        uniqueNumbersQuantity = S.size $ S.fromList numbers
    putStrLn $ if numbersQuantity == uniqueNumbersQuantity
               then "Thanks, you inputed " 
                    ++ show numbersQuantity 
                    ++ " unique numbers."
               else "Sorry, your numbers are not unique..."
```

Раз уж `Set` гарантирует уникальность своих элементов, этим мы и воспользуемся: если количество введённых пользователем значений совпадёт с количеством уникальных значений - значит все они разные, в противном случае имеется дубляж. Естественно, чтобы всё это работало, тип значений, которые мы собираемся запихнуть в `Set`, обязан входить в контекст стандартного класса типов `Ord`.

Вот, собственно, и всё. Главное назначение контейнера `Set` заключается именно в гарантии уникальности его элементов. В остальном этот контейнер тривиален: можно создать, можно проверить/поискать, можно отфильтровать, можно свернуть, можно отсортировать. Всё как обычно.

## И снова о скорости

Помните про `IntMap` из предыдущей главы? То же самое есть и у множества: контейнер `IntSet` предназначен исключительно для хранения целочисленных значений, и тогда, по заверениям автора пакета `containers`, мы получим ощутимый прирост скорости. Интерфейс у `Set` и у `IntSet` практически одинаковый, так что перейти будет просто.

## В сухом остатке

* Множество хранит в себе гарантированно уникальные значения и позволяет совершать различные полезные действия с этими значениями. 
* Для высокоэффективной работы с множествами, в которых хранятся целочисленные значения, рекомендуется использовать `Data.IntSet`.

