----
title: Сравнение с образцом
prevChapter: /ru/miscellaneous/about-modules.html
nextChapter: /ru/miscellaneous/map.html
----

В Haskell есть очень мощный и очень полезный механизм, название которого можно перевести как "сравнение с образцом" (pattern matching). А поскольку у некоторых программистов, пришедших из императивного мира, этот механизм иногда вызывает удивление, о нём необходимо поговорить.

Более того, открою секрет: в предыдущих главах мы уже многократно видели этот механизм в действии. Просто теперь нужно кое-что уточнить.

## Идея

Собственно, название говорит само за себя - сравнение с образцом. Но эта идея не станет понятной без примеров.

Как мы знаем, стандартная функция `head` (определённая в модуле `Prelude`) возвращает первый элемент непустого списка:

```haskell
module Main where

main :: IO ()
main = print $ head [23, 45, 67]
```

Вывод:

```bash
23
```

А теперь давайте взглянем на код этой функции:

```haskell
head :: [a] -> a
head (x : _) = x
```

Хм... С объявлением всё понятно: принимаем список значений некоторого типа и возвращаем значение этого же тип. Но вот определение вызывает у нас вопрос. Круглые скобки вроде бы говорят нам о кортеже, однако функция работает со списком, а не с кортежем.

Перед нами - один из классических случаев pattern matching. То, что мы приняли за кортеж, на самом деле является образцом, с которым и происходит сравнение. Взглянем повнимательнее:

```haskell
(x : _) = x
```

Конструкция в круглых скобках - это концептуальный образец списка. Именно образец, потому-то здесь и нет квадратных скобок. Это удивляет, но лишь до тех пор, пока мы не вспомним, что назначение оператора `:` в том, чтобы добавлять свой левый операнд в начало списка, являющегося правым операндом. Это проясняет картину:

```
( x          :             _       )
  некое      добавляется   некоего
  значение   в начало      списка
```

В результате работы оператора `:` порождается новый список, однако в контексте данного образца нас это не интересует. Более того, нас даже не интересует содержимое списка, в начало которого мы добавляем `x`, поэтому мы используем пустышку `_`. Нас интересует исключительно `x`, ведь именно `x` ассоциируется с первым элементом того самого пустышечного списка. И чтобы завершить сравнение с образцом, мы объявляем равенство:

```haskell
head (x : _) = x
```

Теперь функция `head` вернёт нам тот самый `x`. А чтобы стало совсем понятно, подставим наш реальный список, и вот что получится:

```haskell
head (23 : [45, 67]) = 23
      --               --
```

Мы как бы говорим: "Пусть функция `head` вернёт нам *то*, что нужно было бы добавить в начало списка `[45, 67]`, чтобы получился список `[23, 45, 56]`". А этим *то* и является значение 23.

Кстати, имя `x` не является каким-то особенным. Мы могли бы использовать и любое другое имя:

```haskell
head :: [a] -> a
head (firstElement : _) = firstElement
```

## Дублируем элемент

Рассмотрим другой пример. Определим функцию, дублирующую первый элемент списка:

```haskell
module Main where

duplicateFirstElement :: [a] -> [a]
duplicateFirstElement (x : xs) = x : x : xs

main :: IO ()
main = print $ duplicateFirstElement [23, 45, 67]
```

Вывод:

```bash
[23,23,45,67]
```

Рассмотрим сравнение в теле функции `duplicateFirstElement` внимательнее:

```haskell
(x : xs) = x : x : xs
```

Имена `x` и `xs` в подобных образцах - не более чем дань традиции. А раз так, заменим их на более понятные:

```haskell
(firstElement : otherElements) = firstElement : firstElement : otherElements
```

Теперь мы уже не может использовать пустышку `_`, поскольку нас *интересует* переданный нам список. И для большей ясности добавим наши реальные значения:

```haskell
(23 : [45, 67]) = 23 : 23 : [45, 67] = [23, 23, 45, 67]
 --   ========    --   --   ========    --  --  ======
```

Полагаю, теперь всё предельно понятно.

## Несколько образцов

Да, их может быть несколько. Определим функцию, берующую вершины из двух переданных ей списков и возвращающую кортеж, составленных из этих вершин:

```haskell
module Main where

takeTwoHeads :: [a] -> [a] -> (a, a)
takeTwoHeads (x : _) (y : _) = (x, y)

main :: IO ()
main = print $ takeTwoHeads [23, 45, 67] [89, 93]
```

Результат:

```bash
(23,89)
```

Данное сравнение уже не требует пояснений:

```haskell
takeTwoHeads (x  : _       ) (y  : _   ) = (x,  y)

takeTwoHeads (23 : [45, 67]) (89 : [93]) = (23, 89)
              --              ==            --  ==
```

Как вы уже поняли, комбинировать образцы можно многими способами.

## 


