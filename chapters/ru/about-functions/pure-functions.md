----
title: Чистые функции
prevChapter: /ru/about-functions/index.html
nextChapter: /ru/about-functions/lambda-functions.html
----

Раз уж Haskell - чисто функциональный язык программирования, поговорим о чистых функциях, как об одном из краеугольных камней этого языка.

Для начала вспомним школьный курс математики и сформулируем простейшее определение функции:

> **Функция - это описание зависимости чего-то от чего-то.**

Так вот чистые функции в Haskell - это и есть функции в математическом смысле. Они представляют собой описание того, как входное значение определяет выходное значение.

Отсюда вытекает важнейшая характеристика чистых функций, а именно отсутствие побочных эффектов. Значение на входе чистой функции всецело и полностью определяет значение на выходе. Поэтому если мы миллион раз подадим на вход одно и то же значение, то на выходе мы миллион раз гарантированно получим один и тот же результат.

## Объявляем

Как и во многих других языках программирования, функцию сначала нужно объявить. Сделаем же это:
```haskell
simpleSum :: Int -> Int
```
До символа `::` указывается имя функции, а после - тип.

```
simpleSum :: Int -> Int
|       |    |        |
   имя          тип 
```

Я понимаю, словосочетание "тип функции" звучит странно, но в мире Haskell так: чистая функция - это значение, имеющее тип функции. Рассмотрим описание этого типа:
```haskell
Int -> Int
```
Обратите внимание на стрелочку. Именно эта стрелочка и говорит нам о том, что перед нами - чистая функция. Слева от неё указан тип единственного аргумента (в данном случае это стандартный тип `Int`), а справа от неё - тип выходного значения (тот же `Int`). Саму же стрелочку можно воспринимать как ментальное указание на поток информации, движущийся через функцию: от её входа к выходу, слева направо.

Напоминаю, что чистая функция обязана иметь хотя бы один аргумент и обязана что-то возвращать, ведь это и отражает суть математической функции: что-то обязательно подаём на вход и что-то обязательно получаем на выходе.

Кстати, о количестве аргументов. Разумеется, чистая функция может принимать и несколько аргументов. Вот тип функции, принимающей три аргумента:
```haskell
Int -> Int -> Int -> Int
```
Читать эту запись следует так: ищем последнюю по счёту (самую правую) стрелочку - она-то и будет тем самым разделителем: слева от неё идёт список типов аргументов, справа - тип возвращаемого выражения:

```
Int -> Int -> Int -> Int
типы аргументов  |  |тип возвращаемого значения
```

## Определяем

Теперь функцию необходимо определить. Кстати, определить нужно обязательно. Например, в языке C или C++ мы можем спокойно объявить функцию и не определять её (при условии, что она никогда не вызывается). В Haskell более строгий подход: если объявил функцию - будь добр и определить её, в противном случае компилятор выскажет своё категорическое недовольство.

Поэтому сразу же после объявления пишем определение:
```haskell
simpleSum :: Int -> Int
simpleSum value = value + value
```
Здесь ментальным разделителем является знак равенства. Скелет данного выражения можно представить так:

    NAME ARGUMENTS = BODY_EXPRESSION 

где `NAME` - имя функции, `ARGUMENTS` - список имён аргументов (имён, а не типов), а `BODY_EXPRESSION` - тело функции. В данном случае у нас имеется один-единственный аргумент по имени `value`, а также имеется простое тело, в котором мы просто складываем аргумент с самим собой.

## Вызываем

Теперь нашу функцию можно вызывать. Сделаем же это с аргументом `4`, или, как принято говорить в мире ФП, применим нашу функцию к аргументу `4`:
```haskell
main = putStrLn (show (simpleSum 4))
```
Стандартная функция `putStrLn` выводит строку на экран с завершающим `\n`. Результат выполнения этого кода вполне ожидаем:
```bash
8
```
Готово. А теперь необходимо уточнить некоторые важные детали.

## Выход из функции

В языке C, если у нас есть функция с возвращаемым значением, мы обязаны где-то в её теле указать точку выхода с помощью инструкции `return`. Кроме того, точек выхода может быть несколько.

В Haskell всё обстоит совершенно иначе. Во-первых, точка выхода из чистой функции может быть только одна, а во-вторых, аналога инструкции `return` в Haskell нет. И если мы вспомним математическую природу чистой функции, то поймём, что иначе и быть не может. Ведь чистая функция представляет собой описание зависимости выходного значения от входных значений, поэтому её тело представляет собой совокупность выражений, которые вычисляются и в конечном итоге оставляют одно-единственное, последнее выражение. Так вот это последнее выражение и будет являться "точкой выхода" из функции.

Приведу пример:
```haskell
indicate :: String -> String
indicate address =
    if address == "127.0.0.1" then "localhost" else address
```
Эта функция принимает единственный аргумент стандартного типа `String`, соответствующий некоторому IP-адресу. В теле функции происходит проверка аргумента на равенство адресу `127.0.0.1`, в результате чего мы окажемся в одной из двух логических ветвей. В C++ это выглядело бы так:
```cpp
std::string indicate( const std::string& address ) {
    if( address == "127.0.0.1" ) {
        return "localhost";
    }

    return address;
}
```
Мы явно указали две точки выхода из функции. Но в Haskell этого делать не нужно, потому что когда мы окажемся в одной из двух логических ветвей, то выражение, на котором мы окажемся, и будет возвращено.

Чтобы стало понятнее, перепишем тело этой функции так, чтобы избавиться от выражения `if-then-else`:
```haskell
indicate :: String -> String
indicate "127.0.0.1" = "localhost"
indicate address = address
```
Haskell позволяет вводить несколько определений для одной функции. Рассматривайте это как особый вариант перегрузки. Здесь мы говорим: "Если входной аргумент будет равен '127.0.0.1', пусть будет использовано тело №1, в противном случае пусть будет использовано тело №2". Следовательно, когда компилятор увидит вызов этой функции в коде, он просто подставит на место этого вызова соответствующее выражение: либо строку "localhost", в случае использования первого тела, либо фактически переданный аргумент, в случае использования второго тела.

Теперь всё встало на свои места: явно определять точку выхода из чистой функции не нужно потому, что конечное выражение в теле этой функции просто заменит собою вызов функции. То есть если написано так:
```haskell
main = putStrLn (indicate "127.0.0.1")
```
это то же самое, как если бы было написано просто:
```haskell
main = putStrLn "localhost"
```
Это - важное свойство чистых функций: мы всегда можем безопасно заменить места их вызова соответствующими возвращённым значениями, и работа приложения при этом останется неизменной. Именно поэтому работать с чистой функцией легко.

## Охрана

Существует ещё один способ задать выбор внутри функции без использования `if-then-else`. Называется он охрана (guard), хотя можно перевести и как "защита" или "стража". Перепишем нашу функцию:
```haskell
indicate :: String -> String
indicate address
    | address == "127.0.0.1" = "localhost"
    | null address = "empty IP-address"
    | otherwise = address
```
Символ `|` отражает выбор, как если бы мы написали вместо него слово "либо". После него идёт логическое условие и соответствующее ему итоговое значение функции:
```haskell
    ...
    | address == "127.0.0.1" = "localhost"
    | null address           = "empty IP-address"
    ...
      -- логическое условие  = итоговое значение
```
Кстати, ветку `otherwise` необходимо использовать всегда. Если вы её пропустите, код пройдёт компиляцию, однако в вашем коде поселится коварная ошибка. В частности, если вы напишете так:
```haskell
indicate :: String -> String
indicate address
    | address == "127.0.0.1" = "localhost"
    | null address = "empty IP-address"
```
а потом примените эту функцию к непустой строке, отличающейся от "127.0.0.1", вы получите ошибку времени выполнения:
```bash
Real: src/Main.hs:(23,1)-(25,36): Non-exhaustive patterns in function indicate
```
Будьте внимательны.

## Локальные выражения

Локальное выражение в теле функции - штука очень полезная, спасающая нас от магических чисел и от дубляжа.

Например, у нас есть такая функция:
```haskell
prepareLength :: Double -> Double
prepareLength line = line * 0.4959
```
Здесь мы готовим длину некой линии путём умножения её первоначальной длины на заданный поправочный коэффициент. Но перед нами - классическое магическое число, смысл которого непонятен, и это плохо. Добавлять комментарий - не самое лучшее решение. Поэтому добавим локальное поясняющее выражение:
```haskell
prepareLength :: Double -> Double
prepareLength line =
    line * coefficient
    where coefficient = 0.4959
```
Ключевое слово `where` вводит выражение, которое можно использовать в теле функции. Рассматривайте его как псевдоним: идентификатор `coefficient` теперь можно использовать как аналог числового значения `0.4959`.

Локальных выражений может быть и несколько:

```haskell
...
    line * coefficient - correction
    where coefficient = 0.4959
          correction = 0.0012
```

Есть ещё один способ ввести локальное вспомогательное выражение, а именно с помощью ключевого слова `let`. На примере нашей последней функции это будет выглядеть так:

```haskell
prepareLength :: Double -> Double
prepareLength line =
    let coefficient = 12.4959
        correction = 0.0012
    in
    line * coefficient - correction
```
Общая модель такая:

    let bindings in expression,

где `bindings` - локальные выражения, а `expression` - то место, где мы собираемся использовать эти локальные выражения.

Вы спросите, в чём же разница между `where` и `let`?

Во-первых, выражение `where` может быть только одно и только в конце тела функции, в то время как выражение `let` может присутствовать многократно и в любой части тела функции.

Во-вторых, выражение, введённое ключевым словом `where`, видимо в любой точке тела функции, в то время как выражение, введённое ключевым словом `let`, может быть "супер-локальным". Например:
 
```haskell
...
    let coefficient = 12.4959
        correction = 0.0012
    in
    line * coefficient - correction - (let s = 10.9 in s + 1) - s
```

Здесь мы ввели "супер-локальное" выражение с именем `s`, которое существует только внутри круглых скобок. Именно поэтому этот код не пройдёт компиляцию, ведь второе выражение `s` находится уже за пределами круглых скобок.

## Без объявления

Как вы помните, нельзя объявить функцию и при этом не определить её. А можно ли определить функцию без объявления? Ответ: можно. Однако важно помнить, что общепринятой практикой является объявлять функцию и тут же определять её. Да, мы можем написать так:

```haskell
-- Объявления нет, сразу определение
prepareLength line =
    ...
```

однако для сложных функций делать так крайне не рекомендуется, поскольку определение становится беднее, ведь описание типов аргументов и возвращаемого значения помогает лучше понять работу функции. Кроме того, если вы не укажете эти типы, они станут полиморфными, но об этом мы поговорим позже.

Впрочем, если речь идёт о действительно тривиальных функциях, состоящих из одной-двух строк, говорящих сами за себя, тогда указание типов аргументов и возвращаемого значения будет выглядеть избыточным. В этом случае опускайте их.

## В сухом остатке

* Чистые функции (далее ЧФ) - это функции в математическом смысле слова. Они не имеют побочных эффектов, всегда что-то принимают и всегда что-то возвращают.
* `f x` - это вызов функции `f` с аргументом `x`, или применение функции `f` к значению `x`.
* Мы всегда можем заменить вызов ЧФ возвращаемым ею значением, и у нас ничего не сломается.
* Порядок вычислений в теле ЧФ не важен, ибо от перестановки слагаемых сумма не меняется.
* Мы не можем явно указать точку выхода из ЧФ.
* В теле ЧФ можно ввести одно или более локальных выражений, с помощью `where` и `let`.
* Объявление тривиальных ЧФ рекомендуется опускать. 

