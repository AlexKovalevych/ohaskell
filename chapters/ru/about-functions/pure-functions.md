----
title: Чистые функции
prevChapter: /ru/about-functions/index.html
nextChapter: /ru/about-functions/lambda-functions.html
----

Ранее мною уже были упомянуты так называемые *чистые* функции. И раз уж Haskell является чисто функциональным языком, пришла пора поговорить об этих чистых функциях. Тем более что они являются одним из краеугольных камней этого языка.

Для начала вспомним школьный курс математики и сформулируем простейшее определение функции:

> **Функция - это описание зависимости чего-то от чего-то.**

То есть функциия представляет собою закон, определяющий то, *как* одному конкретному значению соответствует другое конкретное значение. Например, уже известная нам функция `f1`: 

```haskell
f1 x = x * x
```

В рамках данной функции каждому целочисленному значению однозначно соответствует его квадрат. Так вот чистые функции в Haskell - это и есть функции в математическом смысле. Они представляют собой описание того, *как* конкретное входное значение определяет конкретное выходное значение.

Отсюда вытекает важнейшая характеристика чистых функций, а именно отсутствие побочных эффектов. Значение на входе чистой функции всецело и полностью определяет значение на выходе. Поэтому если мы миллион раз подадим на вход функции `f1` одно и то же значение, то на выходе мы миллион раз получим один и тот же результат. Гарантированно.

Кстати, по поводу побочных эффектов. Чистая функция не способна взаимодействовать с внешним миром. Не существует никакого способа заставить чистую функцию записать строчку в файл, прочитать запись из БД, отправить HTTP-запрос или получить текст, вводимый пользователем с клавиатуры. А раз так, чистая функция является в высшей степени предсказуемой конструкцией: она никогда не преподнесёт нам сюрприз, потому что единственное что она делает, это определяет зависимость своего выходного значения от своих аргументов. 

## Объявляем

Сначала функцию рекомендуется объявить. Сделаем же это:
```haskell
simpleSum :: Int -> Int
```
До символа `::` указывается имя функции, а после - её тип.

```
simpleSum :: Int -> Int
|       |    |        |
   имя          тип 
```

Я понимаю, словосочетание "тип функции" звучит странно, но в мире Haskell так: чистая функция - это значение, имеющее тип функции. Рассмотрим описание этого типа:
```haskell
Int -> Int
```
Обратите внимание на стрелочку. В объявлении всех чистых функций всегда присутствует эта стрелочка. Слева от неё указан тип единственного аргумента (в данном случае это стандартный тип `Int`), а справа от неё - тип выходного значения (тот же `Int`). Саму же стрелочку можно воспринимать как ментальное указание на поток информации, движущийся через функцию: от её входа к выходу, слева направо.

Я повторю эту важную мысль ещё раз: чистая функция - это значение. В императивном программировании данные и функции - это совершенно разные вещи. Но в чисто функциональном языке данные и функции - это одно и то же. И на протяжении последущих глав мы много раз будем возвращаться к этой простой и важной мысли. Да, если вы имеете опыт разработки на императивном языке, эта мысль не кажется вам такой уж простой (а вероятно, она вообще кажется вам абсурдной), но вскоре всё встанет на свои места.

Кстати, вы заметили, что выше было упомянуто о том, что функцию рекомендуется объявить? Строго говоря, в Haskell делать это необязательно. Однако объявление показывает нам типы аргументов и тип возвращаемого значения, а это делает код значительно более читабельным.

Напоминаю, что чистая функция обязана иметь хотя бы один аргумент и обязана что-то возвращать, ведь это и отражает суть математической функции: что-то обязательно подаём на вход и что-то обязательно получаем на выходе.

Разумеется, чистая функция может принимать и несколько аргументов. Вот тип функции, принимающей три аргумента:
```haskell
Int -> Int -> Int -> Int
```
Читать эту запись следует так: ищем последнюю по счёту (самую правую) стрелочку - она-то и будет тем самым разделителем: слева от неё идёт список типов аргументов, справа - тип возвращаемого выражения:

```
Int -> Int -> Int -> Int
типы аргументов  |  |тип возвращаемого значения
```

## Определяем

Теперь функцию необходимо определить. Да, определить нужно *обязательно*. Например, в языке C или C++ мы можем спокойно объявить функцию и не определять её (при условии, что она никогда не вызывается). В Haskell более строгий подход: если объявил функцию - будь добр и определить её, в противном случае компилятор выскажет своё категорическое недовольство.

Поэтому сразу же после объявления пишем определение:
```haskell
simpleSum :: Int -> Int
simpleSum value = value + value
```
Здесь ментальным разделителем является знак равенства. Скелет данного выражения можно представить так:

```
NAME ARGUMENTS = BODY_EXPRESSION 
```

где `NAME` - имя функции, `ARGUMENTS` - список имён аргументов (имён, а не типов), а `BODY_EXPRESSION` - тело функции. В данном случае у нас имеется один-единственный аргумент по имени `value`, а также имеется простое тело, в котором мы просто складываем аргумент с самим собой.

## Вызываем

Теперь нашу функцию можно вызывать. Сделаем же это с аргументом `4`, или, как принято говорить в мире функционального программирования, применим функцию к аргументу `4`:
```haskell
main = putStrLn (show (simpleSum 4))
```
Стандартная функция `putStrLn` выводит строку на экран с завершающим `\n`. Результат выполнения этого кода вполне ожидаем:
```bash
8
```
Готово. А теперь необходимо уточнить некоторые важные детали.

## Выход из функции

В языке C, если у нас есть функция с возвращаемым значением, мы обязаны где-то в её теле указать точку выхода с помощью инструкции `return`. Кроме того, точек выхода может быть несколько.

В Haskell всё обстоит совершенно иначе. Во-первых, точка выхода из чистой функции может быть только одна, а во-вторых, аналога инструкции `return` в Haskell нет. Да, существует специальная фукнция `return`, но, как будет упомянуто в следующих главах, она несёт совершено иной смысл.

Почему же в Haskell нет C-подобной инструкции `return`? Если мы вспомним математическую природу чистой функции, то поймём, что иначе и быть не может. Ведь чистая функция представляет собой описание зависимости выходного значения от входных значений, поэтому её тело представляет собой совокупность выражений, которые вычисляются и в конечном итоге оставляют одно-единственное, последнее выражение. Так вот это последнее выражение и будет являться "точкой выхода" из функции.

Приведу пример:
```haskell
indicate :: String -> String
indicate address =
    if address == "127.0.0.1" then "localhost" else address
```
Эта функция принимает единственный аргумент стандартного типа `String`, соответствующий некоторому IP-адресу. В теле функции происходит проверка аргумента на равенство адресу `127.0.0.1`, в результате чего мы окажемся в одной из двух логических ветвей. В C++ это выглядело бы так:
```cpp
std::string indicate( const std::string& address ) {
    if( address == "127.0.0.1" ) {
        return "localhost";
    }

    return address;
}
```
Мы явно указали две точки выхода из функции. Но в Haskell этого делать не нужно, потому что когда мы окажемся в одной из двух логических ветвей, то выражение, на котором мы окажемся, и будет возвращено.

Чтобы стало понятнее, перепишем тело этой функции так, чтобы избавиться от выражения `if-then-else`:
```haskell
indicate :: String -> String
indicate "127.0.0.1" = "localhost"
indicate address = address
```
Haskell позволяет вводить несколько определений для одной функции. Рассматривайте это как особый вариант перегрузки. Здесь мы говорим: "Если входной аргумент будет равен '127.0.0.1', пусть будет использовано тело №1, в противном случае пусть будет использовано тело №2". Следовательно, когда компилятор увидит вызов этой функции в коде, он просто подставит на место этого вызова соответствующее выражение: либо строку "localhost", в случае использования первого тела, либо фактически переданный аргумент, в случае использования второго тела.

Кстати, порядок указания тел функции важен. Если бы мы написали так:
```haskell
indicate :: String -> String
indicate address = address
indicate "127.0.0.1" = "localhost"
```
то функция всегда возвращала бы свой фактический адрес. Ведь любое строковое значение удовлетворяло бы телу №1, и до второго тела мы никогда бы не дошли. Таким образом, если у чистой функции несколько тел, указывать их следует от частного к общему, но не наоборот.

Теперь всё встало на свои места: явно определять точку выхода из чистой функции не нужно потому, что конечное выражение в теле этой функции просто заменит собою её вызов. То есть если написано так:
```haskell
main = putStrLn (indicate "127.0.0.1")
```
это то же самое, как если бы было написано просто:
```haskell
main = putStrLn "localhost"
```
Это чрезвычайно важное свойство чистых функций: мы всегда можем безопасно заменить места их вызова соответствующими возвращёнными значениями, и работа приложения при этом гарантированно останется неизменной. А всё потому, что чистая функция - это и есть возвращённое ею значение. Именно поэтому работать с чистой функцией очень легко.

## Охрана

Существует ещё один способ задать выбор внутри функции без использования конструкции `if-then-else`. Называется он охрана (guard), хотя можно перевести и как "защита" или "стража". Перепишем нашу функцию:
```haskell
indicate :: String -> String
indicate address
    | address == "127.0.0.1" = "localhost"
    | null address = "empty IP-address"
    | otherwise = address
```
Символ `|` отражает выбор, как если бы мы написали вместо него слово "либо". После него идёт логическое условие и соответствующее ему итоговое значение функции:
```haskell
    ...
    | address == "127.0.0.1" = "localhost"
    | null address           = "empty IP-address"
    ...
      -- логическое условие  = итоговое значение
```
Кстати, ветку `otherwise` необходимо использовать всегда. Если вы её пропустите, код пройдёт компиляцию, однако в вашем коде поселится коварная ошибка. В частности, если вы напишете так:
```haskell
indicate :: String -> String
indicate address
    | address == "127.0.0.1" = "localhost"
    | null address = "empty IP-address"
```
а потом примените эту функцию к непустой строке, отличающейся от "127.0.0.1", вы получите ошибку времени выполнения:
```bash
Real: src/Main.hs:(23,1)-(25,36): Non-exhaustive patterns in function indicate
```
Будьте внимательны.

## Отступы

Обратите внимание, что в функции `indicate` перед символами `|` находится отступ. Этот отступ очень важен! В Haskell-коде форматирование имеет большое значение, и если оно, это форматирование, неправильное, компиляция не пройдёт. Подробнее о практических примерах форматирования рассказано в главе [О форматировании](/ru/miscellaneous/about-formatting.html).

## Локальные выражения

Локальное выражение в теле функции - штука очень полезная, спасающая нас от магических чисел и от дубляжа кода.

Например, у нас есть такая функция:
```haskell
prepareLength :: Double -> Double
prepareLength line = line * 0.4959
```
Здесь мы готовим длину некой линии путём умножения её первоначальной длины на заданный поправочный коэффициент. Но перед нами - классическое магическое число, смысл которого непонятен, и это плохо. Добавлять комментарий - не самое лучшее решение. Поэтому добавим локальное поясняющее выражение:
```haskell
prepareLength :: Double -> Double
prepareLength line =
    line * coefficient
    where coefficient = 0.4959
```
Ключевое слово `where` вводит локальный псевдоним для выражения. Теперь идентификатор `coefficient` теперь можно использовать как аналог числового значения `0.4959`.

Локальных выражений может быть и несколько:

```haskell
prepareLength :: Double -> Double
prepareLength line =
    line * coefficient - correction
    where coefficient = 0.4959
          correction = 0.0012
```

Есть ещё один способ ввести локальное вспомогательное выражение, а именно с помощью ключевого слова `let`. На примере нашей последней функции это будет выглядеть так:

```haskell
prepareLength :: Double -> Double
prepareLength line =
    let coefficient = 12.4959
        correction = 0.0012
    in
    line * coefficient - correction
```
Общая модель такая:
```
let bindings in expression,
```
где `bindings` - локальные выражения, а `expression` - то место, где мы собираемся использовать эти локальные выражения. Кстати, слово `in` не всегда обязательно, но об этом мы узнаем в следующих главах.

Вы спросите, в чём же разница между `where` и `let`?

Во-первых, выражение `where` может быть только одно и только в конце тела функции, в то время как выражение `let` может присутствовать многократно и в любой части тела функции.

Во-вторых, выражение, введённое ключевым словом `where`, видимо в любой точке тела функции, в то время как выражение, введённое ключевым словом `let`, может быть "супер-локальным". Например:
 
```haskell
prepareLength :: Double -> Double
prepareLength line =
    let coefficient = 12.4959
        correction = 0.0012
    in
    line * coefficient - correction - (let s = 10.9 in s + 1) - s
```

Здесь мы ввели "супер-локальное" выражение с именем `s`, которое существует только внутри круглых скобок. Именно поэтому этот код не пройдёт компиляцию, ведь второе выражение `s` находится уже за пределами круглых скобок.

Вы спросите, можем ли мы использовать и `let`, и `where` одновременно? Можем, но с одним ограничением. Пишем:

```haskell
prepareLength :: Double -> Double
prepareLength line =
    let coefficient = 12.4959
    in 
    line * coefficient - correction
    where correction = 0.0012
```

Всё прекрасно работает. Мы можем написать и так:

```haskell
prepareLength :: Double -> Double
prepareLength line =
    let coefficient = 12.4959 - specValue
    in line * coefficient - correction
    where correction = 0.0012
          specValue  = 0.03
```

Тоже работает. Как видите, мы ввели третий `where`-псевдоним `specValue` и смогли использовать его в `let`-выражении. А если попробовать наоборот? Вот так:

```haskell
prepareLength :: Double -> Double
prepareLength line =
    let coefficient = 12.4959
        specValue = 0.03
    in line * coefficient - correction
    where correction = 0.0012 - specValue
```

Теперь псевдоним `specValue` задан в `let`-выражении, и мы хотим использовать его в `where`-выражении. Увы, но такой код не скомпилируется, и мы увидим следующую ошибку:

```bash
Not in scope: ‘specValue’
```

Это и есть то самое единственное ограничение: мы не можем использовать `let`-псевдонимы внутри `where`-выражения.

## В сухом остатке

1. Чистые функции (далее ЧФ) - это функции в математическом смысле слова: они всегда что-то принимают и всегда что-то возвращают. Кроме того, ЧФ не могут иметь побочных эффектов и не могут взаимодействовать с внешним миром.
2. `f x` - это вызов функции `f` с аргументом `x`, или применение функции `f` к значению `x`.
3. Мы всегда можем безопасно заменить вызов ЧФ возвращаемым ею значением, и у нас ничего не сломается.
4. Мы не можем явно указать точку выхода из ЧФ, потому что применительно к ЧФ это не имеет смысла.
5. В теле ЧФ можно ввести одно или более локальных выражений, с помощью ключевых слов `where` и `let`.

