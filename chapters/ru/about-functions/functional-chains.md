----
title: Функциональные цепочки
prevChapter: /ru/about-functions/higher-order-functions.html
nextChapter: /ru/about-functions/functions-and-operators.html
----

В отношении функций часто можно сказать: "Один в поле не воин". В этой главе мы рассмотрим два удобных способа организации взаимодействия функций.

## Пример с URL

Известно, что вид URL обязан соответствовать особым правилам. Но в реальной жизни это не всегда так, поэтому иногда URL необходимо преобразовать к правильному виду. Вот как это может выглядеть:

```haskell
import Data.Char
import Data.String.Utils

addPrefix :: String -> String
addPrefix url =
    if url `startsWith` prefix then url else prefix ++ url
    where prefix = "http://"
          startsWith url prefix = startswith prefix url

encodeAllSpaces = replace " " "%20"  -- Заменяем все пробелы на %20.

makeItLowerCase = map toLower  -- Переводим символы строки в нижний регистр.      

main =
    putStrLn (addPrefix (encodeAllSpaces (makeItLowerCase url)))
    where url = "www.SITE.com/test me/Start page"
```

Вывод будет таким:

```bash
http://www.site.com/test%20me/start%20page
```

Обратите внимание: мы импортировали новый модуль `Data.String.Utils`. Этот модуль является частью пакета `MissingH`, содержащего кучу разных полезных утилит. Установим этот пакет:

```bash
$ cabal install MissingH
```

Упомянем его в файле `Real.cabal`:

```haskell
    build-depends: base ==4.6.\*, MissingH
```

В модуле `Data.String.Utils` присутствуют различные вкусности для работы со строками, но нам понадобилась лишь одна функция `startswith`, проверяющая, является ли одна строка началом другой строки. Кстати, вы заметили? Мы обернули эту функцию в нашу собственную:

```haskell
startsWith url prefix = startswith prefix url
```

Ничего особенного, просто переставили аргументы местами. Сделано это для того, чтобы вызов функция правильно смотрелась в инфиксной форме:

```haskell
if url `startsWith` prefix
```

Идём дальше. Вы, вероятно, обратили внимание на две необычные строки:

```haskell
encodeAllSpaces = replace " " "%20"

makeItLowerCase = map toLower
```

Что это? Вроде бы похоже на функции, определённые без объявления, но где же тут аргументы? А они здесь не нужны. Чтобы стало понятнее, напишем одну из них с аргументом:

```haskell
makeItLowerCase url = map toLower url
```

Это - полная форма. Но мы можем сократить её, убрав аргумент. Почему? Потому что такой инструкцией:

```haskell
makeItLowerCase = map toLower
```

мы объявляем: "Всё, теперь `makeItLowerCase` - это псевдоним для функциональной записи `map toLower`. Поэтому везде, где мы напишем `makeItLowerCase arg`, мы будем подразумевать запись `map toLower arg`".

Итак, у нас имеются три функции, каждая из которых делает с нашим URL простую исправительную операцию: `makeItLowerCase` переводит все символы в нижний регистр, `encodeAllSpaces` заменяет пробелы строкой `"%20"`, `addPrefix` добавляет префикс, если таковой отсутствует. То есть у нас есть цепочка из трёх функций: на входе этой цепочки неправильный URL, а на выходе - исправленный URL. Рассмотрим эту цепочку поближе:

```haskell
addPrefix (encodeAllSpaces (makeItLowerCase url))
```

Каждая из функций принимает на вход URL и возвращает уже обработанный ею URL, поступающий на вход следующей функции.

И всё бы хорошо, но есть в такой цепочке один минус - многовато круглых скобок (да простят меня программисты Lisp). Проблема усугубилась бы, если бы функций-исправителей было не три, а больше. Существует два способа сделать такую цепочку красивее.

## Функция композиции

Функция композиции (function composition) выглядит как точка. Впрочем, с математической точки зрения правильнее говорить "композиция функций". Её назначение - компоновать функции в цепочку. Вот так:

```haskell
(addPrefix . encodeAllSpaces . makeItLowerCase) url
```

Функция композиции берёт наши три функции и объединяет их в одну конструкцию, которая один раз применяется к нашему `url`, и результат будет точно таким же, как если бы мы написали так:

```haskell
addPrefix (encodeAllSpaces (makeItLowerCase url))
```

Можно сказать, что функция композиции создала стек из трёх функций: перечислены они слева направо, а вызываться будут справа налево. Таким образом, строка `url` едет по конвейеру, заезжая в него с правого края и выезжая с левого.

## Функция применения

А ещё есть функция применения (function application), иногда говорят "функция аппликации" или "применение функции". Выглядит она как значок доллара. Её назначение - компоновать функции в цепочку. Вот так:

```haskell
addPrefix $ encodeAllSpaces $ makeItLowerCase url
```

Здесь мы обошлись вообще без скобок. И такое написание также аналогично исходному:

```haskell
addPrefix (encodeAllSpaces (makeItLowerCase url))
```

Здесь тоже получился стек из функций: перечислены слева направо, а вызываются справа налево. Такой вызов справа налево называют ещё правоассоциативным (right-associative).

## Вместе

Вероятно, вам интересно, а в чём же разница между этими двумя способами? Ведь и первый и второй предназначены для организации стековой цепочки функций.

Главная разница состоит в том, что функция применения позволяет объединять не только функции, но также функцию с её аргументом:

```haskell
main = print $ "Hi master!"
```

Функция композиции не позволила бы проделать такой фокус.

Вы спросите, зачем всё это нужно? Рассмотрим вот такой вызов:

```haskell
main = print ("Hi master '" ++ name ++ "', have a nice day!")
```

Функция `print` готова работать исключительно с одним аргументом, поэтому три литерала, объединяющиеся в один, необходимо взять в скобки. Значительно удобнее написать так:

```haskell
main = print $ "Hi master '" ++ name ++ "', have a nice day!"
```

Мы избавились от скобок, объединив функцию и её аргумент в маленькую цепочку. Именно благодаря такому свойству функции композиции и применения часто используют вместе:

```haskell
addPrefix . encodeAllSpaces . makeItLowerCase $ url
```

Точка объединяет функции, а доллар привязывает их к аргументу. Кстати, в реальных Haskell-проектах чаще всего используется именно такая "бесскобочная" форма вызова.

## В сухом остатке

* Функция композиции компонует функции в цепочку.
* Функция применения также компонует функции в цепочку, а также позволяет компоновать функцию с её аргументом.
* Совместное использование функций применения и композиции упрощает код, избавляя нас от лишних круглых скобок.


