----
title: Функции высшего порядка
prevChapter: /ru/about-functions/lambda-functions.html
nextChapter: /ru/about-functions/functional-chains.html
----

Функции высшего порядка (higher-order functions) занимают очень важное место в языке Haskell. Из предыдущих глав вы узнали, что чистые функции - это, в конечном итоге, значения. А раз это значения, значит их можно, во-первых, передавать другим функциям в качестве аргументов, а во-вторых, возвращать их из других функций. Так вот функцию, принимающую другую функцию в качестве аргумента и/или возвращающую другую функцию, называют *функцией высшего порядка*.

## Разоблачение функций

Помните, в рассказе о чистых функциях было упомянуто, что они могут принимать как один, так и множество аргументов? Пришло время признаться в обмане, ибо правда такова:

> **Чистые функции в Haskell всегда принимают только один аргумент.** 

Постойте, но как же мы тогда смогли определить функции, принимающие по два и даже по три аргумента?

Это была хитрость, и называется она "каррирование" (currying), иногда говорят "карринг". Слово это знаменитое, ибо происходит от имени [Haskell Curry](https://en.wikipedia.org/wiki/Haskell_Curry). Каррирование - это превращение функции, принимающей множество аргументов, в функцию, принимающую эти аргументы по одному.

Определим функцию деления двух чисел:

```haskell
divide :: Double -> Double -> Double
divide arg1 arg2 = arg1 / arg2
```

Функция принимает два значения стандартного типа `Double` и возвращает результат деления первого значения на второе. Всё предельно просто. Но если мы заглянем "под капот" вызова этой функции:

```haskell
main = print (divide 10.03 2.1)
```

то узнаем, что этот вызов происходит в два этапа:

1.  Функция `divide` применяется к первому аргументу `10.03` и - внимание! - возвращает функцию типа `Double -> Double`.
2.  Эта возвращённая функция, в свою очередь, применяется ко второму аргументу `2.1` и возвращает конечное значение `4.77`.

Мы можем явно отразить эту "двухэтапность", переписав вызов функции так:

```haskell
(divide 10.03) 2.1
```

Функция применяется только к одному значению: сначала к `10.03`, а уже потом функция, возвращённая первым вызовом, применяется к `2.1`. Именно по причине такой "двухэтапности" объявление функции `divide` содержит две стрелочки вместо одной:

```haskell
divide :: Double -> Double -> Double
```

С концептуальной точки зрения такое объявление звучит так: "Функция `divide` принимает два значения типа `Double` и возвращает значение типа `Double`". Однако правильнее читать его так: "Функция `divide` применяется к первому значению типа `Double` и возвращает функцию типа `Double -> Double`, которая применяется ко второму значению типа `Double` и возвращает конечное значение типа `Double`". Кстати, правильное прочтение объявления можно отразить и в самом этом объявлении:

```haskell
divide :: Double -> (Double -> Double)
```

Теперь мы ясно видим, что на первом этапе происходит вызов функции от одного аргумента, возвращающей функцию типа `Double -> Double`, а на втором этапе происходит вызов второй функции, возвращённой на первом этапе.

По аналогии, если у нас есть функция, принимающая три аргумента:

```haskell
totalSum :: Double -> Double -> Double -> Double
totalSum arg1 arg2 arg3 = arg1 + arg2 + arg3
```

то её вызов:

```haskell
main = print (totalSum 10.03 2.1 45.7)
```

проходил бы в три этапа, и чтобы явно отразить этот факт, мы можем переписать объявление данной функции так:

```haskell
totalSum :: Double -> (Double -> (Double -> Double))
```

а её вызов - так:
 
```haskell
((totalSum 10.03) 2.1) 45.7
```
 
И чтобы всё окончательно прояснилось, изучим один важный механизм.

## Частичное применение функции

Несмотря на "двухэтапность" вызова функции `divide`, её тело будет выполнено один раз. Вызов один, просто он разделён на два последовательных шага. А чтобы понять суть этих шагов, изучим частичное применение функции (partial application).

Функцию называют частично применённой, если количество аргументов, к которым она применена, оказалось меньше ожидаемого ею количества аргументов. И здесь нам пригодятся уже известные нам λ-функции.

Применим функцию `divide` не к двум, а только к одному аргументу:

```haskell
main =
    let temporaryFunction = divide 10.03  -- "Запомнили" первое значение...
    in
    print (temporaryFunction 2.1)   -- А вот теперь можем выполнить деление.
```

Теперь всё встало на свои места. Здесь наглядно показано, что же на самом деле означает выражение вида:

```haskell
(divide 10.03) 2.1
```

В результате первого вызова, когда мы применили функцию `divide` к первому аргументу, мы ещё не можем получить результат деления, ведь второго-то аргумента у нас пока нет. Вместо этого мы получили временную λ-функцию, которую для наглядности ассоциировали с выражением `temporaryFunction`. Эта временная λ-функция как бы запомнила значение первого аргумента, и только когда мы применим её ко второму аргументу, получим результат деления.

По аналогии, вызов нашей функции `totalSum`, происходящий в три этапа, можно разложить так:

```haskell
main =
    let firstFunction  = totalSum 1.0       -- "Запомнили" первое значение...
        secondFunction = firstFunction 2.0  -- "Запомнили" второе значение...
    in
    print (secondFunction 3.0)              -- А вот теперь можем складывать.
```

В процессе вызова у нас появилось уже две временные λ-функции, каждая из которых применялась к очередному аргументу и запоминала его. И только когда вторая промежуточная λ-функция была применена к третьему, последнему аргументу, мы и получили сумму.

Так вот упомянутое выше каррирование работает благодаря механизму частичного применения функции. В самом деле, как бы мы смогли разложить функцию от двух аргументов на два одноаргументных шага? Только через частичное применение.

## Зачем это нужно

В подавляющем большинстве случаев знать вышеизложенную информацию о каррировании функций и о частичном применении не обязательно. Основное преимущество каррирования лежит в академической плоскости: выводить математические доказательства гораздо легче, если договориться, что каждая из вычисляемых функций всегда принимает строго один аргумент и возвращает строго одно значение. Но нас-то с вами больше интересует аспект практический. И поэтому мы возвращаемся к рассмотрению функций высшего порядка (далее - ФВП).

Формально функции `divide` и `totalSum` являются ФВП, в силу тех самых промежуточных λ-функций. Более того, все функции в Haskell, принимающие более одного аргумента, являются ФВП. Но все эти промежуточные λ-функции - всего лишь "подкапотные" дела, они скрыты от наших глаз. Гораздо больший интерес для нас представляют "настоящие" ФВП, которые явно объявлены как принимающие на вход функциональные значения и/или возвращающие функциональные значения.

Рассмотрим небольшой пример:

```haskell
type Login     = String
type Password  = String
type AvatarURL = String
type UserId    = Integer

userInfo :: Login -> Password -> AvatarURL -> UserId -> String
userInfo login password avatarURL userId =
    "Full info about user @" ++ (show userId) ++ ":" ++
    "\n login: " ++ login ++
    "\n password: " ++ password ++
    "\n avatar URL: " ++ avatarURL

type EmptyInfo        = Login -> Password -> AvatarURL -> UserId -> String
type WithLogin        =          Password -> AvatarURL -> UserId -> String
type AndWithPassword  =                      AvatarURL -> UserId -> String
type AndWithAvatarURL =                                   UserId -> String

storeLoginIn :: EmptyInfo -> UserId -> WithLogin
storeLoginIn emptyInfo userId =
    emptyInfo "denis"

storePasswordIn :: WithLogin -> UserId -> AndWithPassword
storePasswordIn infoWithLogin userId = 
    infoWithLogin "123456789abc"

storeAvatarURLIn :: AndWithPassword -> UserId -> AndWithAvatarURL
storeAvatarURLIn infoWithPassword userId =
    infoWithPassword "http://dshevchenko.biz/denis_avatar.png"

main =
    let userId = 1234
        infoWithLogin = storeLoginIn userInfo userId
        infoWithPassword = storePasswordIn infoWithLogin userId
        infoWithAvatarURL = storeAvatarURLIn infoWithPassword userId
        fullInfoAboutUser = infoWithAvatarURL userId
    in
    putStrLn fullInfoAboutUser
```

А теперь разберём это хозяйство по косточкам.

Во-первых, появилась новая для нас конструкция:

```haskell
type Login = String
```

Ключевое слово `type` добавляет псевдоним для уже известного типа, и теперь вместо типа `String` можно использовать идентификатор `Login`.

Далее мы определили функцию:

```haskell
userInfo :: Login -> Password -> AvatarURL -> UserId -> String
```

Тут всё просто: функция `userInfo` ожидает на вход логин, пароль, адрес аватара и идентификатор пользователя, а на выходе выдаёт некую описывающую строку. Обратите внимание и на двойной плюс:

```haskell
"\n login: " ++ login
```

Это оператор конкатенации двух списков в один. А поскольку строка есть список символов, к ней этот оператор вполне применим.

А вот теперь начинается самое интересное. Подразумевается, что изначально у нас имеется только идентификатор пользователя, а соответствующие ему логин, пароль и путь к аватару нам нужно откуда-то получить. К счастью, у нас есть три функции, каждая из которых знает, где взять логин, пароль и путь к аватару соответственно. И каждая из этих трёх функций является ФВП.

Рассмотрим псевдонимы:

```haskell
type EmptyInfo        = Login -> Password -> AvatarURL -> UserId -> String
type WithLogin        =          Password -> AvatarURL -> UserId -> String
type AndWithPassword  =                      AvatarURL -> UserId -> String
type AndWithAvatarURL =                                   UserId -> String
```

Каждый из них вводит упрощающее имя для функционального типа, образованного "урезанием" от типа функции `userInfo`. Обратите внимание: каждый последующий тип ожидает на один аргумент меньше, чем предыдущий тип. Эти псевдонимы задают типы для очередной промежуточной λ-функции, которые нужны, как вы уже догадались, для частичного применения функции `userInfo`.

Рассмотрим первый вызов:

```haskell
infoWithLogin = storeLoginIn userInfo userId
```

Здесь мы передаём функцию `userInfo` в качестве первого аргумента функции `storeLoginIn`, внутри которой мы применяем переданную функцию `userInfo` к единственному аргументу, а именно к логину. Соответственно, на выходе из функции `storeLoginIn` мы получаем первую промежуточную λ-функцию, в которой мы сохранили значение логина (именно поэтому тип этой λ-функции ассоциирован со словом `WithLogin`).

Далее следует вызов:

```haskell
infoWithPassword = storePasswordIn infoWithLogin userId
```

Здесь мы передаём нашу промежуточную λ-функцию в качестве первого аргумента функции `storePasswordIn`. Эта функция, в свою очередь, применяет переданную ей λ-функцию к единственному аргументу, а именно к паролю. Таким образом, на выходе из функции `storePasswordIn` мы имеем вторую промежуточную λ-функцию, в которой сохранены уже два значения: полученный на предыдущем вызове логин и на этом вызове - пароль.

То же самое справедливо и для следующего вызова:

```haskell
infoWithAvatarURL = storeAvatarURLIn infoWithPassword userId
```

На выходе из функции `storeAvatarURLIn` мы получаем третью λ-функцию, в которой сохранены уже три значения: логин, пароль и путь к аватару.

В итоге мы применяем эту третью λ-функцию к последнему нужному аргументу, а именно к идентификатору пользователя:

```haskell
fullInfoAboutUser = infoWithAvatarURL userId
```

Здесь-то и происходит "полноценный" вызов функции `userInfo`, в результате которого мы и получаем описывающую строку:

```bash
Full info about user @1234:
 login: denis
 password: 123456789abc
 avatar URL: http://dshevchenko.biz/denis_avatar.png
```

Таким образом, функция `userInfo` была частично применена трижды, каждый раз получая очередной аргумент, и лишь к четвёртому применению она получила все необходимые ей аргументы. Это можно сравнить с конвейерной цепочкой, на каждом шаге которой эта функция получала очередной аргумент.

Впрочем, нужны ли были такие сложности? Ведь мы можем передавать в каждую из этих трёх функций только значение `userId`, а возвращать никакую не промежуточную λ-функцию, а непосредственно логин, пароль и адрес аватара соответственно. Например, вместо функции `storeLoginIn` можно определить функцию `obtainLogin` следующего вида:

```haskell
obtainLogin :: UserId -> Login
obtainLogin userId =
    -- Получаем откуда-то логин и просто возвращаем его.
```

Ну а что если мы не хотим возвращать логин в явном виде? Ведь в случае с частичным применением мы упаковываем логин в промежуточную λ-функцию (то есть фактически прячем логин в неё), а в этом случае мы явно возвращаем его на показ всему миру. Первое решение может оказаться более приемлемым.

Или другой пример:
 
```haskell
type UserId = Integer
type Prefix = String

obtainLogin :: UserId -> (Prefix -> String)
obtainLogin userId =
    loginStorage "denis"  -- Подразумевается, что логин как-то получен.
    where loginStorage login prefix = prefix ++ ": " ++ login

main =
    let userId = 1234
    in
    putStrLn ((obtainLogin userId) "My login")
```
 
Рассмотрим функцию `obtainLogin` подробнее:

```haskell
obtainLogin :: UserId -> (Prefix -> String)
obtainLogin userId =
    loginStorage "denis"
    where loginStorage login prefix = prefix ++ ": " ++ login
```

Здесь мы, на основании полученного извне идентификатора пользователя, откуда-то извлекаем логин и сразу же прячем его в λ-функцию, тут же нами и созданную. В результате функция `obtainLogin` возвращает частично применённую функцию, которую мы вторично применяем к строке-префиксу - и в результате на выходе мы получаем готовый результат:

```bash
My login: denis
```

Вас, вероятно, интересует, почему я сказал о λ-функции? Вроде бы здесь нет нашего знакомого `\`:

```haskell
where loginStorage login prefix = prefix ++ ": " ++ login
```

Однако это не важно, ведь такая запись идентична λ-форме:

```haskell
where loginStorage = \login prefix -> prefix ++ ": " ++ login
```

Помните, выше я говорил, что тривиальную функцию лучше определять без объявления? Вот это тот самый случай.

## В сухом остатке

1. ФВП - это функция, принимающая другую функцию в качестве аргумента и/или возвращающая другую функцию.
2. ФВП неразрывно связаны с механизмом каррирования, когда функция от нескольких аргументов превращается в набор функций от одного аргумента каждая. Поэтому любая функция, принимающая более одного аргумента, является ФВП.
3. Каррирование базируется на частичном применении функции, когда функция принимает не все ожидаемые ею аргументы.


