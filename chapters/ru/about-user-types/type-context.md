----
title: Контекст типа
prevChapter: /ru/about-user-types/about-value-constructors.html
nextChapter: /ru/about-user-types/composite-types.html
----

Как вы уже знаете, тип аргумента функции может быть полиморфным, что позволит нам применить такую функцию к значению любого типа. Но на практике нам редко нужна столь радикальная гибкость. В большинстве случаев, говоря об аргументе любого типа, мы подразумеваем вовсе не *любой* тип, а тип из *некоторой группы*. Об этом и поговорим.

## Любой, да не совсем

Возьмём стандартную функцию `elem`. Как вы помните, это простой предикат, возвращающий `True` в том случае, если заданное значение является элементом списка. Например:

```haskell
main =
    putStrLn $ if "yellow" `elem` colors then "Yellow!" else "There's no yellow."
    where colors = ["red", "black", "yellow", "green"]
```

Предельно простая функция. Взглянем на её объявление:

```haskell
elem :: Eq a => a -> [a] -> Bool
```

Тут вроде бы всё понятно: принимаем значение некоторого типа `a`, а также список из значений этого же типа, и возвращаем логический признак. И всё-таки кое-что новенькое тут присутствует, а именно символ `=>`. Этот символ говорит нам о наличии контекста типа:

```haskell
Eq a => a
```

Слева от символа `=>` находится ограничение, наложенное на полиморфный тип `a`. Мы говорим: "Да, мы готовы принять аргумент любого типа, но при условии, что этот тип относится к классу типов `Eq`."

Стандартный класс типов `Eq` (от английского equal, "равный") предоставляет два метода:

```haskell
(==) :: a -> a -> Bool
(/=) :: a -> a -> Bool
```

Именно поэтому функция `elem` может быть применена лишь к значению такого типа, который предоставляет свои реализации методов "равно" `==` и "не равно" `/=`. Оно и понятно: далеко не для всех типов операция проверки на равенство имеет смысл.

Проверим это на нашем типе `IPAddress`:

```haskell
nothing :: a -> a
nothing value = value

main = print $ nothing $ IP "127.0.0.1"
```

У нас есть функция `nothing`, ничего не делающая и лишь возвращающая свой аргумент. Поскольку она объявлена с полиморфным типом без каких-либо ограничений, мы можем применить эту функцию к значению типа `IPAddress`. Но как только мы добавим в объявление этой функции ограничение:

```haskell
nothing :: Eq a => a -> a
nothing value = value
```

функция `nothing` уже не согласится работать с нашим типом, и правильно сделает: наш тип не имеет никакого отношения к классу `Eq`. В этом случае говорят, что тип `IPAddress` не подходит под ограничение класса `Eq`, или не входит в контекст класса `Eq`. И если бы мы очень захотели работать с функцией `nothing`, нам пришлось бы предоставить свой экземпляр класса `Eq`, реализующий методы `==` и `/=`.

Механизм ограничения класса типа - полезный механизм, делающий наш код самодокументируемым, ведь видя ограничение типа в объявлении функции, мы сразу же понимаем, каким характеристикам должен соответствовать тип того или иного аргумента.

## Множественность

Контекстов типа может быть и несколько. В этом случае мы перечисляем требуемые классы типов в виде кортежа:

```haskell
nothing :: (Show a, Eq a) => a -> a
nothing value = value
```

Здесь мы требуем, чтобы тип аргумента входил как в контекст класса `Show`, так и в контекст класса `Eq`.

Более того, мы можем указать разные ограничения для разных полиморфных типов. Если бы наша функция `nothing` принимала два аргумента, её объявление могло быть таким:

```haskell
nothing :: (Show a, Show b, Eq b) => a -> b -> String
nothing value1 value2 = show value1 ++ show value2
```

Тип первого аргумента должен входить в контекст класса `Show`, в то время как тип второго должен входить в контексты сразу двух классов, `Show` и `Eq`.

Работая с Haskell-пакетами, вы будете очень часто встречаться с контекстами типов. Запомните их.

