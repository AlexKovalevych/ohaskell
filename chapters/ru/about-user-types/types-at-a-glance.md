----
title: Типы - одним взглядом
prevChapter: /ru/about-user-types/index.html
nextChapter: /ru/about-user-types/about-value-constructors.html
----

В настоящих проектах нам обязательно понадобятся собственные типы. А как вы помните, язык Haskell уделяет типам самое пристальное внимание.

Прежде всего познакомимся с новыми ключевыми словами. Слово `data` служит для определения типа. Слово `class` используется для определения класса типов. А слово `instance` необходимо для определения экземпляра класса типов. Запомните эти слова, ведь в процессе разработки на Haskell вы будете сталкиваться с ними постоянно.

## Собственный тип

Определим собственный тип для IP-адреса:

```haskell
data IPAddress = IPAddress String
```

Готово. Перед нами - простейший пользовательский тип. А вот как мы будем создавать значение этого типа:

```haskell
let localhost = IPAddress "127.0.0.1"
```

Мы взяли обыкновенную строку и завернули её в типовую обёртку `IPAddress`. Ещё эту обёртку принято называть *конструктором значения*. А чтобы окончательно понять данный принцип, представьте себе, что `IPAddress` - это функция:

```haskell
IPAddress  "127.0.0.1"
|          |
"функция"  значение
```

Таким образом, конструирование значения этого типа можно представить как апплицирование функции `IPAddress` к значению типа `String`: взяли конструктор значения, применили его к обыкновенной строке - и получилась уже не строка, а значение типа `IPAddress`.

Запомните: имя типа не может начинаться с маленькой буквы. Поэтому такой код:

```haskell
data ipAddress = ipAddress String
```

будет отвергнут компилятором.

## Класс типов

Проблема в том, что тип `IPAddress` в его нынешнем виде настолько примитивен, что не представляет для нас большого интереса. Мы, создав значение этого типа, даже не сможем вывести его на экран. И если мы прямо сейчас напишем так:

```haskell
main = putStrLn . show $ IPAddress "127.0.0.1"
```

компилятор выдаст нам следующую ошибку:

```bash
No instance for (Show IPAddress) arising from a use of `show'
```

И мы не имеем права обижаться на компилятор, он поступил совершенно правильно: стандартная функция `show`, преобразующая переданный ей аргумент в строковый вид, не имеет ни малейшего понятия о том, *как* представить объект типа `IPAddress` в виде строки. И она не узнает это до тех пор, пока мы явно не расскажем ей об этом. Вот тут-то и выходят на сцену классы типов.

Класс типов - это логическая группа типов. Она несёт в себе черты, общие для всех этих типов. А черты эти отражены методами, объявленными в данном классе. И каждый тип, имеющий отношение к этому классу, обязан предоставлять собственную реализацию этих методов. Класс типов можно рассматривать как абстрактный интерфейс.

Например, стандартный класс типов `Show` обобщает все типы, объекты которых могут быть "показаны" (shown), то есть отображены в виде стандартной строки. Вот определение этого класса:

```haskell
class Show a where
    show :: a -> String
```

Здесь присутствует один-единственный метод `show`, принимающий в качестве аргумента объект типа `a` и возвращающий строковое отображение этого объекта.

Вы спросите, что это за тип такой - `a`? Это - полиморфный тип. Фактически, это даже и не тип вовсе, это, скажем так, "заменитель типа". В процессе сборки нашей программы на место этого полиморфного типа подставляется некий реальный тип. Благодаря этому метод `show` может применяться к значениям самых разных типов. Программисты из мира C++ сразу вспомнят шаблоны. По сложившейся традиции полиморфные типы принято именовать одной буквой в нижнем регистре, однако вы можете называть их как угодно.

Но откуда же метод `show` узнаёт, *как* ему стрингифицировать объект конкретного типа? Ведь мы можем применить его к объектам разных типов, для которых понятие "показать" может иметь абсолютно разный смысл. Встречайте экземпляр класса типов.

## Экземпляр класса типов

Если класс типов `Show` - это логическая группа для типов, объекты которых можно показать, то экземпляр класса типов `Show` - это объяснение того, _как_ можно показать объект того или иного типа. И если мы хотим показывать объекты типа `IPAddress`, мы обязаны предоставить экземпляр класса типов `Show` для типа `IPAddress`. Сделаем же это:

```haskell
instance Show IPAddress where
    show (IPAddress address) =
        if address == "127.0.0.1" then "localhost" else address
```

Мы использовали ключевое слово `instance`, а полиморфный тип `a` заменили на реальный тип `IPAddress`. Далее следует определение метода `show`, которое и объясняет, как отобразить значение типа `IPAddress` в виде строки.

Кстати, обратите внимание, как необычно определён метод `show`. Вместо простого указания имени аргумента:

```haskell
show address =
    ...
```

мы указали выражение, порождающее значение типа `IPAddress`:

```haskell
show (IPAddress address) =
      |   выражение   |
    ...
```

Сделали мы так для того, чтобы вытащить конкретное строковое значение IP-адреса, находящееся в типовой обёртке `IPAddress`. Чтобы стало понятнее, взгляните на определение ещё раз, но с небольшим уточнением:

```haskell
show (IPAddress address) = if address == "127.0.0.1" then "localhost" else address
                -------       -------                                      -------
```

Видите? Нельзя вытащить реальный адрес из значения типа `IPAddress`, кроме как таким способом. Этот способ называется сравнением с образцом (pattern matching). В Haskell этот способ используется повсеместно, и я даже посвятил ему [отдельную главу](). А пока запомним главную идею сравнения с образцом: с одной стороны от знака равенства - выражение с некой "деталью", с другой стороны от знака равенства - выражение, использующее эту "деталь".

В данном случае деталью является `address`, и мы как бы говорим: "Из левого выражения, порождающего значение типа `IPAddress`, взглянем на строку `address`. Она-то и будет использована в if-else-конструкции справа." Как я уже сказал, этому важному вопросу посвящена отдельная глава, так что мы ещё вернемся к нему.

А теперь пишем:

```haskell
main = putStrLn . show $ IPAddress "127.0.0.1"
```

И получаем ожидаемый вывод:

```bash
localhost
```

## В сухом остатке

* Если видим слово `data` - перед нами пользовательский тип.
* Класс типов - это абстрактный интерфейс, отражающий некие общие черты для набора типов.
* Каждый тип, желающий породниться с неким классом, обязан предоставить свой экземпляр этого класса, определяя его методы на свой лад.

