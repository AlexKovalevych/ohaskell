----
title: Списки - одним взглядом
prevChapter: /ru/about-lists/index.html
nextChapter: /ru/about-lists/ranges.html
----

Списки в Haskell - это наборы элементов одного типа. И когда вы видите в коде квадратные скобки - значит, список где-то рядом.

Вот список из трёх целочисленных элементов:

```haskell
[1, 2, 3]
```

а вот пустой список:

```haskell
[]
```

Элементами списка могут быть значения любого типа, в том числе и другие списки. Мы даже можем создать список функций, но после прочтения предыдущих глав вас этот факт не должен удивлять.

## Простейшие действия

Если списки создаются - значит это кому-нибудь нужно. Вот функция, возвращающая список из трёх строк:

```haskell
listOfNames :: String -> [String]
listOfNames prefix =
    [prefix ++ "John", prefix ++ "Anna", prefix ++ "Andrew"]

main = print $ listOfNames "Dear "
```

Результат:

```bash
["Dear John","Dear Anna","Dear Andrew"]
```

Обратите внимание на объявление этой функции:

```haskell
listOfNames :: String -> [String]
```

Тип `[String]` - это тип списка строк. А, например, список символов объявляется как `[Char]`. Кстати, строка - это и есть список символов, то есть тип `String` эквивалентен типу `[Char]`. Поэтому объявление может быть и таким:

```haskell
listOfNames :: String -> [[Char]]  -- Возвращает список списков символов.
```

Вот так можно узнать размер списка:

```haskell
main =
    print $ length listOfAnimals
    where listOfAnimals = ["Bear", "Tiger", "Lion", "Wolf"]
```

А так можно узнать, присутствует ли заданное значение в списке:

```haskell
thisIsAWildAnimal :: String -> Bool
thisIsAWildAnimal name =
    name `elem` wildAnimals
    where wildAnimals = ["Bear", "Tiger", "Lion", "Wolf"]

main = print $ if thisIsAWildAnimal "Cat" then "Yes!" else "No!"
```

Здесь функция стандартная функция `elem`, записанная в инфиксной форме (то есть между двумя своими аргументами), проверяет наличие строки `"Cat"` в списке диких животных.

Стандартная библиотека Haskell позволяет делать со списком самые разные вещи, такие как получение минимального значения, вычисления суммы элементов, извлечение части списка, проверка на пустоту и равенство и так далее и в том же духе.

## Неизменность списка

Как вы знаете, все значения в Haskell неизменны, как Египетские пирамиды. Списки - не исключение: мы не можем изменить список, мы можем лишь создать на его основе новый список. Например:

```haskell
addNewHostToFront :: String -> [String] -> [String]
addNewHostToFront newHost listOfHosts = newHost : listOfHosts

main =
    print $ addNewHostToFront "124.67.54.90" listOfHosts
    where listOfHosts = ["45.67.78.89", "123.45.65.54", "127.0.0.1"]
```

Вывод:

```bash
["124.67.54.90","45.67.78.89","123.45.65.54","127.0.0.1"]
```

С концептуальной точки зрения функция `addNewHostToFront` добавила новый адрес в начало переданного ей списка. Но в действительности никакого добавления не произошло: функция просто взяла значение `newHost` и список `listOfHosts` и создала на их основе новый список, содержащий уже четыре адреса вместо трёх.

## Действия над элементами

Мы создаём список для того, чтобы что-то делать с его элементами. Например, такая функция:

```haskell
removeAllEmptyNamesFrom :: [String] -> [String]
removeAllEmptyNamesFrom listOfNames =
    filter notEmptyName listOfNames
    where notEmptyName = not . null

main =
    print $ removeAllEmptyNamesFrom listOfNames
    where listOfNames = ["John", "", "Ann"]
```

Стандартная функция `filter` последовательно применяет предикат `notEmptyName` к каждой строке в списке и конструирует новый список лишь из тех строк, которые удовлетворяют этому предикату. В качестве предиката выступает функция, применяющаяся к одной строке и возвращающая значение `True` только в том случае, если эта строка не `null` (то есть непустая). Обратите внимание, мы вновь использовали короткую форму записи функции notEmptyName, опустив имя аргумента.

## Сворачивание

Об этом механизме я не могу промолчать, уж очень он занимательный и полезный. Речь идёт о сворачивании (folding) списка. Суть его очень проста и элегантна, а потому сворачивание очень часто используется на практике.

Сворачивание - это процесс превращения всех элементов списка в одно значение. Сразу пример:

```haskell
main =
    putStrLn $ foldl (++) "http" ["://", "www", ".", "google.com"]
```

Вывод будет следующим:

```bash
http://www.google.com
```

Стандартная функция `foldl` сворачивает список слева (название собрано из слов "fold left"). Рассмотрим, как же она работает.

Для сворачивания элементов используется бинарная функция, в данном случае оператор `(++)`. На первом шаге функция `foldl` берёт начальное значение `"http"` и первый элемент `"://"`, а затем применяет к ним оператор конкатенации. В результате получается строка `"http://"`. На втором шаге оператор конкатенации применяется уже к этой строке и ко второму элементу `"www"`, в результате чего получаем `"http://www"`. На третьем шаге складываем эту строку с третьим элементом `"."`, получив `"http://www."`. И на последнем шаге складываем получившееся с четвёртым элементом, и вот перед нами полная строка `"http://www.google.com"`. Таким образом, функция `foldl` постепенно скомкала (свернула) все строки в одну.

Впрочем, вы можете увидеть все эти шаги воочию, достаточно воспользоваться стандартной функцией `scanl`:

```haskell
main =
    print $ scanl (++) "http" ["://", "www", ".", "google.com"]
```

Результат будет таким:

```bash
["http","http://","http://www","http://www.","http://www.google.com"]
```

Функция `scanl` выступает в роли эдакого рентгена для функции `foldl`, показывая внутреннюю работу последней: в возвращённом списке строк мы видим, как сворачивается наш изначальный список.

Разумеется, сворачивать список можно не только слева, но и справа. Для этого, как вы уже догадались, следует использовать функцию `foldr`:

```haskell
main =
    putStrLn $ foldr (++) ".com" ["http", "://", "www", ".", "google"]
```

Результат будет таким же, мы просто свернули строки справа, о чём нам может поведать функция `scanr`:

```haskell
main =
    print $ scanr (++) ".com" ["http", "://", "www", ".", "google"]
```

Вывод:

```bash
["http://www.google.com","://www.google.com","www.google.com",".google.com","google.com",".com"]
```

Взгляните на этот список справа налево - и вы сразу поймёте, *как* происходило сворачивание на этот раз. Кстати, если вам не нужно начальное значение, на помощь придут функции `foldl1` и `foldr1`. Да, название не очень, но уж какое есть. Этим функциям не требуется начальное значение, они сразу же начинают работать с элементами списка. Упростим наш первый пример:

```haskell
main =
    putStrLn $ foldl1 (++) ["http", "://", "www", ".", "google", ".com"]
```

Таким образом, механизм сворачивания даёт нам простой и очень элегантный способ объединения элементов списка в единое значение.

Вот и всё, что хотелось рассмотреть. Помимо функций, рассмотренных выше, в стандартной библиотеке Haskell присутствуют и многие другие вкусности для работы с элементами (проверки, замены, сортировки, перестановки и тому подобное).

## В сухом остатке

* Список - это набор значений одного типа.
* Мы не можем изменить уже созданный список, мы можем лишь создать на его основе другой список.
* С элементами списка можно совершать различные манипуляции.

