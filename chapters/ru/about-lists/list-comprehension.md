----
title: Генераторы списков
prevChapter: /ru/about-lists/tuples.html
nextChapter: /ru/about-user-types/index.html
----

Понятие "list comprehension" в русскоязычной документации чаще всего переводится как "генератор списка". Строго говоря, это не лучший перевод, но я не смог подобрать ничего лучшего.

Речь пойдёт об одной хитрой конструкции, предназначенной для прохода по элементам списка(ов) и применения к ним некоторых действий, в результате чего будет создан (сгенерирован) новый список. Да-да, это похоже на уже известные нам функции `map` и `filter`, однако есть некоторые дополнительные вкусности.

## Хитрый список

Вот как это выглядит:

```haskell
import Data.Char

main = print [toUpper c | c <- "http"]
```

На выходе получим:

```bash
"HTTP"
```

Рассмотрим поближе:

```haskell
[toUpper c | c <- "http"]
```

Мы видим квадратные скобки... То есть перед нами список? Ну почти. Перед нами - генератор списка. Скелет такой конструкции можно представить так:

```
[OPERATION ELEM | ELEM <- LIST]
```

где `LIST` - список, `ELEM` - элемент этого списка, а `OPERATION` - функция, применяемая к каждому элементу. Мы говорим: "Возьми список `LIST`, последовательно пройдись по всем его элементам и примени к каждому из них функцию `OPERATION`". В результате значения, возвращаемые функцией `OPERATION`, породят новый список.

В данном случае мы пройдём по всем символам строки `http` и применим к каждому из её символов функцию `toUpper`, которая в свою очередь переведёт этот символ в верхний регистр. В результате мы получим новую строку `"HTTP"`.

## Добавляем предикат

Мы можем добавить предикат в эту конструкцию. Тогда её скелет станет таким:

```
[OPERATION ELEM | ELEM <- LIST, PREDICATE]
```

В этом случае мы говорим: "Возьми список `LIST`, последовательно пройдись по всем его элементам и примени функцию `OPERATION` только к тем элементам, которые удовлетворят предикату `PREDICATE`".

Например:

```haskell
import Data.Char

main = print [toUpper c | c <- "http", c == 't']
```

На выходе будет:

```bash
"TT"
```

Мы прошлись по всем четырём символам строки `http`, но функция `toUpper` была применена только к тем символам, которые удовлетворили предикату `c == 't'`. Именно поэтому на выходе мы получили строку лишь из этих двух символов.

Предикатов, кстати, может быть несколько. Например, так:

```haskell
import Data.Char

main = print [toUpper c | c <- "http", c /= 'h', c /= 'p']
```

Вывод в этом случае будет таким же:

```bash
"TT"
```

Здесь два предиката, `c /= 'h'` и `c /= 'p'`. Они соединяются в единый предикат через логическое "И", поэтому мы можем написать и так:

```haskell
[toUpper c | c <- "http", c /= 'h' && c /= 'p']
```

Результат будет таким же.

Обратите внимание на комбинацию символов `/=`. Это функция проверки на неравенство, аналог оператора `!=` в языке C. Кстати, он тоже носит математический окрас. Сравните:

```
/=   -- Haskell-форма
≠    -- математическая форма
```

Симпатично, не правда ли? Прямое сходство, мы лишь передвинули перечеркивающую косую палочку.

## Больше списков

Мы можем использовать генератор для совместной работы с несколькими списками. Скелет в этом случае будет таким:

```
[OPERATION_with_ELEMs | ELEM1 <- LIST1, ..., ELEMN <- LISTN ]
```

Здесь мы работаем сразу с `N` списками, а `OPERATION_with_ELEMs` представляет собой функцию, в которую передаются все элементы наших списков. Например:

```haskell
main =
    print [prefix ++ name | name <- names, prefix <- namePrefix]
    where names = ["James", "Victor", "Denis", "Michael"]
          namePrefix = ["Mr. "]
```

На выходе получим:

```bash
["Mr. James","Mr. Victor","Mr. Denis","Mr. Michael"]
```

Мы последовательно прошлись по всем элементам списков `names` и `namePrefix`. Обратите внимание, в списке `namePrefix` лишь один префикс. Вот что будет, если префиксов два:

```haskell
main =
    print [prefix ++ name | name <- names, prefix <- namePrefix]
    where names = ["James", "Victor", "Denis", "Michael"]
          namePrefix = ["Mr. ", "sir "] -- Теперь префиксов два
```

В этом случае на выходе будет:

```bash
["Mr. James","sir James","Mr. Victor","sir Victor","Mr. Denis","sir Denis","Mr. Michael","sir Michael"]
```

В этом случае мы последовательно использовали _каждый_ элемент из списка `names` и _каждый_ элемент из списка `namePrefix`.

## Добавляем условие

Предикат не всегда применим к элементам списка. В ряде случаев нам нужно условие. Добавим его:

```haskell
main =
    print [if car == "Bentley" then "Wow!" else "Good!" | car <- cars]
    where cars = ["Mercedes",
                  "BMW",
                  "Bentley",
                  "Audi",
                  "Bentley"]
```

Результат:

```bash
["Good!","Good!","Wow!","Good!","Wow!"]
```

Мы прошлись по списку марок автомобилей и применили к каждой из них условие, которое вернуло строку `"Wow!"` или строку `"Good!"`.

## Добавляем локальное выражение

Мы можем добавить сюда и локальное выражение с помощью уже известного нам `let`. Например так:

```haskell
import Data.Char

main = print [toUpper c | c <- "http",
                          let hletter = 'h' in c /= hletter]
```

Промежуточное значение может быть использовано во избежание дубляжа при наличии нескольких предикатов.

## Пример

Разберём более практичный пример:

```haskell
import Data.List

checkGooglerBy :: String -> String
checkGooglerBy email =
    if "gmail.com" `isSuffixOf` email
    then nameFrom email ++ " is a Googler!"
    else email
    where nameFrom fullEmail = takeWhile (/= '@') fullEmail

main = print [checkGooglerBy email | email <- ["adam@gmail.com",
                                               "bob@yahoo.com",
                                               "richard@gmail.com",
                                               "elena@yandex.ru",
                                               "denis@gmail.com"]]
```

Результат:

```haskell
["adam is a Googler!","bob@yahoo.com","richard is a Googler!","elena@yandex.ru","denis is a Googler!"]
```

Мы проанализировали список email-адресов, и заменили все gmail-адреса фразой, начинающейся с имени пользователя.

Рассмотрим эту строку:

```haskell
takeWhile (/= '@') fullEmail
```

Скелет стандартной функции `takeWhile` можно отобразить так:

```
takeWhile PREDICATE LIST
```

Здесь мы говорим: "Последовательно забирай (take) элементы из списка `LIST` до тех пор (While), пока `PREDICATE`, применённый к этим элементам, возвращает `True`. Если наткнёшься на элемент, не соответствующий этому предикату, немедленно прекращай работу и возвращай список из ранее полученных элементов". Нам нужно извлечь имя пользователя из его email-адреса, а значит, мы бежим по email до тех пор, пока символы не равны `'@'`, что и отражается предикатом `(/= '@')`. Как только натыкаемся на собачку - возвращаем всё, находящееся перед ней.

## В сухом остатке

1. Генератор списка - это конструкция, порождающая новый список из одного или нескольких имеющихся списов.
2. Новый список порождается в результате применения различных функций к элементам имеющегося списка/списков.
