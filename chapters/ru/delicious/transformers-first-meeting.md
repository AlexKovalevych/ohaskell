----
title: Трансформеры: первая встреча
prevChapter: /ru/delicious/applicative-functors.html
nextChapter: /ru/delicious/transformers-reader.html
----

Монадные трансформеры (monad transformers) занимают важное место в Haskell. Знать о них необходимо, ведь многие пакеты, живущие в Hackage, используют трансформеры. К тому же, этот языковой механизм весьма элегантен, и потому заслуживает нашего самого пристального внимания.

Суть его очень проста:

**Монадный трансформер - это матрёшка два-в-одном. Он соединяет две монады в одну, с целью объединения свойств этих двух монад в одной монаде.**

Для нашего первого знакомства с трансформерами я выбрал `MaybeT`, ибо это один из самых простых трансформеров.

## Пара слов о пакетах

Прежде всего, нам понадобится пакет `transformers`. Однако устанавливать его вам едва ли придётся, поскольку вместе с ранее установленными пакетами он, скорее всего, уже установился автоматически (как вы помните, многие пакеты используют трансформеры, поэтому указывают пакет `transformers` в своих зависимостях). Но, на всякий случай, выполним:

```bash
$ stack install transformers
```

Вам следует знать и о втором пакете с трансформерами, а именно `mtl` (аббревиатура от **Monad Transformer Library**). Оба эти пакета являются стандартными библиотеками для работы с трансформерами, к тому же, они - братья-близнецы (между ними очень много общего). Устанавливать `mtl` вам точно не придётся, поскольку он установился вместе с уже имеющимся у вас пакетом `MissingH`.

В этой главе я буду использовать `transformers`, а дальше - видно будет.

## Задача

Допустим, мы пишем консольную утилитку, которая, на одном из шагов, должна получить от пользователя его электронную почту. Однако необходимо учесть, что пользователь (по злому ли умыслу, или по недогляду) может ввести что-то не то. Поэтому нам нужна некая проверка, а также возможность оповещения о проблеме, если таковая возникнет.

## Привычный способ

Пишем:

```haskell
emailIsValid :: String -> Bool
-- Пусть наличие '@' будет нашим единственным
-- критерием корректности почтового адреса.
emailIsValid email = '@' `elem` email

getEmail :: IO (Maybe String)
getEmail = do
    email <- getLine  -- Что-то получаем от пользователя...
    return $ if emailIsValid email
             then Just email  -- Всё в порядке.
             else Nothing     -- Нет, ерунда какая-то.

main :: IO ()
main = do
    putStrLn "Input your email, please:"
    email <- getEmail
    -- Проверяем, всё ли правильно сделал наш пользователь...
    case email of
        Nothing -> putStrLn "Wrong email."
        Just email -> putStrLn $ "OK, your email is " ++ email
```

Всё предельно просто: получили, проверили, оповестили. Роль оповещателя играет наша старая знакомая монада `Maybe`. Теперь рассмотрим функцию `getEmail` ещё раз:

```haskell
getEmail :: IO (Maybe String)
getEmail = do
    email <- getLine  
    return $ if emailIsValid email
             then Just email  
             else Nothing     
```

Из-за того, что эта функция возвращает "монаду-в-монаде", мы вынуждены *дважды* обернуть полученную от пользователя строку: сначала в монаду `Maybe` (используя конструктор `Just`), а затем в монаду `IO` (используя функцию `return`). Эдакая конфета в двух фантиках получилась. Так вот монадный трансформер `MaybeT` позволит нам упростить эту функцию.

## Способ с MaybeT

Перепишем:

```haskell
import Control.Monad.Trans.Maybe
import Control.Monad.Trans.Class
import Control.Monad

emailIsValid :: String -> Bool
emailIsValid email = '@' `elem` email

getEmail :: MaybeT IO String
getEmail = do
    email <- lift getLine
    guard $ emailIsValid email
    return email

main :: IO ()
main = do
    putStrLn "Input your email, please:"
    email <- runMaybeT getEmail
    case email of
        Nothing -> putStrLn "Wrong email."
        Just email -> putStrLn $ "OK, your email is " ++ email
```

Наше внимание приковывает обновлённая функция `getEmail`, с неё и начнём. Во-первых, что за странный тип она возвращает?

```haskell
getEmail :: MaybeT IO String
```

А это и есть наш первый трансформер. Вот что он собою представляет:

```haskell
newtype MaybeT m a
```

Конструктор типа `MaybeT` параметризуется двумя типами, `m` и `a`. `m` - некоторый монадный тип, а `a` - тип конкретного значения, содержащегося внутри. Таким образом, видя тип:

```haskell
MaybeT IO String
```

мы понимаем, что речь идёт о строке, завёрнутой в два фантика: сначала в монаду `Maybe`, а затем в монаду `IO`. Этот трансформер говорит нам: "Дайте мне значение, уже завёрнутое в некую монаду, а я добавлю к этой монаде возможности монады `Maybe`."

## Зачем такие сложности

Если в нашем первом примере мы имели дело с двумя монадами, вложенными друг в друга, то в примере с трансформером мы имеем дело с одной монадой, объединяющей в себе `IO` и `Maybe`. Грубо говоря, в первом случае конфета была завёрнута в два независящих друг от друга фантика, а во втором случае эти два фантика склеились в один общий. И нужно это для упрощения функции `getEmail`. Взглянем ещё раз:

```haskell
getEmail = do
    email <- lift getLine
    guard $ emailIsValid email
    return email
```

Обратите внимание: уже нет ни проверочной `if`-конструкции, ни наших знакомых `Just` и `Nothing`. Код действительно упростился, ведь нам уже не нужно дважды заворачивать полученную от пользователя строку, поскольку мы имеем дело уже не с двумя монадами, а с одной объединённой. В этом и заключается фокус: мы по-прежнему работаем с монадой `Maybe`, но теперь делаем это как бы скрытно. Это стало возможным благодаря трансформеру `MaybeT` и двум новичкам, функциям `lift` и `guard`.

## Про лифт

Функция `lift` - это... хм... лифт. Именно представив себе лифт в жилом доме, вы легко поймёте суть этой функции. Вот её объявление:

```haskell
class MonadTrans t where
    lift :: Monad m => m a -> t m a
```

Функция `lift` является единственным методом класса `MonadTrans`, общего класса для всех трансформерных типов пакета `transformers`. И подобно тому, как лифт поднимает нас с первого этажа на второй, функция `lift` берёт некую монаду и поднимает её на более высокий уровень абстракции: была монада - получился трансформер. Именно это и произошло:

```haskell
getEmail = do
    email <- lift getLine
```

Функция `getLine` возвращает `IO String`, а функция `lift` берёт эту монаду и поднимает её до уровня трансформера: была `IO String` - получилась `MaybeT IO String`.

## Про охранника

Функция `guard` не менее любопытна. Как только мы извлекли из нашего трансформерного фантика введённую пользователем строку, она попала на вход проверочного предиката `emailIsValid`. И возвращённое этим предикатом значение поступает на вход функции `guard`. Именно она берёт на себя роль `if`-конструкции из нашего первого примера. Если предикат вернёт `True`, на выходе из `getEmail` будет `Just email`, в противном случае на выходе получим `Nothing`. Это магия трансформера `MaybeT`, о которой было сказано выше: мы погружаем нашу строку в монаду `Maybe`, но это происходит скрытно, без явного использования конструкторов `Just` и `Nothing`.

## Вернёмся к main

Есть в трансформерном примере ещё одно новшество:

```haskell
main = do
    putStrLn "Input your email, please:"
    email <- runMaybeT getEmail  -- А это что за runMaybeT?
    case email of
        Nothing -> putStrLn "Wrong email."
        Just email -> putStrLn $ "OK, your email is " ++ email
```

Функция `runMaybeT` - это ассистент трансформера `MaybeT`. Вот её объявление:

```haskell
runMaybeT :: MaybeT m a -> m (Maybe a)
```

Теперь всё встало на свои места. Вспомните: в первом примере мы имели дело с типом `IO (Maybe String)`, а во втором - с типом `MaybeT IO String`. Теперь заменим `m` и `a` на наши реальные типы - и вот что получится:

```haskell
runMaybeT :: MaybeT IO String -> IO (Maybe String)
```

Функция `runMaybeT` расклеивает наш объединённый монадный фантик на два независимых монадных фантика. На мой взгляд, название `runMaybeT` не самое удачное, но уж какое есть. Теперь мы понимаем, что происходит в этой строке:

```
    email <- runMaybeT getEmail
    |        |         |
    |        |         Возвращаем MaybeT IO String...
    |        |
    |        Затем расклеиваем фантик на IO (Maybe String)...
    |
    А здесь уже обыкновенная Maybe String.
```

После этого мы можем узнать, что же там с нашим пользовательским вводом:

```haskell
    case email of
        Nothing -> putStrLn "Wrong email."
        Just email -> putStrLn $ "OK, your email is " ++ email
```

## В сухом остатке

1. Монадный трансформер объединяет две монады в одну общую.
2. В случае использования `MaybeT` мы работаем с монадой `Maybe`, но делаем это скрытно.
3. Функция `lift` поднимает монаду на следующий этаж абстрации, объединяя её с некоторой второй монадой.
4. Склеив два монадных фантика в один, мы можем расклеить их обратно.

Таков наш первый пример использования трансформеров. Он очень простой, но уже демонстрирует элегантность трансформеров, а в следующих главах мы увидим значительно более интересные примеры.
