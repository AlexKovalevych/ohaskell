----
title: Монады: суть
prevChapter: /ru/delicious/index.html
nextChapter: /ru/delicious/monads-IO.html
----

Произнесите это слово: "монада". Вам страшно? Нет?? Быть не может! Вам должно быть страшно. Все знают, что монады - это самое страшное и самое сложное что есть в языке Haskell!

Позвольте открыть вам тайну: ничего страшного в этих монадах нет.

## Почему их так боятся

Термин "монада" (от греческого μονάς, "единица") пришло в Haskell из мира математики, а именно из теории категорий. Послушайте, как это звучит:

> Монада может быть определена через общее понятие моноида в моноидальной категории. Монада над категорией K - это моноид в моноидальной категории эндофункторов End(K).

Вот поэтому их и боятся: с таким же успехом это определение могло быть написано на китайском. Лично я понял из него чуть меньше чем ничего. Конечно, я прекрасно понял бы его, если бы был знаком с той самой теорией категорий. К счастью, понять суть монад можно и без изучения этой теории.

## Определение

Монады - это механизм, привносящий императивный подход в чисто функциональный язык. Вот и всё. Если нам нужно связать некие шаги в чёткую последовательную цепочку - значит нам нужен монадический механизм.

Впрочем, разве мы не говорили об императивном подходе, рассматривая do-нотацию и взаимодействия с внешним миром? Говорили. Потому что упомянутый в предыдущих главах тип `IO` имеет самое прямое отношения к монадам. А если вспомнить, что ни одно приложение на Haskell не может обойтись без взаимодействия с внешним миром, становится ясно: даже однострочное приложение уровня "Hello World" использует монадический механизм.

## Иллюстрация

Если вы используете Unix-подобную операционную систему, откройте терминал и введите:

```bash
$ cd /usr/lib
$ ls | grep xml
```

Обратите внимание на вторую команду. Это - Unix-канал, связывающий две системные утилиты, а если точнее, связывающий не утилиты, а результаты работы этих утилит. Взгляните:

```bash
ls         |      grep xml

процесс 1  канал  процесс 2
```

Когда первый процесс, соответствующий утилите `ls`, выполнится, он вернёт текст, отображающий содержимое текущего каталога. Этот текст поступает на вход Unix-канала и затем, выходя из него, поступает на вход второго процесса, соответствующего утилите `grep`. Второй процесс фильтрует полученный текст по слову `"xml"` и возвращает некий результат.

Таким образом, Unix-канал создал цепочку из двух звеньев, на выходе из которой мы получаем итоговое "значение", явившееся результатом последовательного выполнения двух "вычислений". И эта цепочка характеризуется двумя важными свойствами: последовательность и изоляция.

Последовательность даёт нам твёрдую уверенность в том, что до тех пор, пока утилита `ls` не завершит свою работу, мы не перейдём к утилите `grep`. Да, с технической точки зрения обе эти утилиты запускаются одновременно и работают параллельно, но для нас с вами их взаимодействие выглядит именно как последовательность: сначала завершили `ls`, а потом перешли к `grep`.

А изоляция обеспечивает взаимодействие звеньев, ничего не знающих друг о друге. Утилита `ls` не догадывается о том, что результат её работы будет подан на вход утилите `grep`. Да и утилита `grep` остаётся в полном неведении о том, что имеет дело с результатом работы утилиты `ls`. Взаимодействие двух этих утилит стало возможным только благодаря тому, что обе они имеют дело с общим "типом данных", а именно с текстом: утилита слева от канала возвращает текст, а утилита справа от канала принимает текст.

В этом и заключается простая суть монадического механизма: связать в последовательную цепочку вычисления, ничего друг о друге не знающие. Теперь вы понимаете, почему работа с вводом и выводом неразрывно связана с монадами, ведь `IO` - это и есть одна из монад. Рассмотрим `IO` внимательнее.
