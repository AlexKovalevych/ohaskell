----
title: Монады: практика
prevChapter: /ru/delicious/monads-IO.html
nextChapter: /ru/delicious/maybe.html
----

Зачем же ради соединения вычислений в последовательную цепочку обматывать эти вычисления в какие-то монадические обёртки?

Главная цель такого подхода: гибкость и упрощение кода. Приступим.

## Разоблачение списков

Списки в Haskell - это тоже монады. Рассмотрим, какую пользу нам может принести этот факт.

Начнём со строки. Она ведь есть ни что иное, как `[Char]`, а это значит, она тоже является монадой. Помните наш пример про исправление URL? Напишем нечто похожее:

```haskell
import Data.Char 

toLowerCase = return . toLower

underlineSpaces char = return $ if char == ' ' then '_' else char

main :: IO ()
main =
    print $ name >>= toLowerCase >>= underlineSpaces
    where name = "Lorem ipsuM"
```

На выходе будет:

```bash
lorem_ipsum
```

Проанализируем. Наше внимание приковывает вот эта строка:

```haskell
name >>= toLowerCase >>= underlineSpaces
```

В глаза бросаются операторы компоновки, а это значит, перед нами монадический конвейер. Слева в него въезжает наша строка name, то есть монада `[Char]`, и едет по нему. А за конвейером её ждут два работника, `toLowerCase` и `underlineSpaces`, каждый из которых вносит в `name` свои изменения.

Вы спросите, в чём же тут соль? Чем это отличается от функций композиции и применения, рассмотренных нами в главе о функциональных цепочках? Ведь там мы тоже конструировали конвейер из трёх функций:

```haskell
addPrefix . encodeAllSpaces . makeItLowerCase $ url
```

Однако отличия имеются, и главное из них в том, что эти три функции работают со строкой, а функции `toLowerCase` и `underlineSpaces` работают с _элементом_ строки. Взгляните:

```haskell
toLowerCase = return . toLower
```

Эта функция ожидает на вход символ, а не строку, ведь стандартная функция `toLower` применяется к значению типа `Char`. И это очень важное свойство функций, компонуемых в монадическую цепочку: они работают со значением, содержащимся в монаде, а не с самой монадой. Поскольку в данном случае монадой является `[Char]`, функция `toLowerCase` работает только с `Char`, извлекаемым из списка оператором компоновки. Понятно, что оператор компоновки, определённый для списка, подразумевает "прогон" монадной функции через _все_ элементы этого списка.

Монадическая цепочка предоставляет нам большую гибкость, ведь функции `toLowerCase` и `underlineSpaces` вообще не знают о том, что работают в конечном итоге со строкой. А значит, эти функции можно соединять для работы с самыми разными монадами, содержащими в себе значения типа `Char`.

Кстати, важное уточнение: функции такого рода могут работать только с монадами, о чём красноречиво говорит функция `return`. Взглянем на определение ещё раз:

```haskell
toLowerCase = return . toLower
```

Функция говорит нам: "Да, я работаю с аргументом типа `Char`, но в конце своей работы я, с помощью функции `return`, возвращаю итоговое значение типа `Char` обратно в какую-то монаду". А вот в какую именно - это уже неважно. Поэтому мы можем написать, например, так:

```haskell
{-# LANGUAGE NoMonomorphismRestriction #-}

import Data.Char

toLowerCase = return . toLower

main :: IO ()
main =
    print $ name >>= toLowerCase
    where name = Just 'A'
```

Обратите внимание на новую для нас строку:

```haskell
{-# LANGUAGE NoMonomorphismRestriction #-}
```

Перед нами - препроцессорный прагма-тег `LANGUAGE`, предназначенный для активизирования того или иного расширения языка Haskell. Расширения используются для добавления в ваш код определённых вкусностей. В данном случае мы активизировали расширение `NoMonomorphismRestriction`. Кстати, если вдруг вы ошибётесь в написании того или иного расширения, на стадии сборки компилятор выскажет своё негодование. А список всех поддерживаемых расширений мы сможем лицезреть, выполнив команду:

```bash
$ ghc --supported-extensions
```

Вернёмся к функции `toLowerCase`. Она остаётся в счастливом неведении о том, что работает уже не со списком символов, а с монадой `Maybe`, содержащей в себе символ. И поэтому функция `return` в теле функции `toLowerCase` завернёт итоговый символ уже не списочную монаду, а в монаду `Maybe`. Таким образом, функцию, задуманную для работы с одной монадой, можно использовать для работы с другими.

Кстати, о монаде `Maybe` будет подробно рассказано в следующей главе. Очень простой тип, но при этом чрезвычайно полезный и потому часто использующийся в реальных проектах.

## Меняем тип

Ещё один пример:

```haskell
import Data.Char

main :: IO ()
main =
    print $ numbers >>= toRealNumbers
    where numbers = "1234567890"
          toRealNumbers = return . digitToInt
```

На выходе нас ждёт:

```bash
[1,2,3,4,5,6,7,8,9,0]
```

Здесь произошло изменение типа монады. Функция `toRealNumbers` превращает символ в его цифровое представление. И вновь оператор компоновки и функция `return` сделали своё красивое дело: на вход была подана монада `[Char]`, а на выходе получили монаду `[Int]`. Таким образом, на протяжении всей цепочки монадическая обёртка остаётся неизменной, а вот наполнение этой обёртки может изменять не только своё значение, но и свой тип.

## Зеркальная компоновка

В стандартном пакете `Prelude` определён ещё один монадический оператор, который можно назвать "зеркальной компоновкой". Всё то же самое, но справа налево. Вот как это будет выглядеть в нашем примере:

```haskell
import Data.Char

main :: IO ()
main =
    print $ toLowerCase =<< underlineSpaces =<< name
    where name = "Lorem ipsuM"
```

Мы просто развернули оператор компоновки наоборот, и теперь значение `name` заезжает в конвейер справа налево. Лично мне классический вариант кажется более удобным, так что выбор между обычной и зеркальной компоновкой - это вопрос эстетический.

Монадические цепочки - красивый и гибкий инструмент связки вычислений. Как мы смогли убедиться, аналогия с Unix-каналом оказалась достаточно точной.

