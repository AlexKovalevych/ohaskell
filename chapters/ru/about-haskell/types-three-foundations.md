----
title: Три кита типизации
prevChapter: /ru/about-haskell/pure-functionality.html
nextChapter: /ru/about-haskell/immutability.html
----

К типам у Haskell отношение очень серьёзное. Его система типов зиждется на трёх китах:

1.  статическая проверка,
2.  строгость,
3.  автоматическое выведение.

## Кит первый

Статическая проверка типов - это проверка типа каждого выражения, выполняемая на стадии компиляции. И если компилятору что-то не понравится в типе какого-либо выражения, компиляция будет прервана с ошибкой.

Соответственно, если компиляция кода на Haskell прошла успешно, мы можем утверждать, что с типами у нас всё в порядке, потому что у нас есть второй кит.

## Кит второй

Строгость типов - это требование соответствия того, что мы ожидаем, тому, что мы получаем.

Например, в языке C мы можем написать такую функцию:
```c
int coefficient() {
    return 12.9;
}
```
Это пример неявного приведения типов. Мы ожидаем значение типа `int`, но фактически получаем значение типа `double`. Однако компилятор языка C спокойно проглотит это, при этом аккуратно отбросив дробную часть возвращаемого значения, ведь тип этого значения будет незримо приведён к `int`.

В Haskell подобный код не имеет ни малейших шансов пройти компиляцию, потому что в этом языке не существует неявного приведения типов: если мы ожидаем целое число - будь добр предоставить именно целое число.

Впрочем, явное приведение типов в Haskell тоже очень ограничено. В том же C++ мы можем написать так:
```cpp
int main() {
    std::cout << (int)'1' << std::endl;
}
```
Взяли значение типа `char` - и грубо переделали его в значение типа `int`. Компилятор - молчок. Последствия такого рода ошибок уже стали притчею во языцех...

В Haskell мы можем явно указать тип некоторого значения, но только если этот тип ассоциативен со значением. То есть если это число 1, мы можем явно указать лишь "числовой" тип (такой, как `Integer` или `Double`). А вот фокусы с приведением символа к целочисленному значению, как это было продемонстрировано выше, в Haskell невозможны.

## Кит третий

Автоматическое выведение типов - это способность компилятора понять тип выражения по самому этому выражению.

Например, в языке C мы обязаны указывать тип явно:
```c
double i = 10.34;
```
В Haskell этого делать не нужно. Мы просто пишем:

    i = 10.34 

Компилятор проанализирует значение `10.34` и сам поймёт, что тип `i` - это `Double`. Впрочем, как уже было сказано, мы _можем_ указать тип выражения явно (а иногда _должны_ это сделать). Вскоре я продемонстрирую это.
