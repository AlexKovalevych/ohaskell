----
title: Чистая функциональность
prevChapter: /ru/about-haskell/index.html
nextChapter: /ru/about-haskell/types-three-foundations.html
----

Haskell - чисто функциональный язык программирования общего назначения. Разберёмся, что это значит.

## Императивный подход

Исторически сложилось так, что наиболее популярным ныне подходом к написанию программ является императивный подход (от английского imperative, приказание). При таком подходе программа представляет собой набор инструкций, которые должны быть выполнены строго в порядке их объявления. Кроме того, императивное программирование подразумевает обязательное наличие оператора присваивания, ведь программист часто меняет состояние множества переменных. Изменение состояния (или значения) переменных является одним из краеугольных камней императивного подхода.

Следствием такого подхода является тот факт, что *любая* функция в программе способна изменять значение той или иной переменной, даже если это изменение касается глобального состояния программы или внешнего мира. Например, любая функция в C++-коде потенциально способна не только изменить длину какого-нибудь глобального контейнера, но и переписать некий файл, изменить запись в БД, отправить HTTP-запрос или вывести текст на экран. С одной стороны, это удобно, но с другой стороны, это игра с огнём. Ведь если в моей императивной программе есть, скажем, три тысячи функций, я вынужден крайне внимательно следить за тем, что делает каждая из них. Не важно, *как* я буду это делать, важно что это прибавит мне головной боли. И мой личный опыт разработки на императивных языках убедительно доказал мне это.

## Декларативный подход

Существует принципиально иной подход к написанию программ, а именно декларативный (от английского declarative, описание), при котором программа представляет собой набор описаний того, что должен представлять собою конечный результат. И как бы странно это ни звучало, декларативное программирование часто позволяет нам вообще не думать о порядке выполнения инструкций. Приведу пример.

Допустим, у нас есть две следующие функции:

```haskell
f1 x = x * x

f2 x = x * x * x
```

Назначение этих функций предельно понятно: первая возвращает значение, равное квадрату своего единственного аргумента, а вторая - кубу своего единственного аргумента. Таким образом:

```haskell
f1 2 = 2 * 2 = 4

f2 2 = 2 * 2 * 2 = 8
```

А теперь напишем так:

```haskell
sum = (f1 2) + (f2 2) = (4) + (8) = 12
```

Тут тоже всё ясно: вызываем каждую из двух функций, а значение `sum` будет равным сумме возвращённых функциями значений.

А теперь вопрос вам, уважаемый читатель: какая из этих двух функций будет вызвана *первой* по счёту? Думаете, `f1`? Правда в том, что когда речь идёт о декларативном подходе, порядок вызова этих двух функций не важен. Не имеет никакого значения, какое число будет посчитано первым, 4 или 8. Важно, что значение `sum` в любом случае будет равным 12. Мы как будто говорим компилятору: "Друг, вот тебе две функции, реши, пожалуйста, сам, какую из них вызывать первой. Мы не хотим об этом думать, нам важен только конечный результат."

Так вот функциональное программирование является одним из воплощений декларативного подхода. И если сказанное выше сбило вас с толку, то я усилю ваше удивление и упомяну такие свойства языка Haskell, как:

1. отсутствие оператора присваивания,
2. чёткая разница между чистыми функциями и функциями с побочными эффектами,
3. ленивость вычислений.

Звучит весьма странно, не так ли? Пойдём же вперёд, и увидим, насколько глубока эта кроличья нора. ;-)
