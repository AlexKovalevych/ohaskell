----
title: Неизменность данных
prevChapter: /ru/about-haskell/types-three-foundations.html
nextChapter: /ru/about-haskell/laziness.html
----

Как было упомянуто ранее, одной из фундаментальных черт языка Haskell является отсутствие оператора присваивания.

Знаете, услышав о котором впервые, я не поверил своим ушам. Как это можно программировать без оператора присваивания?! А как же мы будем изменять состояние наших переменных?

Чтобы разобраться, рассмотрим такую строку:
```haskell
a = 123
```
В императивном языке такая инструкция означает присваивание. В этом случае мы приказываем: "Возьми совокупность байтов, соответствующую значению 123, и замени ею ту совокупность байтов, которая хранилась в переменной `a` до этого". Таким образом, происходит перезапись старого значения новым. Это обычный процесс для императивных языков.

Однако в чисто функциональном языке такая инструкция означает то же, что она означает в математике, а именно равенство. В этом случае мы объявляем: "Значение `a` равно 123".

Вы спросите, в чём разница? Мы ведь в любом случае получаем переменную `a`, равную 123. А разница в том, что присваивание может происходить сколько угодно раз в отношении одной и той же переменной, в то время как объявление равенства может быть указано только единожды. Поэтому если мы объявили, что значение `a` равно 123 - так оно и будет, и ничто не сможет этого изменить. Именно поэтому в языке Haskell нет ни понятия "переменная", ни ключевого слова `const`, ведь все значения в нём константны по своей сути.

Вы спросите, как же мы сможем добавить элемент в какой-нибудь список, если у нас всё константное? Ответ: никак. Мы не можем *изменить* значение, мы можем лишь создать на его основе *новое* значение. О памяти не беспокойтесь: выделена она будет автоматически, равно как и уничтожена, ответственность за это ляжет на встроенный в Haskell сборщик мусора.

Вскоре вы убедитесь, что без оператора присваивания можно прекрасно обходиться.
