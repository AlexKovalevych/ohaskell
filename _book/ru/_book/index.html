<!DOCTYPE HTML>
<html lang="en-US">
    <head prefix="og: http://ogp.me/ns# book: http://ogp.me/ns/book#">
        
        <meta charset="UTF-8">
        <title>О Haskell по-человечески</title>

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="robots" content="index, follow">
        <meta name="author" content="denisshevchenko">
        <meta name="description" content="Book generated using GitBook">
        <meta name="keywords" content="gitbook,github" >
        <meta name="generator" content="www.gitbook.io">

        
        

        <meta property="og:title" content="О Haskell по-человечески">
        <meta property="og:site_name" content="О Haskell по-человечески">
        <meta property="og:type" content="book">
        <meta property="og:locale" content="en_US">

        <meta property="book:author" content="https://github.com/denisshevchenko">
        <meta property="book:tag" content="GitBook">

        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">

        <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

        

        <link rel="stylesheet" href="gitbook/style.css">
        
<link rel="stylesheet" href="gitbook/print.css">

        
    </head>
    <body>
        
    
    <section id="cover">
        <h1>О Haskell по-человечески</h1>
        <h2>By <a href="https://github.com/denisshevchenko">@denisshevchenko</a></h2>
    </section>

    
    <section id="summary">
        <h1>Summary</h1>

        <ul class="summary">
            <li>
                <a href="#README.md">Introduction</a>
            </li>
            
                <li>
                    <a href="#intro/README.md">1) Лирическое вступление</a>
                    
                    <ul>
                        
                            <li>
                                <a href="#intro/who.md">1.1) Кто</a>
                            </li>
                        
                            <li>
                                <a href="#intro/why.md">1.2) Почему</a>
                            </li>
                        
                            <li>
                                <a href="#intro/what-for.md">1.3) Зачем</a>
                            </li>
                        
                            <li>
                                <a href="#intro/for-whom.md">1.4) Для кого</a>
                            </li>
                        
                    </ul>
                    
                </li>
            
                <li>
                    <a href="#prepare/README.md">2) Готовимся к работе</a>
                    
                    <ul>
                        
                            <li>
                                <a href="#prepare/create-project.md">2.1) Создаём проект</a>
                            </li>
                        
                            <li>
                                <a href="#prepare/about-modules-minimum.md">2.2) О модулях, минимум</a>
                            </li>
                        
                            <li>
                                <a href="#prepare/about-hackage.md">2.3) О Hackage</a>
                            </li>
                        
                    </ul>
                    
                </li>
            
                <li>
                    <a href="#about-haskell/README.md">3) Несколько слов о Haskell</a>
                    
                    <ul>
                        
                            <li>
                                <a href="#about-haskell/pure-functionality.md">3.1) Чистая функциональность</a>
                            </li>
                        
                            <li>
                                <a href="#about-haskell/types-three-foundations.md">3.2) Три кита типизации</a>
                            </li>
                        
                            <li>
                                <a href="#about-haskell/immutability.md">3.3) Неизменность данных</a>
                            </li>
                        
                            <li>
                                <a href="#about-haskell/laziness.md">3.4) Лень</a>
                            </li>
                        
                    </ul>
                    
                </li>
            
                <li>
                    <a href="#about-functions/README.md">4) О функциях</a>
                    
                    <ul>
                        
                            <li>
                                <a href="#about-functions/pure-functions.md">4.1) Чистые функции</a>
                            </li>
                        
                            <li>
                                <a href="#about-functions/lambda-functions.md">4.2) λ-функции</a>
                            </li>
                        
                            <li>
                                <a href="#about-functions/higher-order-functions.md">4.3) Функции высшего порядка</a>
                            </li>
                        
                            <li>
                                <a href="#about-functions/functional-chains.md">4.4) Функциональные цепочки</a>
                            </li>
                        
                    </ul>
                    
                </li>
            
                <li>
                    <a href="#about-lists/README.md">5) О списках</a>
                    
                    <ul>
                        
                            <li>
                                <a href="#about-lists/lists-at-a-glance.md">5.1) Списки - одним взглядом</a>
                            </li>
                        
                            <li>
                                <a href="#about-lists/ranges.md">5.2) Диапазоны</a>
                            </li>
                        
                            <li>
                                <a href="#about-lists/tuples.md">5.3) Кортежи</a>
                            </li>
                        
                            <li>
                                <a href="#about-lists/list-comprehension.md">5.4) List comprehension</a>
                            </li>
                        
                    </ul>
                    
                </li>
            
                <li>
                    <a href="#about-user-types/README.md">6) О пользовательских типах</a>
                    
                    <ul>
                        
                            <li>
                                <a href="#about-user-types/types-at-a-glance.md">6.1) Типы - одним взглядом</a>
                            </li>
                        
                            <li>
                                <a href="#about-user-types/about-value-constructors.md">6.2) О конструкторах значений</a>
                            </li>
                        
                            <li>
                                <a href="#about-user-types/type-context.md">6.3) Контекст типа</a>
                            </li>
                        
                            <li>
                                <a href="#about-user-types/composite-types.md">6.4) Составные типы</a>
                            </li>
                        
                            <li>
                                <a href="#about-user-types/deriving.md">6.5) Наследуемые типы</a>
                            </li>
                        
                            <li>
                                <a href="#about-user-types/own-type-classes.md">6.6) Собственные классы типов</a>
                            </li>
                        
                            <li>
                                <a href="#about-user-types/newtype.md">6.7) Новый тип</a>
                            </li>
                        
                    </ul>
                    
                </li>
            
                <li>
                    <a href="#io/README.md">7) Ввод и вывод</a>
                    
                    <ul>
                        
                            <li>
                                <a href="#io/functions-with-side-effects.md">7.1) Функции с побочными эффектами</a>
                            </li>
                        
                            <li>
                                <a href="#io/IO-a.md">7.2) IO a</a>
                            </li>
                        
                            <li>
                                <a href="#io/do-imperative-world.md">7.3) do: императивный мир</a>
                            </li>
                        
                            <li>
                                <a href="#io/exceptions-handling.md">7.4) Обработка исключений</a>
                            </li>
                        
                            <li>
                                <a href="#io/own-exceptions.md">7.5) Собственные исключения</a>
                            </li>
                        
                    </ul>
                    
                </li>
            
                <li>
                    <a href="#delicious/README.md">8) Деликатесы</a>
                    
                    <ul>
                        
                            <li>
                                <a href="#delicious/monads-essence.md">8.1) Монады: суть</a>
                            </li>
                        
                            <li>
                                <a href="#delicious/monads-IO.md">8.2) Монады: на примере IO</a>
                            </li>
                        
                            <li>
                                <a href="#delicious/monads-practice.md">8.3) Монады: практика</a>
                            </li>
                        
                            <li>
                                <a href="#delicious/maybe.md">8.4) Может быть</a>
                            </li>
                        
                            <li>
                                <a href="#delicious/functors.md">8.5) Функторы</a>
                            </li>
                        
                            <li>
                                <a href="#delicious/applicative-functors.md">8.6) Аппликативные функторы</a>
                            </li>
                        
                    </ul>
                    
                </li>
            
                <li>
                    <a href="#miscellaneous/README.md">9) Остальное</a>
                    
                    <ul>
                        
                            <li>
                                <a href="#miscellaneous/about-modules.md">9.1) О модулях</a>
                            </li>
                        
                            <li>
                                <a href="#miscellaneous/recursive-functions.md">9.2) Рекурсивные функции</a>
                            </li>
                        
                            <li>
                                <a href="#miscellaneous/about-apostrophe.md">9.3) Про апостроф</a>
                            </li>
                        
                            <li>
                                <a href="#miscellaneous/about-formatting.md">9.4) О форматировании</a>
                            </li>
                        
                            <li>
                                <a href="#miscellaneous/about-hlint.md">9.5) Про hlint</a>
                            </li>
                        
                    </ul>
                    
                </li>
            
                <li>
                    <a href="#integration/README.md">10) Интеграция</a>
                    
                    <ul>
                        
                            <li>
                                <a href="#integration/c-from-haskell.md">10.1) C из Haskell</a>
                            </li>
                        
                    </ul>
                    
                </li>
            
                <li>
                    <a href="#end/README.md">11) Заключение</a>
                    
                    <ul>
                        
                            <li>
                                <a href="#end/is-this-end.md">11.1) И что, это всё??</a>
                            </li>
                        
                            <li>
                                <a href="#end/gratitudes.md">11.2) Благодарности</a>
                            </li>
                        
                    </ul>
                    
                </li>
            
                <li>
                    <a href="#appendix/README.md">12) Приложения</a>
                    
                    <ul>
                        
                            <li>
                                <a href="#appendix/useful-links.md">12.1) Полезные ссылки</a>
                            </li>
                        
                    </ul>
                    
                </li>
            
        </ul>
    </section>

    
    <section>
        <article id="README.md">
        
            
                <h1 id="-haskell-">О Haskell по-человечески</h1>
<h3 id="-">Приветствую вас!</h3>
<p>Перед вами — книга о Haskell, удивительном, мощном и красивом языке программирования. Я написал её специально для тех, кто плохо представляет себе, что такое функциональное программирование и с чем его едят, но хочет наконец разобраться.</p>
<h3 id="-">Почему эта книга появилась</h3>
<p>Меня достало. Почти все книги по Haskell начинаются с демонстрации быстрой сортировки, и ещё что-то там про факториал… Эта книга не такая. Я расскажу о Haskell человеческим языком, с минимумом академизма, с действительно понятными примерами и по возможности лаконично.</p>
<h3 id="-">Зачем</h3>
<p>Функциональное программирование — это своеобразное гетто посреди мирового мегаполиса программной разработки. Доля функциональных языков на рынке очень мала, а программистов, использующих эти языки, считают либо недосягаемой элитой, либо асоциальными идиотами. Цель этой книги — разрушить такое представление.</p>

            
        
        </article>
    </section>
    
        
        <section>
            <article id="intro/README.md" class="new-chapter">
                <h1>Лирическое вступление</h1>
            </article>

            
                
                    <article id="intro/who.md">
                    
                            
                                <h2 id="-">Кто</h2>
<blockquote>
<p>Я, барон Мюнхгаузен, обыкновенный человек... </p>
</blockquote>
<p>А я, подобно Мюнхгаузену, обыкновенный программист. Самый заурядный самоучка. Когда-то я считал программирование самым скучным видом человеческой деятельности. Последние семь лет я считаю его одним из наиболее интересных дел.</p>
<p>Фредерик Брукс был прав, серебряной пули не существует. И всё же программисты-практики ищут новые инструменты для решения своих непростых задач. Вот и я, после 7 лет опыта программирования на C++, решил искать нечто новое, и именно ради стремления к большей эффективности.</p>
<p>Признаюсь, я начал уставать от сложности C++. Захотелось мне чего-нибудь эдакого. Компилируемость, строгость к типам, высокоуровневые конструкции, красивый синтаксис, универсальность и... что-нибудь попроще. Да, я хотел именно этого. Под руку случайно подвернулся Haskell - и зацепил меня сразу.</p>
<p>Во-первых, отсутствие оператора присваивания. Признаюсь, крышу мне снесло напрочь, и я решил разобраться.</p>
<p>Во-вторых, красота. Я люблю красивый код, а, как выяснилось, код на Haskell может быть очень красивым.</p>
<p>В-третьих, мощь. Продолжайте читать, и чуть позже вы сами в этом убедитесь.</p>
<p>И наконец, простота. Нет, я не оговорился. Мне известно, что к функциональному программированию эпитет «простое» применяется чуть реже, чем никогда. В частности, в отношении Haskell бытует мнение о чрезвычайной, прямо-таки фантастической сложности его освоения. И всё же я повторю: в этом языке меня поразила его простота. И скоро вы поймёте, что я имею в виду.</p>

                            
                        
                    </article>
                
            
                
                    <article id="intro/why.md">
                    
                            
                                <h2 id="-">Почему</h2>
<p>А в самом деле, почему? С чего это я решил написать ещё одну книгу о Haskell?</p>
<p>Причина первая: меня достало! Достало, что почти все известные мне руководства по Haskell начинаются с демонстрации того, как реализовать алгоритм быстрой сортировки. И ещё что-то там про факториал и числа Фибоначчи. Мне за все годы практики ни разу не приходилось реализовывать алгоритм быстрой сортировки. Поэтому я даже не знаю, что это такое.</p>
<p>Исторически сложилось так, что большинство из нас начали свой профессиональный путь именно с императивных языков. И вот вместо того, чтобы показать нам красоту функциональных языков в свете их реального применения, нас тыкают носом в числа Фибоначчи и в почти нами забытую математическую нотацию... Естественно, читая подобные материалы, обычный программист начинает чувствовать себя дебилом, и это чувство отбивает в нём всякую охоту осваивать эту непонятную функциональщину.</p>
<p>Именно поэтому я расскажу о Haskell нормальным, человеческим языком, с минимумом академизма и действительно понятными примерами.</p>
<p>Есть и вторая причина. Все известные мне книги по Haskell слишком объёмны. В них много лишнего. А у нас, программистов-практиков, не так много свободного времени, чтобы проглатывать очередной талмудоподобный труд в 500 страниц. Именно поэтому я расскажу о Haskell по возможности лаконично.</p>

                            
                        
                    </article>
                
            
                
                    <article id="intro/what-for.md">
                    
                            
                                <h2 id="-">Зачем</h2>
<p>Функциональное программирование — это своеобразное гетто посреди мирового мегаполиса программной разработки. Доля функциональных языков на рынке очень мала, а программистов, использующих эти языки, считают либо недосягаемой элитой, либо асоциальными идиотами. Цель данной книги — разрушить такое представление.</p>
<p>В частности, я докажу ложность двух представлений о языке Haskell, а именно а) представление о колоссальной сложности его освоения и б) убеждение в том, что этот язык пригоден исключительно для научных лабораторий MIT.</p>
<p>Да, в прошлом оба эти представления соответствовали действительности. Haskell официально существует с 1990 года, однако его выход в &quot;широкий свет&quot; начался лишь в 2003. Таким образом, в течение 13 лет этот язык действительно был уделом лабораторий, и изучить его было нелегко, поскольку вся имеющаяся на тот момент документация по нему была напичкана математикой. Тогда язык был медленным. Тогда было мало библиотек. Однако то, что было актуально тогда, уже неактуально сегодня.</p>
<p>И ещё об ожиданиях. Не ждите от этой книги всеохватной полноты рассмотрения Haskell и его экосистемы. Кроме того, это не справочник. Я не буду копировать сюда всё содержимое официального сайта Haskell или переводить на русский язык стандарт Haskell 2010. Также здесь не приводится информация, которую госпожа Википедия выдаст вам в один момент (например, повествование об истории языка).</p>
<p>Цель этой книги — протянуть новичкам руку помощи в самом начале их пути.</p>

                            
                        
                    </article>
                
            
                
                    <article id="intro/for-whom.md">
                    
                            
                                <h2 id="-">Для кого</h2>
<p>Если вы дочитали до этого места — значит эта книга для вас. И не беспокойтесь об уровне своей квалификации: если вы уже знаете, что такое компилятор, зачем нужны пользовательские типы и чем объявление функции отличается от её определения — смело продолжайте читать.</p>
<p>Признаюсь вам: на момент написания этой книги я ещё не имел опыта разработки на Haskell и даже не завершил изучение этого языка. Многие удивятся: как же может человек, не имеющий весомого опыта и глубоких знаний в области функционального программирования, браться за написание книги о Haskell?!</p>
<p>Главное препятствие на пути популяризации этого языка (равно как и функционального программирования в целом) заключается в том, что рассказывающие о нём люди зачастую слишком далеки от обыкновенных разработчиков и от обыкновенных задач, решаемых этими разработчиками. И многие из нас, читая какой-нибудь труд, написанный аспирантом МФТИ, часто ловят себя на мысли, мол, куда уж мне до его мозгов...</p>
<p>Именно поэтому автор этой книги — самый обыкновенный программист. Я рассматриваю Haskell не как объект научного исследования, а как инструмент для решения моих повседневных задач. Таких как я — большинство. И если я смог ухватить суть этой функциональщины — значит и вы сможете.</p>
<p>Возможно, вы влюбитесь в этот язык. Возможно, он вызовет у вас отвращение. Могу обещать одно: скучно не будет.</p>
<p>Начнём.</p>

                            
                        
                    </article>
                
            
        </section>
        
    
        
        <section>
            <article id="prepare/README.md" class="new-chapter">
                <h1>Готовимся к работе</h1>
            </article>

            
                
                    <article id="prepare/create-project.md">
                    
                            
                                <h1 id="-">Готовимся к работе</h1>
<p>С корабля на бал. Создаём настоящий проект и готовимся к реальной работе.</p>
<h2 id="-">Создаём проект</h2>
<p>Мы не можем начать изучение языка без испытательного полигона. Поэтому скачайте и установите <a href="http://www.haskell.org/platform/" target="_blank">Haskell Platform</a>.</p>
<p>В состав Haskell Platform входит два важнейших компонента, о которых вам нужно знать:</p>
<ol>
<li><code>ghc</code>, компилятор Haskell (Glasgow Haskell Compiler);</li>
<li><code>ghci</code>, интерпретатор Haskell.</li>
</ol>
<p>Запомнили? А теперь можете забыть. Особенно про интерпретатор. Ведь вы планируете использовать Haskell в реальной работе, а это значит, все ваши проекты будут компилироваться. Да, интерпретатор  бывает полезен в ряде случаев, но без него вполне можно обойтись. Однако и непосредственное использование компилятора вам тоже едва ли понадобится.</p>
<p>В реальной работе вы не будете создавать файлик <code>Main.hs</code> на рабочем столе для последующего скармливания его компилятору. Напротив, вы создадите нормальный рабочий проект с логичной внутренней структурой. Так давайте и создадим такой с самого начала. А поможет нам в этом удобная утилита из Haskell Platform с необычным названием <code>cabal</code>. Эта утилита предназначена для сборки проектов. Уверен, вы слышали о вещах типа <code>cmake</code> или <code>qmake</code>, так вот воспринимайте <code>cabal</code> как <code>cmake</code> для Haskell.</p>
<p>Как вы уже поняли, <code>.hs</code> - стандартное расширение для файлов с исходным кодом на Haskell.</p>
<p>Начнём творить. Разумеется, все описываемые ниже действия подразумевают вашу крепкую дружбу с командной строкой. Я буду приводить Unix-овые команды, если же вы используете Windows - адаптируйте примеры под себя.</p>
<h3 id="-">Готовим структуру</h3>
<p>Открываем терминал и творим:</p>
<pre><code class="lang-bash">$ mkdir -p Real/src/Utils
$ touch Real/src/Main.hs
$ touch Real/src/Utils/Helpers.hs
</code></pre>
<p>Итак, у нас появился каталог Real с привычной структурой: </p>
<pre><code class="lang-bash">Real/
    src/
        Main.hs
        Utils/
            Helpers.hs
</code></pre>
<p>Есть корневой каталог <code>src</code>, внутри которой лежат все наши исходники, некоторым образом сгруппированные.</p>
<p>Кстати, об именах. Вам, вероятно, интересно, почему имена файлов и каталогов внутри каталога <code>src</code> начинаются с большой буквы? Чуть позже я объясню причину. А пока откроем файл <code>Main.hs</code> и напишем в нём:</p>
<pre><code class="lang-haskell"><span class="hljs-title">main</span> = putStrLn <span class="hljs-string">"Hi, haskeller!"</span>
</code></pre>
<p>Закрываем, возвращаемся в корень проекта.</p>
<h3 id="-">Настраиваем</h3>
<p>Выполняем команду:</p>
<pre><code class="lang-bash">$ cabal init
</code></pre>
<p>Мы попадём в интерактивный диалог, в ходе которого нам будет предложено ответить на несколько вопросов о нашем проекте. В конце этого диалога будут автоматически созданы файлы проекта, и наш каталог приобретёт следующее содержимое:</p>
<pre><code class="lang-haskell"><span class="hljs-type">Real</span>.cabal
<span class="hljs-type">Setup</span>.hs
<span class="hljs-title">src</span>/
    <span class="hljs-type">Main</span>.hs
    <span class="hljs-type">Utils</span>/
        <span class="hljs-type">Helpers</span>.hs
</code></pre>
<p>Кстати, если вдруг вы увидите вот такое предупреждение:</p>
<pre><code class="lang-bash">Generating LICENSE...
Warning: unknown license <span class="hljs-built_in">type</span>, you must put a copy <span class="hljs-keyword">in</span> LICENSE yourself.
</code></pre>
<p>не беспокойтесь. Просто добавьте файл <code>LICENSE</code> вручную, для поддержания классического вида проекта.</p>
<p>Как уже было упомянуто, в корневом каталоге нашего проекта появились два новых файла, <code>Real.cabal</code> и <code>Setup.hs</code>. Второй файл нам не так интересен, а вот первый - это и есть сборочный файл нашего проекта. Откроем его:</p>
<pre><code class="lang-haskell"><span class="hljs-comment">-- Initial Real.cabal generated by cabal init.  For further documentation,</span>
<span class="hljs-comment">-- see http://haskell.org/cabal/users-guide/</span>

<span class="hljs-title">name</span>:                <span class="hljs-type">Real</span>
<span class="hljs-title">version</span>:             <span class="hljs-number">0.1</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>
<span class="hljs-title">synopsis</span>:            <span class="hljs-type">Real</span> project <span class="hljs-keyword">in</span> <span class="hljs-type">Haskell</span>
<span class="hljs-comment">-- description:         </span>
<span class="hljs-comment">-- license:             </span>
<span class="hljs-title">license</span>-file:        <span class="hljs-type">LICENSE</span>
<span class="hljs-title">author</span>:              <span class="hljs-type">Denis</span> <span class="hljs-type">Shevchenko</span>
<span class="hljs-title">maintainer</span>:          me@dshevchenko.biz
<span class="hljs-comment">-- copyright:           </span>
<span class="hljs-comment">-- category:            </span>
<span class="hljs-title">build</span>-<span class="hljs-typedef"><span class="hljs-keyword">type</span>:          <span class="hljs-type">Simple</span></span>
<span class="hljs-title">cabal</span>-version:       &gt;=<span class="hljs-number">1.8</span>

<span class="hljs-title">executable</span> <span class="hljs-type">Real</span>
  <span class="hljs-comment">-- main-is:             </span>
  <span class="hljs-comment">-- other-modules:       </span>
  build-depends:       base ==<span class="hljs-number">4.6</span>.*
  hs-source-dirs:      src
</code></pre>
<p>Здесь уже сохранены те самые значения, которые мы вводили в процессе вышеупомянутого диалога. Однако собрать проект прямо сейчас мы не сможем, потому что строка:</p>
<pre><code class="lang-haskell">  <span class="hljs-comment">-- main-is:</span>
</code></pre>
<p>закомментирована. В этом файле принят синтаксис, подобный синтаксису Haskell, и поэтому однострочные комментарии здесь, как и в программном коде, начинаются с двух минусов подряд. Многострочный комментарий, который вам тоже понадобится, заключается между символами <code>{-</code> и <code>-}</code>.</p>
<p>Нам необходимо раскомментировать эту строку и прописать в ней имя файла <code>Main.hs</code>, содержащего функцию <code>main</code>:</p>
<pre><code class="lang-haskell">  main-is: <span class="hljs-type">Main</span>.hs
</code></pre>
<h3 id="-">Конфигурируем</h3>
<p>Выполняем:</p>
<pre><code class="lang-bash">$ cabal configure
</code></pre>
<p>В результате произойдёт подготовка проекта к сборке. Но прежде чем перейти к этой самой сборке, обращаю ваше внимание на последнюю часть файла <code>Real.cabal</code>:</p>
<pre><code class="lang-haskell"><span class="hljs-title">executable</span> <span class="hljs-type">Real</span>
  main-is:             <span class="hljs-type">Main</span>.hs             
  <span class="hljs-comment">-- other-modules:       </span>
  build-depends:       base ==<span class="hljs-number">4.6</span>.*
  hs-source-dirs:      src
</code></pre>
<p>Видите отступ в два пробела перед четырьмя последними строчками? Оказывается, этот отступ необходим, и без него проект не соберётся. Кроме того, отступ этот должен быть не менее двух пробелов. Я рекомендую четыре, для красоты.</p>
<p>И ещё одна деталь. Это необязательно, но лишним не будет. Допишем в секцию executable Real ещё одну строку:</p>
<pre><code class="lang-haskell">  ghc-options:         -<span class="hljs-type">W</span>
</code></pre>
<p>Параметр <code>ghc-options</code> позволяет задавать флаги <code>ghc</code>. В частности, флаг <code>-W</code> вежливо попросит <code>ghc</code> показывать все основные предупреждения при компиляции. Не пренебрегайте этой возможностью.</p>
<h3 id="-">Собираем</h3>
<p>Выполняем:</p>
<pre><code class="lang-bash">$ cabal build
Building Real-<span class="hljs-number">0.1</span>.<span class="hljs-number">0.0</span>...
Preprocessing executable <span class="hljs-string">'Real'</span> <span class="hljs-keyword">for</span> Real-<span class="hljs-number">0.1</span>.<span class="hljs-number">0.0</span>...
[<span class="hljs-number">1</span> of <span class="hljs-number">1</span>] Compiling Main             ( src/Main.hs, dist/build/Real/Real-tmp/Main.o )
Linking dist/build/Real/Real ...
</code></pre>
<p>Готово. В нашем каталоге появилось кое-что новенькое:</p>
<pre><code class="lang-bash">LICENSE
Real.cabal
Setup.hs
dist/
    build/
        Real/
            Real  &lt;- Это и есть исполняемый файл.
...
</code></pre>
<p>Остальное содержимое каталога <code>dist</code> нас пока не интересует.</p>
<h3 id="-">Запускаем</h3>
<p>Пришло время запустить наше приложение. Находясь в корне проекта, выполняем:</p>
<pre><code class="lang-bash">$ ./dist/build/Real/Real
Hi haskeller!
</code></pre>
<p>Вот и всё. Теперь вы знаете, как создавать, настраивать и собирать Haskell-проект. Вероятно, вас интересует, зачем мы создавали файл <code>Helpers.hs</code> в подкаталоге <code>Utils</code>? Какой в нём смысл, если он всё равно остался пустым? В следующей главе вы это узнаете.</p>

                            
                        
                    </article>
                
            
                
                    <article id="prepare/about-modules-minimum.md">
                    
                            
                                <h2 id="-">О модулях, минимум</h2>
<p>Настоящие проекты никогда не состоят из одного-единственного файла. Пришла пора узнать о модулях.</p>
<p>Исходные файлы в Haskell-проекте - это и есть модули. Один файл - один модуль. Таким образом, в нашем проекте сейчас есть два модуля: <code>Main.hs</code> и <code>Helpers.hs</code>.</p>
<p>В Haskell нет заголовочных файлов. Каждый из модулей рассматривается как самостоятельная единица проекта, содержащая в себе разные интересные вещи. И чтобы воспользоваться этими интересными вещами, нужно один модуль импортировать в другой.</p>
<p>Откроем наш пустой файл <code>Helpers.hs</code> и напишем в нём:</p>
<pre><code class="lang-haskell"><span class="hljs-module"><span class="hljs-keyword">module</span> Helpers <span class="hljs-keyword">where</span></span>

<span class="hljs-title">hello</span> user = <span class="hljs-string">"Hi, "</span> ++ user
</code></pre>
<p>Первой строкой мы объявили, что имя этого модуля - <code>Helpers</code>. Далее, после ключевого слова <code>where</code>, мы наполнили модуль содержимым. Содержимое у нас предельно простое, но пока не спрашивайте меня, что такое <code>hello</code>. Очень скоро мы выясним это.</p>
<h3 id="-">Импортируем</h3>
<p>Откроем файл <code>Main.hs</code> и чуток изменим его:</p>
<pre><code class="lang-haskell"><span class="hljs-import"><span class="hljs-keyword">import</span> Helpers</span>

<span class="hljs-title">main</span> = putStrLn (hello <span class="hljs-string">"denis"</span>)
</code></pre>
<p>Мы включили наш модуль <code>Helpers</code> с помощью директивы <code>import</code>. Теперь  можно воспользоваться содержимым этого модуля, а именно той самой штуковиной по имени <code>hello</code>.</p>
<h3 id="-">Упоминаем</h3>
<p>Теперь упомянем модуль <code>Helpers</code> в сборочном файле <code>Real.cabal</code>. Открываем его и прописываем наш модуль:</p>
<pre><code class="lang-haskell"><span class="hljs-title">executable</span> <span class="hljs-type">Real</span>
    main-is:             <span class="hljs-type">Main</span>.hs             
    other-modules:       <span class="hljs-type">Helpers</span>
    build-depends:       base ==<span class="hljs-number">4.6</span>.\*
    hs-source-dirs:      src
</code></pre>
<p>Мы раскомментировали строку other-modules и указали имя нашего модуля. Обращаю ваше внимание: указать нужно не имя файла, а имя модуля.</p>
<p>Но раз уж мы указали имя нашего модуля, необходимо указать и место, где его искать. Ведь он лежит не в каталоге src, а в подкаталоге src/Utils. Поэтому в сборочном файле ищем параметр hs-source-dirs и дописываем:</p>
<pre><code class="lang-haskell">    hs-source-dirs:      src
                         src/<span class="hljs-type">Utils</span>
</code></pre>
<p>Сохраняем, собираем:</p>
<pre><code class="lang-bash">$ cabal build
Building Real-<span class="hljs-number">0.1</span>.<span class="hljs-number">0.0</span>...
Preprocessing executable <span class="hljs-string">'Real'</span> <span class="hljs-keyword">for</span> Real-<span class="hljs-number">0.1</span>.<span class="hljs-number">0.0</span>...
[<span class="hljs-number">1</span> of <span class="hljs-number">2</span>] Compiling Helpers          ( src/Utils/Helpers.hs, dist/build/Real/Real-tmp/Helpers.o )
[<span class="hljs-number">2</span> of <span class="hljs-number">2</span>] Compiling Main             ( src/Main.hs, dist/build/Real/Real-tmp/Main.o )
Linking dist/build/Real/Real ...
</code></pre>
<p>Получилось: уже не один, а два модуля были скомпилированы. Теперь запускаем:</p>
<pre><code class="lang-bash">$ ./dist/build/Real/Real
Hi, denis
</code></pre>
<p>Работает.</p>
<h3 id="-">Об именах</h3>
<p>Здесь есть два правила.</p>
<p>Во-первых, имя модуля должно начинаться с большой буквы. В отношении имён подпапок внутри <code>src</code> принята та же практика.</p>
<p>Во-вторых, имя модуля должно совпадать с именем соответствующего ему файла. Именно поэтому файл, содержащий модуль <code>Helpers</code>, назван <code>Helpers.hs</code>. Это, кстати, удобно, во избежание путаницы.</p>
<p>Вот и всё. Теперь вы знаете, как организовать настоящий Haskell-проект. Позже я расскажу о модулях кое-что ещё, но на данный момент вам необходимо знать лишь это.</p>

                            
                        
                    </article>
                
            
                
                    <article id="prepare/about-hackage.md">
                    
                            
                                <h2 id="-hackage">О Hackage</h2>
<p>Если вы работали с Linux, вам знакомо понятие &quot;репозиторий&quot;: эдакое централизованное место, откуда можно взять много разных вкусностей. Так вот Hackage - это главный репозиторий в мире Haskell.</p>
<p>Название происходит от слияния слов Haskell и package. Существует он с 2008 года, и представляет собой большую-пребольшую кучу пакетов. Воспринимайте пакет как библиотеку, однако в мире Haskell закрепилось понятие &quot;пакет&quot; (package).</p>
<p>Среди этой кучи вы найдёте очень много готовых решений, как для стандартных задач, так и для узкоспециализированных.</p>
<p>Чтобы воспользоваться пакетом, нам необходимо сделать четыре шага:</p>
<ol>
<li>найти этот пакет,</li>
<li>установить его,</li>
<li>добавить его в наш проект,</li>
<li>импортировать из него нужные нам модули.</li>
</ol>
<h3 id="-">Ищем</h3>
<p>Рекомендую искать пакеты здесь:</p>
<ol>
<li><a href="http://www.haskell.org/hoogle/" target="_blank">Hoogle</a></li>
<li><a href="http://holumbus.fh-wedel.de/hayoo/hayoo.html" target="_blank">Hayoo!</a></li>
</ol>
<p>Вбиваем в строке поиска нужное вам название, или категорию, или некое ассоциативное слово - и получаем много интересных результатов.</p>
<p>Для примера установим пакет <code>text</code>, продвинутый пакет для работы с... текстом, очевидно.</p>
<h3 id="-">Устанавливаем</h3>
<p>Существует инструмент для удобной установки пакетов из Hackage, и имя ему <code>cabal</code>. Да-да, та самая, уже знакомая нам утилита!</p>
<p>Переходим в корень нашего проекта и выполняем команду:</p>
<pre><code class="lang-bash">$ cabal update
</code></pre>
<p>Этой командной мы обновляем список всех доступных пакетов. Рекомендуется периодически выполнять эту команду, чтобы всегда быть &quot;на острие&quot; развития Hackage.</p>
<p>После обновления списка устанавливаем наш пакет:</p>
<pre><code class="lang-bash">$ cabal install text
</code></pre>
<p>Чуток терпения - и пакет установлен.</p>
<h3 id="-">Добавляем в проект</h3>
<p>Открываем сборочный файл <code>Real.cabal</code> и прописываем в нём имя установленного пакета. Для этого находим параметр <code>build-depends</code> и через запятую дописываем имя пакета:</p>
<pre><code class="lang-haskell"><span class="hljs-title">build</span>-depends:   base == <span class="hljs-number">4.6</span>.\*, text
</code></pre>
<p>И последний шаг.</p>
<h3 id="-">Импортируем модули</h3>
<p>Пакет состоит из модулей (а модули, как вы уже знаете, это файлы исходного кода). В пакете <code>text</code> модулей весьма много, мы выберем самый первый по счёту, <code>Data.Text</code>. Открываем <code>Main.hs</code> и пишем в самом начале:</p>
<pre><code class="lang-haskell"><span class="hljs-import"><span class="hljs-keyword">import</span> Data.Text</span>
</code></pre>
<p>Готово. Теперь мы можем использовать разные вкусные вещи из этого модуля. А вот какие именно вещи и как их использовать - об этом вы узнаете в ближайшем будущем.</p>
<h3 id="-">О прелюдии</h3>
<p>Есть один стандартный модуль, который по умолчанию импортируется во все ваши модули. Имя ему - <a href="http://hackage.haskell.org/package/base/docs/Prelude.html" target="_blank">Prelude</a>. В нём содержатся самые базовые Haskell-инструменты, многие из которых вы будете использовать постоянно.</p>

                            
                        
                    </article>
                
            
        </section>
        
    
        
        <section>
            <article id="about-haskell/README.md" class="new-chapter">
                <h1>Несколько слов о Haskell</h1>
            </article>

            
                
                    <article id="about-haskell/pure-functionality.md">
                    
                            
                                <h1 id="-">Чистая функциональность</h1>
<p>Haskell - чисто функциональный язык программирования общего назначения.</p>
<p>Исторически сложилось так, что наиболее популярным ныне подходом к написанию программ является императивный подход (от английского imperative, приказание). При таком подходе программа представляет собой набор инструкций, которые должны быть выполнены строго в том порядке, в котором эти инструкции указаны. Кроме этого, императивное программирование подразумевает наличие оператора присваивания, потому что программист часто меняет состояние множества переменных.</p>
<p>Однако существует принципиально иной подход к написанию программ, а именно декларативный (от английского declarative, описание), при котором программа представляет собой набор описаний того, что же она должна в итоге сделать. Функциональное программирование является одним из воплощений декларативного подхода. При таком подходе порядок выполнения инструкций зачастую неважен. Более того, в Haskell нет оператора присваивания, и все переменные в нём вовсе не переменные, а самые что ни на есть постоянные.</p>
<p>И чтобы окончательно сбить вас с толку, упомяну такие свойства Haskell, как:</p>
<ol>
<li>наличие чистых функций,</li>
<li>разница между чистыми функциями и функциями с побочными эффектами,</li>
<li>ленивость вычислений.</li>
</ol>
<p>Звучит весьма странно, поэтому начнём разбираться.</p>

                            
                        
                    </article>
                
            
                
                    <article id="about-haskell/types-three-foundations.md">
                    
                            
                                <h2 id="-">Три кита типизации</h2>
<p>К типам у Haskell отношение очень серьёзное. Его система типов зиждется на трёх китах:</p>
<ol>
<li>статическая проверка,</li>
<li>строгость,</li>
<li>автоматическое выведение.</li>
</ol>
<h3 id="-">Кит первый</h3>
<p>Статическая проверка типов - это проверка типа каждого выражения, выполняемая на стадии компиляции. И если компилятору что-то не понравится в типе какого-либо выражения, компиляция будет прервана с ошибкой.</p>
<p>Соответственно, если компиляция кода на Haskell прошла успешно, мы можем утверждать, что с типами у нас всё в порядке, потому что у нас есть второй кит.</p>
<h3 id="-">Кит второй</h3>
<p>Строгость типов - это требование соответствия того, что мы ожидаем, тому, что мы получаем.</p>
<p>Например, в языке C мы можем написать такую функцию:</p>
<pre><code class="lang-c"><span class="hljs-keyword">int</span> coefficient() {
    <span class="hljs-keyword">return</span> <span class="hljs-number">12.9</span>;
}
</code></pre>
<p>Это пример неявного приведения типов. Мы ожидаем значение типа <code>int</code>, но фактически получаем значение типа <code>double</code>. Однако компилятор языка C спокойно проглотит это, при этом аккуратно отбросив дробную часть возвращаемого значения, ведь тип этого значения будет незримо приведён к <code>int</code>.</p>
<p>В Haskell подобный код не имеет ни малейших шансов пройти компиляцию, потому что в этом языке не существует неявного приведения типов: если мы ожидаем целое число - будь добр предоставить именно целое число.</p>
<p>Впрочем, явное приведение типов в Haskell тоже очень ограничено. В том же C++ мы можем написать так:</p>
<pre><code class="lang-cpp"><span class="hljs-keyword">int</span> main() {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; (<span class="hljs-keyword">int</span>)<span class="hljs-string">'1'</span> &lt;&lt; <span class="hljs-built_in">std</span>::endl;
}
</code></pre>
<p>Взяли значение типа <code>char</code> - и грубо переделали его в значение типа <code>int</code>. Компилятор - молчок. Последствия такого рода ошибок уже стали притчею во языцех...</p>
<p>В Haskell мы можем явно указать тип некоторого значения, но только если этот тип ассоциативен со значением. То есть если это число 1, мы можем явно указать лишь &quot;числовой&quot; тип (такой, как <code>Integer</code> или <code>Double</code>). А вот фокусы с приведением символа к целочисленному значению, как это было продемонстрировано выше, в Haskell невозможны.</p>
<h3 id="-">Кит третий</h3>
<p>Автоматическое выведение типов - это способность компилятора понять тип выражения по самому этому выражению.</p>
<p>Например, в языке C мы обязаны указывать тип явно:</p>
<pre><code class="lang-c"><span class="hljs-keyword">double</span> i = <span class="hljs-number">10.34</span>;
</code></pre>
<p>В Haskell этого делать не нужно. Мы просто пишем:</p>
<pre><code><span class="hljs-attribute">i </span>=<span class="hljs-string"> 10.34 </span>
</code></pre><p>Компилятор проанализирует значение <code>10.34</code> и сам поймёт, что тип <code>i</code> - это <code>Double</code>. Впрочем, как уже было сказано, мы <em>можем</em> указать тип выражения явно (а иногда <em>должны</em> это сделать). Вскоре я продемонстрирую это.</p>

                            
                        
                    </article>
                
            
                
                    <article id="about-haskell/immutability.md">
                    
                            
                                <h2 id="-">Неизменность данных</h2>
<p>Одним из фундаментальных свойств Haskell языка является отсутствие оператора присваивания.</p>
<p>Это именно то свойство, услышав о котором впервые, я не поверил своим ушам. Каким образом можно программировать без оператора присваивания? А как же мы будем изменять состояние наших переменных? Моё удивление можно было понять: в процессе написания кода на C++ я часто использую оператор присваивания.</p>
<p>Чтобы разобраться, рассмотрим такую строку:</p>
<pre><code><span class="hljs-attribute">a </span>=<span class="hljs-string"> 123</span>
</code></pre><p>В императивном языке такая инструкция означает присваивание. В этом случае мы приказываем: &quot;Возьми совокупность байтов, соответствующую значению 123, и замени ею ту совокупность байтов, которая хранилась в переменной a до этого&quot;. Таким образом, происходит перезапись старого значения новым.</p>
<p>Однако в чисто функциональном языке такая инструкция означает то же, что она означает в математике, а именно равенство. В этом случае мы объявляем: &quot;Значение a равно 123&quot;.</p>
<p>Вы спросите, в чём разница? Мы в любом случае получаем переменную a со значением 123. А разница в том, что присваивание может происходить множество раз в отношении одной и той же переменной, в то время как объявление равенства может быть указано только единожды. Поэтому если мы объявили, что значение a равно 123, то так оно и будет, раз и навсегда. Именно поэтому в языке Haskell нет ни понятия &quot;переменная&quot;, ни ключевого слова const, ведь все значения в нём константны по своей сути.</p>
<p>Вы спросите, как же мы сможем добавить элемент в какую-нибудь коллекцию, если у нас всё константное? Ответ: никак. Мы не можем изменить значение, мы можем лишь создать на его основе новое значение. О памяти не беспокойтесь: выделена она будет автоматически, равно как и уничтожена, ответственность за это ляжет на встроенный в Haskell сборщик мусора.</p>
<p>Вскоре вы убедитесь, что без оператора присваивания можно прекрасно жить.</p>

                            
                        
                    </article>
                
            
                
                    <article id="about-haskell/laziness.md">
                    
                            
                                <h2 id="-">Лень</h2>
<p>Язык Haskell - ленивый, поэтому он не делает работу, результат которой никому не нужен.</p>
<h3 id="-c-">Начнём с C++</h3>
<p>Допустим, нам нужен список из некоторого числа одинаковых IP-адресов. Да, в реальной жизни нам такое едва ли понадобится, но этот пример хорошо покажет нам суть ленивых вычислений.</p>
<p>Функция, возвращающая список адресов, на C++ может выглядеть так:</p>
<pre><code class="lang-cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;</span> IPAddresses;

IPAddresses generate_addresses( size_t howMany,
                                <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; address ) {
    <span class="hljs-keyword">const</span> IPAddresses addresses( howMany, address );
    <span class="hljs-keyword">return</span> addresses;
}
</code></pre>
<p>Теперь нам понадобилась функция, получающая заданное количество адресов из этого списка и выводящая их на экран. Например:</p>
<pre><code class="lang-cpp"><span class="hljs-keyword">void</span> take_and_print( size_t howMany,
                     <span class="hljs-keyword">const</span> IPAddresses&amp; addresses ) {
    <span class="hljs-keyword">for</span>( size_t i = <span class="hljs-number">0</span>; i &lt; howMany; ++i ) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; addresses[i] &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    }
} 

<span class="hljs-keyword">int</span> main() {
    take_and_print( <span class="hljs-number">2</span>, generate_addresses( <span class="hljs-number">100</span>, <span class="hljs-string">"127.0.0.1"</span> ) );
}
</code></pre>
<p>Функция <code>take_and_print</code> получает список, возвращённый функцией <code>generate_addresses</code>, а потом печатает первые два адреса из этого списка.</p>
<p>Вывод будет таким:</p>
<pre><code class="lang-bash"><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>
<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>
</code></pre>
<p>И всё бы хорошо, но из 100 созданных строк фактически потребовались лишь первые две.  Оставшиеся 98 строк были созданы абсолютно напрасно. Было затрачено время, была затрачена память - и всё впустую.</p>
<p>Это - следствие строгости вычислений, присущей языку C++. Функция <code>generate_addresses</code> прямолинейна и сразу рвётся в бой. Сказали ей создать 100 адресов - получите 100. Скажут создать миллион - пожалуйста, вот вам миллион. Скажут миллиард - ну что ж, потерпите чуток, но будет вам и миллиард.</p>
<p>Тем временем функция <code>take_and_print</code> столь же прямолинейна, и ей абсолютно наплевать на усилия трудолюбивой функции <code>generate_addresses</code>. Если ей сказали отобразить лишь первые два элемента полученного контейнера, именно это она и сделает. И ей без разницы, сколько там ещё осталось элементов, десять или полмиллиарда.</p>
<p>Результатом строгости вычислений является лишняя работа. Но функции в Haskell, в отличие от своих трудолюбивых коллег из C++, терпеть не могут лишней работы.</p>
<h3 id="-haskell">А вот как в Haskell</h3>
<p>Откроем файл <code>Main.hs</code> и перепишем его:</p>
<pre><code class="lang-haskell"><span class="hljs-title">main</span> = print (take <span class="hljs-number">2</span> (replicate <span class="hljs-number">100</span> <span class="hljs-string">"127.0.0.1"</span>))
</code></pre>
<p>Функция <code>replicate</code> создаёт список из 100 адресов вида <code>127.0.0.1</code>, а функция <code>take</code> берёт 2 первых адреса из этого списка (о чём свидетельствует число 2, переданное ей в качестве первого аргумента). Функция <code>print</code> приводит это хозяйство к строковому виду и выводит на экран. Не обращайте внимания на синтаксические непонятности этого кода. В последующих главах они будут разъяснены в высшей степени подробно.</p>
<p>Весь фокус в том, что функция <code>replicate</code> создаёт список вовсе не из 100 адресов, а всего из двух. Почему? Потому что именно столько понадобилось функции <code>take</code>.</p>
<p>Функция <code>replicate</code> - лентяйка. Несмотря на то, что мы попросили её создать список из 100 строк, она смотрит по сторонам и думает: &quot;Так-с, кому тут нужны мои строки? Ага, функции <code>take</code> нужны. И сколько же ей нужно? А-а, всего две. Ну так а чего я, глупая что ли, создавать сто строк, когда требуется всего две?! Вот тебе две строки и будь счастлива!&quot;</p>
<p>Да, трудолюбие - это хорошо, а лень - это плохо, однако в данном случае мне более симпатична функция-лентяйка. Она, как хороший рационализатор, делает не столько, сколько её попросили, а столько, сколько реально нужно. В этом и заключается суть ленивых вычислений в Haskell.</p>
<p>Разумеется, если аппетиты функции <code>take</code> возрастут и она попросит первые пятьдесят элементов вместо первых двух, то функция <code>replicate</code> создаст список уже из 50 строк. Столько, сколько нужно, и ни капли больше.</p>
<p>Да, но откуда мы можем знать, что функция <code>replicate</code>  создаёт лишь столько IP-адресов, сколько потребовалось? А вдруг это не так? Давайте проверим.</p>
<p>Ленивость языка Haskell позволяет нам оперировать бесконечно большими списками. Нет, не просто очень большими, но именно бесконечными. Перепишем наш пример следующим образом:</p>
<pre><code class="lang-haskell"><span class="hljs-title">main</span> = print (take <span class="hljs-number">2</span> (repeat <span class="hljs-string">"127.0.0.1"</span>))
</code></pre>
<p>Функция <code>repeat</code> создаст бесконечно большой список IP-адресов, элементами которого будет переданный ей адрес <code>127.0.0.1</code>. И вот если бы наша трудолюбивая функция <code>generate_addresses</code> из C++ захотела стать похожей на свою ленивую коллегу, ей пришлось бы стать примерно такой:</p>
<pre><code class="lang-cpp">IPAddresses generate_addresses( size_t howMany,
                                <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; address ) {
    IPAddresses addresses;
    <span class="hljs-keyword">for</span>(;;) {
        addresses.push_back( address );
    }

    <span class="hljs-keyword">return</span> addresses;
}
</code></pre>
<p>И всё бы хорошо, но это намертво зависнет. И причиной тому служит уже известное нам трудолюбие функции <code>generate_addresses</code>. Сказали ей создать бесконечно большой список - будет создавать до последнего вздоха, ведь цикл <code>for</code> в данном случае не имеет выхода.</p>
<p>Однако если мы соберём наш Haskell-проект и запустим его, то не будет никакого зависания, и на экран вновь выведутся уже знакомые нам два адреса. А всё потому, что функция <code>repeat</code> столь же ленива и рациональна, как и её коллега <code>replicate</code>. Да, мы попросили её создать бесконечно большой список, однако на деле она создаст список вовсе не бесконечно большой, а настолько большой, насколько потребуется. И если в данном случае потребовался список только из двух строк - получите список из двух строк. Конечно, если бы потребовался список из миллиона строк - извольте, будет вам миллион.</p>
<p>Вот суть ленивых вычислений в Haskell: не важно, сколько приказали сделать, ведь в конечном итоге будет сделано ровно столько, сколько реально понадобится.</p>

                            
                        
                    </article>
                
            
        </section>
        
    
        
        <section>
            <article id="about-functions/README.md" class="new-chapter">
                <h1>О функциях</h1>
            </article>

            
                
                    <article id="about-functions/pure-functions.md">
                    
                            
                                <h2 id="-">Чистые функции</h2>
<p>Раз уж Haskell - чисто функциональный язык программирования, поговорим о чистых функциях, как об одном из краеугольных камней этого языка.</p>
<p>Для начала вспомним школьный курс математики и сформулируем простейшее определение функции:</p>
<blockquote>
<p><strong>Функция - это описание зависимости чего-то от чего-то.</strong></p>
</blockquote>
<p>Так вот чистые функции в Haskell - это и есть функции в математическом смысле. Они представляют собой описание того, как входное значение определяет выходное значение.</p>
<p>Отсюда вытекает важнейшая характеристика чистых функций, а именно отсутствие побочных эффектов. Значение на входе чистой функции всецело и полностью определяет значение на выходе. Поэтому если мы миллион раз подадим на вход одно и то же значение, то на выходе мы миллион раз гарантированно получим один и тот же результат.</p>
<h3 id="-">Объявляем</h3>
<p>Как и во многих других языках программирования, функцию сначала нужно объявить. Сделаем же это:</p>
<pre><code class="lang-haskell"><span class="hljs-title">simpleSum</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span>
</code></pre>
<p>До символа <code>::</code> указывается имя функции, а после - тип.</p>
<pre><code>simpleSum :: <span class="hljs-built_in">Int</span> -&gt; <span class="hljs-built_in">Int</span>
|       |    |        |
   имя          тип 
</code></pre><p>Я понимаю, словосочетание &quot;тип функции&quot; звучит странно, но в мире Haskell так: чистая функция - это значение, имеющее тип функции. Рассмотрим описание этого типа:</p>
<pre><code class="lang-haskell"><span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span>
</code></pre>
<p>Обратите внимание на стрелочку. Именно эта стрелочка и говорит нам о том, что перед нами - чистая функция. Слева от неё указан тип единственного аргумента (в данном случае это стандартный тип <code>Int</code>), а справа от неё - тип выходного значения (тот же <code>Int</code>). Саму же стрелочку можно воспринимать как ментальное указание на поток информации, движущийся через функцию: от её входа к выходу, слева направо.</p>
<p>Напоминаю, что чистая функция обязана иметь хотя бы один аргумент и обязана что-то возвращать, ведь это и отражает суть математической функции: что-то обязательно подаём на вход и что-то обязательно получаем на выходе.</p>
<p>Кстати, о количестве аргументов. Разумеется, чистая функция может принимать и несколько аргументов. Вот тип функции, принимающей три аргумента:</p>
<pre><code class="lang-haskell"><span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span>
</code></pre>
<p>Читать эту запись следует так: ищем последнюю по счёту (самую правую) стрелочку - она-то и будет тем самым разделителем: слева от неё идёт список типов аргументов, справа - тип возвращаемого выражения:</p>
<pre><code><span class="hljs-built_in">Int</span> -&gt; <span class="hljs-built_in">Int</span> -&gt; <span class="hljs-built_in">Int</span> -&gt; <span class="hljs-built_in">Int</span>
типы аргументов  |  |тип возвращаемого значения
</code></pre><h3 id="-">Определяем</h3>
<p>Теперь функцию необходимо определить. Кстати, определить нужно обязательно. Например, в языке C или C++ мы можем спокойно объявить функцию и не определять её (при условии, что она никогда не вызывается). В Haskell более строгий подход: если объявил функцию - будь добр и определить её, в противном случае компилятор выскажет своё категорическое недовольство.</p>
<p>Поэтому сразу же после объявления пишем определение:</p>
<pre><code class="lang-haskell"><span class="hljs-title">simpleSum</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span>
<span class="hljs-title">simpleSum</span> value = value + value
</code></pre>
<p>Здесь ментальным разделителем является знак равенства. Скелет данного выражения можно представить так:</p>
<pre><code><span class="hljs-attribute">NAME ARGUMENTS </span>=<span class="hljs-string"> BODY_EXPRESSION </span>
</code></pre><p>где <code>NAME</code> - имя функции, <code>ARGUMENTS</code> - список имён аргументов (имён, а не типов), а <code>BODY_EXPRESSION</code> - тело функции. В данном случае у нас имеется один-единственный аргумент по имени <code>value</code>, а также имеется простое тело, в котором мы просто складываем аргумент с самим собой.</p>
<h3 id="-">Вызываем</h3>
<p>Теперь нашу функцию можно вызывать. Сделаем же это с аргументом <code>4</code>, или, как принято говорить в мире ФП, применим нашу функцию к аргументу <code>4</code>:</p>
<pre><code class="lang-haskell"><span class="hljs-title">main</span> = putStrLn (show (simpleSum <span class="hljs-number">4</span>))
</code></pre>
<p>Стандартная функция <code>putStrLn</code> выводит строку на экран с завершающим <code>\n</code>. Результат выполнения этого кода вполне ожидаем:</p>
<pre><code class="lang-bash"><span class="hljs-number">8</span>
</code></pre>
<p>Готово. А теперь необходимо уточнить некоторые важные детали.</p>
<h3 id="-">Выход из функции</h3>
<p>В языке C, если у нас есть функция с возвращаемым значением, мы обязаны где-то в её теле указать точку выхода с помощью инструкции return. Кроме того, точек выхода может быть несколько.</p>
<p>В Haskell всё обстоит совершенно иначе. Во-первых, точка выхода из чистой функции может быть только одна, а во-вторых, аналога инструкции <code>return</code> в Haskell нет. И если мы вспомним математическую природу чистой функции, то поймём, что иначе и быть не может. Ведь чистая функция представляет собой описание зависимости выходного значения от входных значений, поэтому её тело представляет собой совокупность выражений, которые вычисляются и в конечном итоге оставляют одно-единственное, последнее выражение. Так вот это последнее выражение и будет являться &quot;точкой выхода&quot; из функции.</p>
<p>Приведу пример:</p>
<pre><code class="lang-haskell"><span class="hljs-title">indicate</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">String</span>
<span class="hljs-title">indicate</span> address =
    <span class="hljs-keyword">if</span> address == <span class="hljs-string">"127.0.0.1"</span> <span class="hljs-keyword">then</span> <span class="hljs-string">"localhost"</span> <span class="hljs-keyword">else</span> address
</code></pre>
<p>Эта функция принимает единственный аргумент стандартного типа <code>String</code>, соответствующий некоторому IP-адресу. В теле функции происходит проверка аргумента на равенство адресу <code>127.0.0.1</code>, в результате чего мы окажемся в одной из двух логических ветвей. В C++ это выглядело бы так:</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> indicate( <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; address ) {
    <span class="hljs-keyword">if</span>( address == <span class="hljs-string">"127.0.0.1"</span> ) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"localhost"</span>;
    }

    <span class="hljs-keyword">return</span> address;
}
</code></pre>
<p>Мы явно указали две точки выхода из функции. Но в Haskell этого делать не нужно, потому что когда мы окажемся в одной из двух логических ветвей, то выражение, на котором мы окажемся, и будет возвращено.</p>
<p>Чтобы стало понятнее, перепишем тело этой функции так, чтобы избавиться от выражения <code>if-then-else</code>:</p>
<pre><code class="lang-haskell"><span class="hljs-title">indicate</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">String</span>
<span class="hljs-title">indicate</span> <span class="hljs-string">"127.0.0.1"</span> = <span class="hljs-string">"localhost"</span>
<span class="hljs-title">indicate</span> address = address
</code></pre>
<p>Haskell позволяет вводить несколько определений для одной функции. Рассматривайте это как особый вариант перегрузки. Здесь мы говорим: &quot;Если входной аргумент будет равен &#39;127.0.0.1&#39;, пусть будет использовано тело №1, в противном случае пусть будет использовано тело №2&quot;. Следовательно, когда компилятор увидит вызов этой функции в коде, он просто подставит на место этого вызова соответствующее выражение: либо строку &quot;localhost&quot;, в случае использования первого тела, либо фактически переданный аргумент, в случае использования второго тела.</p>
<p>Теперь всё встало на свои места: явно определять точку выхода из чистой функции не нужно потому, что конечное выражение в теле этой функции просто заменит собою вызов функции. То есть если написано так:</p>
<pre><code class="lang-haskell"><span class="hljs-title">main</span> = putStrLn (indicate <span class="hljs-string">"127.0.0.1"</span>)
</code></pre>
<p>это то же самое, как если бы было написано просто:</p>
<pre><code class="lang-haskell"><span class="hljs-title">main</span> = putStrLn <span class="hljs-string">"localhost"</span>
</code></pre>
<p>Это - важное свойство чистых функций: мы всегда можем безопасно заменить места их вызова соответствующими возвращённым значениями, и работа приложения при этом останется неизменной. Именно поэтому работать с чистой функцией легко.</p>
<h3 id="-">Охрана</h3>
<p>Существует ещё один способ задать выбор внутри функции без использования <code>if-then-else</code>. Называется он охрана (guard), хотя можно перевести и как &quot;защита&quot; или &quot;стража&quot;. Перепишем нашу функцию:</p>
<pre><code class="lang-haskell"><span class="hljs-title">indicate</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">String</span>
<span class="hljs-title">indicate</span> address
    | address == <span class="hljs-string">"127.0.0.1"</span> = <span class="hljs-string">"localhost"</span>
    | null address = <span class="hljs-string">"empty IP-address"</span>
    | otherwise = address
</code></pre>
<p>Символ <code>|</code> отражает выбор, как если бы мы написали вместо него слово &quot;либо&quot;. После него идёт логическое условие и соответствующее ему итоговое значение функции:</p>
<pre><code class="lang-haskell">    ...
    | address == <span class="hljs-string">"127.0.0.1"</span> = <span class="hljs-string">"localhost"</span>
    | null address           = <span class="hljs-string">"empty IP-address"</span>
    ...
      <span class="hljs-comment">-- логическое условие  = итоговое значение</span>
</code></pre>
<p>Кстати, ветку <code>otherwise</code> необходимо использовать всегда. Если вы её пропустите, код пройдёт компиляцию, однако в вашем коде поселится коварная ошибка. В частности, если вы напишете так:</p>
<pre><code class="lang-haskell"><span class="hljs-title">indicate</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">String</span>
<span class="hljs-title">indicate</span> address
    | address == <span class="hljs-string">"127.0.0.1"</span> = <span class="hljs-string">"localhost"</span>
    | null address = <span class="hljs-string">"empty IP-address"</span>
</code></pre>
<p>а потом примените эту функцию к непустой строке, отличающейся от &quot;127.0.0.1&quot;, вы получите ошибку времени выполнения:</p>
<pre><code class="lang-bash">Real: src/Main.hs:(<span class="hljs-number">23</span>,<span class="hljs-number">1</span>)-(<span class="hljs-number">25</span>,<span class="hljs-number">36</span>): Non-exhaustive patterns <span class="hljs-keyword">in</span> function indicate
</code></pre>
<p>Будьте внимательны.</p>
<h3 id="-">Локальные выражения</h3>
<p>Локальное выражение в теле функции - штука очень полезная, спасающая нас от магических чисел и от дубляжа.</p>
<p>Например, у нас есть такая функция:</p>
<pre><code class="lang-haskell"><span class="hljs-title">prepareLength</span> :: <span class="hljs-type">Double</span> -&gt; <span class="hljs-type">Double</span>
<span class="hljs-title">prepareLength</span> line = line * <span class="hljs-number">0.4959</span>
</code></pre>
<p>Здесь мы готовим длину некой линии путём умножения её первоначальной длины на заданный поправочный коэффициент. Но перед нами - классическое магическое число, смысл которого непонятен, и это плохо. Добавлять комментарий - не самое лучшее решение. Поэтому добавим локальное поясняющее выражение:</p>
<pre><code class="lang-haskell"><span class="hljs-title">prepareLength</span> :: <span class="hljs-type">Double</span> -&gt; <span class="hljs-type">Double</span>
<span class="hljs-title">prepareLength</span> line =
    line * coefficient
    <span class="hljs-keyword">where</span> coefficient = <span class="hljs-number">0.4959</span>
</code></pre>
<p>Ключевое слово <code>where</code> вводит выражение, которое можно использовать в теле функции. Рассматривайте его как псевдоним: идентификатор <code>coefficient</code> теперь можно использовать как аналог числового значения <code>0.4959</code>.</p>
<p>Локальных выражений может быть и несколько:</p>
<pre><code class="lang-haskell">...
    line * coefficient - correction
    <span class="hljs-keyword">where</span> coefficient = <span class="hljs-number">0.4959</span>
          correction = <span class="hljs-number">0.0012</span>
</code></pre>
<p>Есть ещё один способ ввести локальное вспомогательное выражение, а именно с помощью ключевого слова <code>let</code>. На примере нашей последней функции это будет выглядеть так:</p>
<pre><code class="lang-haskell"><span class="hljs-title">prepareLength</span> :: <span class="hljs-type">Double</span> -&gt; <span class="hljs-type">Double</span>
<span class="hljs-title">prepareLength</span> line =
    <span class="hljs-keyword">let</span> coefficient = <span class="hljs-number">12.4959</span>
        correction = <span class="hljs-number">0.0012</span>
    <span class="hljs-keyword">in</span>
    line * coefficient - correction
</code></pre>
<p>Общая модель такая:</p>
<pre><code><span class="hljs-built_in">let</span> bindings <span class="hljs-keyword">in</span> expression,
</code></pre><p>где <code>bindings</code> - локальные выражения, а <code>expression</code> - то место, где мы собираемся использовать эти локальные выражения.</p>
<p>Вы спросите, в чём же разница между <code>where</code> и <code>let</code>?</p>
<p>Во-первых, выражение <code>where</code> может быть только одно и только в конце тела функции, в то время как выражение <code>let</code> может присутствовать многократно и в любой части тела функции.</p>
<p>Во-вторых, выражение, введённое ключевым словом <code>where</code>, видимо в любой точке тела функции, в то время как выражение, введённое ключевым словом <code>let</code>, может быть &quot;супер-локальным&quot;. Например:</p>
<pre><code class="lang-haskell">...
    <span class="hljs-keyword">let</span> coefficient = <span class="hljs-number">12.4959</span>
        correction = <span class="hljs-number">0.0012</span>
    <span class="hljs-keyword">in</span>
    line * coefficient - correction - (<span class="hljs-keyword">let</span> s = <span class="hljs-number">10.9</span> <span class="hljs-keyword">in</span> s + <span class="hljs-number">1</span>) - s
</code></pre>
<p>Здесь мы ввели &quot;супер-локальное&quot; выражение с именем <code>s</code>, которое существует только внутри круглых скобок. Именно поэтому этот код не пройдёт компиляцию, ведь второе выражение <code>s</code> находится уже за пределами круглых скобок.</p>
<h3 id="-">Без объявления</h3>
<p>Как вы помните, нельзя объявить функцию и при этом не определить её. А можно ли определить функцию без объявления? Ответ: можно. Однако важно помнить, что общепринятой практикой является объявлять функцию и тут же определять её. Да, мы можем написать так:</p>
<pre><code class="lang-haskell"><span class="hljs-comment">-- Объявления нет, сразу определение</span>
<span class="hljs-title">prepareLength</span> line =
    ...
</code></pre>
<p>однако для сложных функций делать так крайне не рекомендуется, поскольку определение становится беднее, ведь описание типов аргументов и возвращаемого значения помогает лучше понять работу функции. Кроме того, если вы не укажете эти типы, они станут полиморфными, но об этом мы поговорим позже.</p>
<p>Впрочем, если речь идёт о действительно тривиальных функциях, состоящих из одной-двух строк, говорящих сами за себя, тогда указание типов аргументов и возвращаемого значения будет выглядеть избыточным. В этом случае опускайте их.</p>
<p>Вот и всё, теперь вы знаете о чистых функциях. Кстати, они нам очень пригодятся - в последующих главах мы к ним вернёмся не раз.</p>

                            
                        
                    </article>
                
            
                
                    <article id="about-functions/lambda-functions.md">
                    
                            
                                <h2 id="-">λ-функции</h2>
<p>Теперь мы должны познакомится с любопытной и важной концепцией, а именно с λ-функциями (лямбда-функциями).</p>
<p>Вспомним упомянутое в предыдущей главе определение математической функции:</p>
<blockquote>
<p><strong>Функция - это описание зависимости чего-то от чего-то.</strong> </p>
</blockquote>
<p>Однако в языке C (и подобных ему языках) функция никогда не ассоциировалась с таким определением. Напротив, функция там есть ни что иное, как подпрограмма, а имя функции есть ни что иное, как указатель на первую инструкцию этой подпрограммы.</p>
<p>Кроме того, функция в языке C является глобальной в рамках текущей единицы трансляции. И поэтому вызов функции - это своего рода глобальный <code>goto</code> в её тело, с последующим возвратом из него. Именно поэтому функция в языке C не может быть безымянной, потому что иначе её невозможно было бы вызвать.</p>
<p>λ-функция - совсем другой зверь.</p>
<h3 id="-">Что это такое</h3>
<p>В основе λ-функций лежит λ-исчисление, названное так по имени красивой греческой буквы. У λ-исчисления довольно-таки долгая академическая история, но нас с вами интересует практическая сторона, поэтому сразу приведу пример.</p>
<p>Допустим, нам нужна функция, принимающая некое целочисленное значение и возвращающая квадрат этого значения. Такую функцию мы можем описать так:</p>
<pre><code><span class="hljs-number">5</span> -&gt; f -&gt; <span class="hljs-number">25</span> 
</code></pre><p>Проще некуда: на входе - <code>5</code>, на выходе - <code>25</code>. Внутренности этой функции можно описать так:</p>
<pre><code><span class="hljs-number">5</span><span class="hljs-function"> -&gt;</span> <span class="hljs-function"><span class="hljs-params">(x * x)</span> -&gt;</span> <span class="hljs-number">25</span>
</code></pre><p>А теперь главный вопрос: как такую функцию описать формально? Вот тут-то на сцену и выходит λ-исчисление, ибо оно как раз и предлагает формализованный способ записи функции. Для нашей функции эта запись будет такой:</p>
<pre><code>λ<span class="hljs-built_in">x</span><span class="hljs-preprocessor">.x</span> * <span class="hljs-built_in">x</span> 
</code></pre><p>Буква λ - это признак λ-функции. А читать это выражение следует так: &quot;λ-функция (от) одного аргумента x, возвращающая результат умножения этого аргумента на самого себя&quot;.</p>
<p>Разделителем здесь является точка. Выражение слева от этой точки - список аргументов (в данном случае он один), а выражение справа от неё - тело функции.</p>
<p>Простое и элегантное описание, ничего лишнего. Нет даже имени. Особенностью λ-функции является её безымянность, ведь имя ей не нужно. И это принципиально отличает её от &quot;обыкновенной&quot; функции.</p>
<h3 id="-">Как это выглядит в коде</h3>
<p>λ-функции присутствуют во многих языках, но в Haskell вид λ-выражения максимально приближен к математическому. Сравните:</p>
<pre><code>λx .  x * x  <span class="hljs-comment">-- Математическая форма</span>
\x -&gt; x * x  <span class="hljs-comment">-- Haskell-форма</span>
</code></pre><p>Прямое сходство. Даже <code>\</code> вначале подходит как нельзя лучше: рассматривайте его как &quot;спинку&quot; буквы λ. Единственное отличие - замена точки стрелочкой.</p>
<p>А теперь возникает резонный вопрос: как мы можем вызвать такую функцию? Вероятно, ответ удивит вас, но λ-функции, строго говоря, не вызывают. Впрочем, это лишь игра слов. Вернёмся на минутку в математику.</p>
<p>Идея λ-функции базируется на математическом принципе &quot;аппликации&quot; (application), или &quot;применения&quot;. λ-функцию не вызывают с аргументом, а применяют (апплицируют) её к аргументу. Поэтому запись вида:</p>
<pre><code>f <span class="hljs-operator">a</span> 
</code></pre><p>принято читать так: &quot;Применение функции <code>f</code> к аргументу <code>a</code>&quot;.</p>
<p>Вот как это выглядит в Haskell:</p>
<pre><code class="lang-haskell">(\x -&gt; x * x) <span class="hljs-number">5</span>
</code></pre>
<p>λ-выражение, находящееся в скобках, порождает λ-функцию, которая сразу же применяется к аргументу <code>5</code>.</p>
<h3 id="-">Множество аргументов</h3>
<p>λ-функция может применяться и к нескольким аргументам. Вот функция, возвращающая результат умножения первого значения на второе:</p>
<pre><code class="lang-haskell"><span class="hljs-title">main</span> =
    print (f <span class="hljs-number">5</span> <span class="hljs-number">6</span>)
    <span class="hljs-keyword">where</span> f = \arg1 arg2 -&gt; arg1 * arg2
</code></pre>
<p>Между <code>\</code> и стрелочкой идёт список имён аргументов функции.</p>
<h3 id="-">Какая от них польза</h3>
<p>В языке C принята стандартная последовательность из трёх шагов при работе с функцией:</p>
<ol>
<li>объявление,</li>
<li>определение,</li>
<li>вызов.</li>
</ol>
<p>Например:</p>
<pre><code class="lang-c"><span class="hljs-keyword">int</span> sq( <span class="hljs-keyword">int</span> i ) {
    <span class="hljs-keyword">return</span> i * i;
}

<span class="hljs-keyword">int</span> main() {
    <span class="hljs-built_in">printf</span>( <span class="hljs-string">"%d"</span>, sq( <span class="hljs-number">5</span> ) );
}
</code></pre>
<p>Мы готовим нашу &quot;глобальную подпрограмму&quot;, а потом заходим в неё через вызов.</p>
<p>А вот как это выглядит в Haskell:</p>
<pre><code class="lang-haskell"><span class="hljs-title">main</span> = print ((\x -&gt; x * x) <span class="hljs-number">5</span>)
</code></pre>
<p>Мы ничего не готовим заранее. Напротив, мы создаём функцию как значение, локально и непосредственно перед использованием. Создаём - и тут же применяем её к аргументу <code>5</code>.</p>
<p>Для простоты мы можем ввести пояснительное выражение для нашей функции:</p>
<pre><code class="lang-haskell"><span class="hljs-title">main</span> =
    print (f <span class="hljs-number">5</span>)
    <span class="hljs-keyword">where</span> f = \x -&gt; x * x
</code></pre>
<p>Одно из преимуществ λ-функции как раз и заключается в её локальности. Зачем нам заранее объявлять и определять функцию, если мы можем создать и сразу использовать её непосредственно в том месте, где она нужна? Впрочем, если λ-функция используется в нескольких местах, мы можем, во избежание дубляжа, определить её глобально, связав с некоторым именем. Например:</p>
<pre><code class="lang-haskell"><span class="hljs-title">f</span> = \x -&gt; x * x

<span class="hljs-title">main</span> = print ((f <span class="hljs-number">5</span>) + (f <span class="hljs-number">6</span>))
</code></pre>
<p>Выражение <code>f</code> равно нашей λ-функции, и теперь мы можем многократно применять это выражение к различным аргументам.</p>
<p>Готово. Теперь вы знаете, что такое λ-функции. Однако самое интересное их применение связано с функциями высшего порядка, о которых мы поговорим прямо сейчас.</p>

                            
                        
                    </article>
                
            
                
                    <article id="about-functions/higher-order-functions.md">
                    
                            
                                <h2 id="-">Функции высшего порядка</h2>
<p>Функции высшего порядка (higher-order functions) занимают важное место в языке Haskell. Из предыдущих глав вы узнали, что чистые функции - это, в конечном итоге, значения. Следовательно, чистые функции можно, во-первых, передавать другим функциям в качестве аргументов, а во-вторых, возвращать их из других функций.</p>
<p>Функцией высшего порядка называют такую функцию, которая принимает другую функцию в качестве аргумента и/или возвращает другую функцию.</p>
<h3 id="-">Разоблачение функций</h3>
<p>Помните, в рассказе о чистых функциях было упомянуто, что они могут принимать как один, так и множество аргументов? Пришло время признаться в обмане, ибо правда такова:</p>
<blockquote>
<p><strong>Чистые функции в Haskell всегда принимают только один аргумент.</strong> </p>
</blockquote>
<p>Постойте, но как же мы тогда смогли определить функции, принимающие по два и даже по три аргумента?</p>
<p>Это была хитрость, и называется она &quot;каррирование&quot; (currying), иногда говорят &quot;карринг&quot;. Слово это знаменитое, ибо происходит от имени <a href="https://en.wikipedia.org/wiki/Haskell_Curry" target="_blank">Haskell Curry</a>. Каррирование - это превращение функции, принимающей множество аргументов, в функцию, принимающую все эти аргументы по одному.</p>
<p>Определим функцию деления двух чисел:</p>
<pre><code class="lang-haskell"><span class="hljs-title">divide</span> :: <span class="hljs-type">Double</span> -&gt; <span class="hljs-type">Double</span> -&gt; <span class="hljs-type">Double</span>
<span class="hljs-title">divide</span> arg1 arg2 = arg1 / arg2
</code></pre>
<p>Функция принимает два значения стандартного типа <code>Double</code> и возвращает результат деления первого значения на второе. Всё предельно просто. Но если мы заглянем &quot;под капот&quot; вызова этой функции:</p>
<pre><code class="lang-haskell"><span class="hljs-title">main</span> = print (divide <span class="hljs-number">10.03</span> <span class="hljs-number">2.1</span>)
</code></pre>
<p>то узнаем, что этот вызов происходит в два этапа:</p>
<ol>
<li>Функция <code>divide</code> применяется к первому аргументу <code>10.03</code> и - внимание! - возвращает функцию типа <code>Double -&gt; Double</code>.</li>
<li>Эта возвращённая функция, в свою очередь, применяется ко второму аргументу <code>2.1</code> и возвращает конечное значение <code>4.77</code>.</li>
</ol>
<p>Мы можем явно отразить эту &quot;двухэтапность&quot;, переписав вызов функции так:</p>
<pre><code class="lang-haskell">(divide <span class="hljs-number">10.03</span>) <span class="hljs-number">2.1</span>
</code></pre>
<p>Функция применяется только к одному значению: сначала к <code>10.03</code>, а уже потом функция, возвращённая первым вызовом, применяется к <code>2.1</code>. Именно по причине такой &quot;двухэтапности&quot; объявление функции <code>divide</code> содержит две стрелочки вместо одной:</p>
<pre><code class="lang-haskell"><span class="hljs-title">divide</span> :: <span class="hljs-type">Double</span> -&gt; <span class="hljs-type">Double</span> -&gt; <span class="hljs-type">Double</span>
</code></pre>
<p>С концептуальной точки зрения такое объявление звучит так: &quot;Функция <code>divide</code> принимает два значения типа <code>Double</code> и возвращает значение типа <code>Double</code>&quot;. Однако правильнее читать его так: &quot;Функция <code>divide</code> применяется к первому значению типа <code>Double</code> и возвращает функцию типа <code>Double -&gt; Double</code>, которая применяется ко второму значению типа <code>Double</code> и возвращает конечное значение типа <code>Double</code>&quot;. Кстати, правильное прочтение объявления можно отразить и в самом этом объявлении:</p>
<pre><code class="lang-haskell"><span class="hljs-title">divide</span> :: <span class="hljs-type">Double</span> -&gt; (<span class="hljs-type">Double</span> -&gt; <span class="hljs-type">Double</span>)
</code></pre>
<p>Теперь мы ясно видим, что на первом этапе происходит вызов функции от одного аргумента, возвращающей функцию типа <code>Double -&gt; Double</code>, а на втором этапе происходит вызов второй функции, возвращённой на первом этапе.</p>
<p>По аналогии, если у нас есть функция, принимающая три аргумента:</p>
<pre><code class="lang-haskell"><span class="hljs-title">totalSum</span> :: <span class="hljs-type">Double</span> -&gt; <span class="hljs-type">Double</span> -&gt; <span class="hljs-type">Double</span> -&gt; <span class="hljs-type">Double</span>
<span class="hljs-title">totalSum</span> arg1 arg2 arg3 = arg1 + arg2 + arg3
</code></pre>
<p>то её вызов:</p>
<pre><code class="lang-haskell"><span class="hljs-title">main</span> = print (totalSum <span class="hljs-number">10.03</span> <span class="hljs-number">2.1</span> <span class="hljs-number">45.7</span>)
</code></pre>
<p>проходил бы в три этапа, и чтобы явно отразить этот факт, мы можем переписать объявление данной функции так:</p>
<pre><code class="lang-haskell"><span class="hljs-title">totalSum</span> :: <span class="hljs-type">Double</span> -&gt; (<span class="hljs-type">Double</span> -&gt; (<span class="hljs-type">Double</span> -&gt; <span class="hljs-type">Double</span>))
</code></pre>
<p>а её вызов - так:</p>
<pre><code><span class="hljs-list">(<span class="hljs-list">(<span class="hljs-title">totalSum</span> <span class="hljs-number">10.03</span>)</span> <span class="hljs-number">2.1</span>)</span> <span class="hljs-number">45.7</span>
</code></pre><p>И чтобы всё окончательно прояснилось, изучим одну важную деталь.</p>
<h3 id="-">Частичное применение функции</h3>
<p>Несмотря на &quot;двухэтапность&quot; вызова функции <code>divide</code>, её тело будет выполнено один раз. Вызов один, просто он разделён на два последовательных шага. А чтобы понять суть этих шагов, изучим частичное применение функции (partial application).</p>
<p>Функцию называют частично применённой, если количество аргументов, к которым она применена, оказалось меньше ожидаемого ею количества аргументов. И здесь нам пригодятся уже известные нам λ-функции.</p>
<p>Применим функцию <code>divide</code> не к двум, а только к одному аргументу:</p>
<pre><code class="lang-haskell"><span class="hljs-title">main</span> =
    <span class="hljs-keyword">let</span> temporaryFunction = divide <span class="hljs-number">10.03</span>  <span class="hljs-comment">-- "Запомнили" первое значение...</span>
    <span class="hljs-keyword">in</span>
    print (temporaryFunction <span class="hljs-number">2.1</span>)   <span class="hljs-comment">-- А вот теперь можем выполнить работу.</span>
</code></pre>
<p>Теперь всё встало на свои места. Здесь наглядно показано, что же на самом деле означает выражение вида:</p>
<pre><code class="lang-haskell">(divide <span class="hljs-number">10.03</span>) <span class="hljs-number">2.1</span>
</code></pre>
<p>В результате первого вызова, когда мы применили функцию <code>divide</code> к первому аргументу, мы ещё не можем получить результат деления, ведь второго-то аргумента ещё нет! Вместо этого мы получили временную λ-функцию, которую для наглядности ассоциировали с выражением <code>temporaryFunction</code>. Эта временная λ-функция как бы запомнила значение первого аргумента, и только когда мы применим её ко второму аргументу, мы и получим результат деления.</p>
<p>По аналогии, вызов нашей функции <code>totalSum</code>, происходящий в три этапа, можно разложить так:</p>
<pre><code class="lang-haskell"><span class="hljs-title">main</span> =
    <span class="hljs-keyword">let</span> firstFunction = totalSum <span class="hljs-number">1.0</span>       <span class="hljs-comment">-- "Запомнили" первый...</span>
        secondFunction = firstFunction <span class="hljs-number">2.0</span> <span class="hljs-comment">-- "Запомнили" второй...</span>
    <span class="hljs-keyword">in</span>
    print (secondFunction <span class="hljs-number">3.0</span>)    <span class="hljs-comment">-- А вот теперь можем складывать.</span>
</code></pre>
<p>В процессе вызова у нас появилось уже две временные λ-функции, каждая из которых применялась к очередному аргументу и запоминала его. И только когда вторая промежуточная λ-функция была применена к третьему, последнему аргументу, мы и получили сумму.</p>
<h3 id="-">Зачем это нужно</h3>
<p>В подавляющем большинстве случаев знать вышеизложенную информацию о каррировании функций и о частичном применении не обязательно. Основное преимущество каррирования лежит в академической плоскости: выводить математические доказательства гораздо легче, если договориться, что каждая из вычисляемых функций всегда принимает строго один аргумент и возвращает строго одно значение. Но нас с вами больше интересует аспект практический. И поэтому мы возвращаемся к рассмотрению функций высшего порядка (далее - ФВП).</p>
<p>Формально функции <code>divide</code> и <code>totalSum</code> являются ФВП, в силу тех самых промежуточных λ-функций. Фактически, все функции, принимающие более одного аргумента, являются ФВП. Но все эти промежуточные λ-функции - всего лишь &quot;подкапотные&quot; дела, они скрыты от наших глаз. Гораздо больший интерес для нас представляют &quot;настоящие&quot; ФВП, которые явно объявлены как принимающие на вход функциональные значения и/или возвращающие функциональные значения.</p>
<p>Рассмотрим небольшой пример:</p>
<pre><code class="lang-haskell"><span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">Login</span> = <span class="hljs-type">String</span></span>
<span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">Password</span> = <span class="hljs-type">String</span></span>
<span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">AvatarURL</span> = <span class="hljs-type">String</span></span>
<span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">UserId</span> = <span class="hljs-type">Integer</span></span>

<span class="hljs-title">userInfo</span> :: <span class="hljs-type">Login</span> -&gt; <span class="hljs-type">Password</span> -&gt; <span class="hljs-type">AvatarURL</span> -&gt; <span class="hljs-type">UserId</span> -&gt; <span class="hljs-type">String</span>
<span class="hljs-title">userInfo</span> login password avatarURL userId =
    <span class="hljs-string">"Full info about user @"</span> ++ (show userId) ++ <span class="hljs-string">":"</span> ++
    <span class="hljs-string">"\n login: "</span> ++ login ++
    <span class="hljs-string">"\n password: "</span> ++ password ++
    <span class="hljs-string">"\n avatar URL: "</span> ++ avatarURL

<span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">EmptyInfo</span> = <span class="hljs-type">Login</span> -&gt; <span class="hljs-type">Password</span> -&gt; <span class="hljs-type">AvatarURL</span> -&gt; <span class="hljs-type">UserId</span> -&gt; <span class="hljs-type">String</span></span>
<span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">WithLogin</span> =          <span class="hljs-type">Password</span> -&gt; <span class="hljs-type">AvatarURL</span> -&gt; <span class="hljs-type">UserId</span> -&gt; <span class="hljs-type">String</span></span>
<span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">AndWithPassword</span> =                <span class="hljs-type">AvatarURL</span> -&gt; <span class="hljs-type">UserId</span> -&gt; <span class="hljs-type">String</span></span>
<span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">AndWithAvatarURL</span> =                            <span class="hljs-type">UserId</span> -&gt; <span class="hljs-type">String</span></span>

<span class="hljs-title">storeLoginIn</span> :: <span class="hljs-type">EmptyInfo</span> -&gt; <span class="hljs-type">UserId</span> -&gt; <span class="hljs-type">WithLogin</span>
<span class="hljs-title">storeLoginIn</span> emptyInfo userId =
    emptyInfo <span class="hljs-string">"denis"</span>
    <span class="hljs-comment">{- В реальности логин будет получен
       в соответствии с переданным userId -}</span>

<span class="hljs-title">storePasswordIn</span> :: <span class="hljs-type">WithLogin</span> -&gt; <span class="hljs-type">UserId</span> -&gt; <span class="hljs-type">AndWithPassword</span>
<span class="hljs-title">storePasswordIn</span> infoWithLogin userId = infoWithLogin <span class="hljs-string">"123456789abc"</span>
    <span class="hljs-comment">{- В реальности пароль будет получен
       в соответствии с переданным userId -}</span>

<span class="hljs-title">storeAvatarURLIn</span> :: <span class="hljs-type">AndWithPassword</span> -&gt; <span class="hljs-type">UserId</span> -&gt; <span class="hljs-type">AndWithAvatarURL</span>
<span class="hljs-title">storeAvatarURLIn</span> infoWithPassword userId =
    infoWithPassword <span class="hljs-string">"http://dshevchenko.biz/denis_avatar.png"</span>
    <span class="hljs-comment">{- В реальности URL будет получен
       в соответствии с переданным userId -}</span>

<span class="hljs-title">main</span> =
    <span class="hljs-keyword">let</span> userId = <span class="hljs-number">1234</span>
        infoWithLogin = storeLoginIn userInfo userId
        infoWithPassword = storePasswordIn infoWithLogin userId
        infoWithAvatarURL = storeAvatarURLIn infoWithPassword userId
        fullInfoAboutUser = infoWithAvatarURL userId
    <span class="hljs-keyword">in</span>
    putStrLn fullInfoAboutUser
</code></pre>
<p>А теперь разберём это хозяйство по косточкам.</p>
<p>Во-первых, появилась новая для нас конструкция:</p>
<pre><code class="lang-haskell"><span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">Login</span> = <span class="hljs-type">String</span></span>
</code></pre>
<p>Ключевое слово <code>type</code> добавляет псевдоним для уже известного типа, и теперь вместо типа <code>String</code> можно использовать идентификатор <code>Login</code>.</p>
<p>Далее мы определили функцию:</p>
<pre><code class="lang-haskell"><span class="hljs-title">userInfo</span> :: <span class="hljs-type">Login</span> -&gt; <span class="hljs-type">Password</span> -&gt; <span class="hljs-type">AvatarURL</span> -&gt; <span class="hljs-type">UserId</span> -&gt; <span class="hljs-type">String</span>
</code></pre>
<p>Тут всё просто: функция <code>userInfo</code> ожидает на вход логин, пароль, адрес аватара и идентификатор пользователя, а на выходе выдаёт некую описывающую строку. Обратите внимание и на двойной плюс:</p>
<pre><code class="lang-haskell"><span class="hljs-string">"\n login: "</span> ++ login
</code></pre>
<p>Это оператор конкатенации двух строк в одну.</p>
<p>А вот теперь начинается самое интересное. Подразумевается, что изначально у нас имеется только идентификатор пользователя, а соответствующие ему логин, пароль и путь к аватару нам нужно откуда-то получить. К счастью, у нас есть три функции, каждая из которых знает, где взять логин, пароль и путь к аватару соответственно. И каждая из этих трёх функций является ФВП.</p>
<p>Рассмотрим псевдонимы:</p>
<pre><code class="lang-haskell"><span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">EmptyInfo</span> = <span class="hljs-type">Login</span> -&gt; <span class="hljs-type">Password</span> -&gt; <span class="hljs-type">AvatarURL</span> -&gt; <span class="hljs-type">UserId</span> -&gt; <span class="hljs-type">String</span></span>
<span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">WithLogin</span> =          <span class="hljs-type">Password</span> -&gt; <span class="hljs-type">AvatarURL</span> -&gt; <span class="hljs-type">UserId</span> -&gt; <span class="hljs-type">String</span></span>
<span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">AndWithPassword</span> =                <span class="hljs-type">AvatarURL</span> -&gt; <span class="hljs-type">UserId</span> -&gt; <span class="hljs-type">String</span></span>
<span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">AndWithAvatarURL</span> =                            <span class="hljs-type">UserId</span> -&gt; <span class="hljs-type">String</span></span>
</code></pre>
<p>Каждый из них вводит упрощающее имя для функционального типа, образованного &quot;урезанием&quot; от типа функции <code>userInfo</code>. Обратите внимание: каждый последующий тип ожидает на один аргумент меньше, чем предыдущий тип. Эти псевдонимы задают типы для очередной промежуточной λ-функции, которые нужны, как вы уже догадались, для частичного применения функции <code>userInfo</code>.</p>
<p>Рассмотрим первый вызов:</p>
<pre><code class="lang-haskell"><span class="hljs-title">infoWithLogin</span> = storeLoginIn userInfo userId
</code></pre>
<p>Здесь мы передаём функцию <code>userInfo</code> в качестве первого аргумента функции <code>storeLoginIn</code>, внутри которой мы применяем переданную функцию <code>userInfo</code> к единственному аргументу, а именно к логину. Соответственно, на выходе из функции <code>storeLoginIn</code> мы получаем первую промежуточную λ-функцию, в которой мы сохранили значение логина (именно поэтому тип этой λ-функции ассоциирован со словом <code>WithLogin</code>).</p>
<p>Далее следует вызов:</p>
<pre><code class="lang-haskell"><span class="hljs-title">infoWithPassword</span> = storePasswordIn infoWithLogin userId
</code></pre>
<p>Здесь мы передаём нашу промежуточную λ-функцию в качестве первого аргумента функции <code>storePasswordIn</code>. Эта функция, в свою очередь, применяет переданную ей λ-функцию к единственному аргументу, а именно к паролю. Таким образом, на выходе из функции <code>storePasswordIn</code> мы имеем вторую промежуточную λ-функцию, в которой сохранены уже два значения: полученный на предыдущем вызове логин и на этом вызове - пароль.</p>
<p>То же самое справедливо и для следующего вызова:</p>
<pre><code class="lang-haskell"><span class="hljs-title">infoWithAvatarURL</span> = storeAvatarURLIn infoWithPassword userId
</code></pre>
<p>На выходе из функции <code>storeAvatarURLIn</code> мы получаем третью λ-функцию, в которой сохранены уже три значения: логин, пароль и путь к аватару.</p>
<p>В итоге мы применяем эту третью λ-функцию к последнему нужному аргументу, а именно к идентификатору пользователя:</p>
<pre><code class="lang-haskell"><span class="hljs-title">fullInfoAboutUser</span> = infoWithAvatarURL userId
</code></pre>
<p>Здесь-то и происходит &quot;полноценный&quot; вызов функции <code>userInfo</code>, в результате которого мы и получаем описывающую строку:</p>
<pre><code class="lang-bash">Full info about user @<span class="hljs-number">1234</span>:
 login: denis
 password: <span class="hljs-number">123456789</span>abc
 avatar URL: http://dshevchenko.biz/denis_avatar.png
</code></pre>
<p>Таким образом, функция <code>userInfo</code> была частично применена трижды, каждый раз получая очередной аргумент, и лишь к четвёртому применению она получила все необходимые ей аргументы. Это можно сравнить с конвейерной цепочкой, на каждом шаге которой эта функция получала очередной аргумент.</p>
<p>Впрочем, нужны ли были такие сложности? Ведь мы можем передавать в каждую из этих трёх функций только значение <code>userId</code>, а возвращать никакую не промежуточную λ-функцию, а непосредственно логин, пароль и адрес аватара соответственно. Например, вместо функции <code>storeLoginIn</code> можно определить функцию <code>obtainLogin</code> следующего вида:</p>
<pre><code class="lang-haskell"><span class="hljs-title">obtainLogin</span> :: <span class="hljs-type">UserId</span> -&gt; <span class="hljs-type">Login</span>
<span class="hljs-title">obtainLogin</span> userId =
    <span class="hljs-comment">-- Получаем откуда-то логин и просто возвращаем его.</span>
</code></pre>
<p>Ну а что если мы не хотим возвращать логин в явном виде? Ведь в случае с частичным применением мы упаковываем логин в промежуточную λ-функцию (то есть фактически прячем логин в неё), а в этом случае мы явно возвращаем его на показ всему миру. Первое решение может оказаться более приемлемым.</p>
<p>Или другой пример:</p>
<pre><code class="lang-haskell"><span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">UserId</span> = <span class="hljs-type">Integer</span></span>
<span class="hljs-typedef"><span class="hljs-keyword">type</span> <span class="hljs-type">Prefix</span> = <span class="hljs-type">String</span></span>

<span class="hljs-title">obtainLogin</span> :: <span class="hljs-type">UserId</span> -&gt; (<span class="hljs-type">Prefix</span> -&gt; <span class="hljs-type">String</span>)
<span class="hljs-title">obtainLogin</span> userId =
    loginStorage <span class="hljs-string">"denis"</span>  <span class="hljs-comment">-- Подразумевается, что логин как-то получен.</span>
    <span class="hljs-keyword">where</span> loginStorage login prefix = prefix ++ <span class="hljs-string">": "</span> ++ login

<span class="hljs-title">main</span> =
    <span class="hljs-keyword">let</span> userId = <span class="hljs-number">1234</span>
    <span class="hljs-keyword">in</span>
    putStrLn ((obtainLogin userId) <span class="hljs-string">"My login"</span>)
</code></pre>
<p>Рассмотрим функцию <code>obtainLogin</code> подробнее:</p>
<pre><code class="lang-haskell"><span class="hljs-title">obtainLogin</span> :: <span class="hljs-type">UserId</span> -&gt; (<span class="hljs-type">Prefix</span> -&gt; <span class="hljs-type">String</span>)
<span class="hljs-title">obtainLogin</span> userId =
    loginStorage <span class="hljs-string">"denis"</span>
    <span class="hljs-keyword">where</span> loginStorage login prefix = prefix ++ <span class="hljs-string">": "</span> ++ login
</code></pre>
<p>Здесь мы, на основании полученного извне идентификатора пользователя, откуда-то извлекаем логин и сразу же прячем его в λ-функцию, тут же нами и созданную. В результате функция <code>obtainLogin</code> возвращает частично применённую функцию, которую мы вторично применяем к строке-префиксу - и в результате на выходе мы получаем готовый результат:</p>
<pre><code class="lang-bash">My login: denis
</code></pre>
<p>Вас, вероятно, интересует, почему я сказал о λ-функции? Вроде бы здесь нет нашего знакомого <code>\</code>:</p>
<pre><code class="lang-haskell">    <span class="hljs-keyword">where</span> loginStorage login prefix = prefix ++ <span class="hljs-string">": "</span> ++ login
</code></pre>
<p>Однако это не важно, ведь такая запись идентична λ-форме:</p>
<pre><code class="lang-haskell">    <span class="hljs-keyword">where</span> loginStorage = \login prefix -&gt; prefix ++ <span class="hljs-string">": "</span> ++ login
</code></pre>
<p>Помните, выше я говорил, что тривиальную функцию лучше определять без объявления? Вот это тот самый случай.</p>
<p>Готово. Теперь вы знаете о функциях высшего порядка. Именно по причине того, что с функциями в Haskell можно работать как со значениями, мы можем составлять из них гибкие комбинации.</p>

                            
                        
                    </article>
                
            
                
                    <article id="about-functions/functional-chains.md">
                    
                            
                                <h2 id="-">Функциональные цепочки</h2>
<p>В отношении функций часто можно сказать: &quot;Один в поле не воин&quot;. В этой главе мы рассмотрим два удобных способа организации взаимодействия функций.</p>
<h3 id="-url">Пример с URL</h3>
<p>Известно, что вид URL обязан соответствовать особым правилам. Но в реальной жизни это не всегда так, поэтому иногда URL необходимо преобразовать к правильному виду. Вот как это может выглядеть:</p>
<pre><code class="lang-haskell"><span class="hljs-import"><span class="hljs-keyword">import</span> Data.Char</span>
<span class="hljs-import"><span class="hljs-keyword">import</span> Data.String.Utils</span>

<span class="hljs-title">addPrefix</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">String</span>
<span class="hljs-title">addPrefix</span> url =
    <span class="hljs-keyword">if</span> url `startsWith` prefix <span class="hljs-keyword">then</span> url <span class="hljs-keyword">else</span> prefix ++ url
    <span class="hljs-keyword">where</span> prefix = <span class="hljs-string">"http://"</span>
          startsWith url prefix = startswith prefix url

<span class="hljs-title">encodeAllSpaces</span> = replace <span class="hljs-string">" "</span> <span class="hljs-string">"%20"</span>  <span class="hljs-comment">-- Заменяем все пробелы на %20.</span>

<span class="hljs-title">makeItLowerCase</span> = map toLower  <span class="hljs-comment">-- Переводим символы строки в нижний регистр.      </span>

<span class="hljs-title">main</span> =
    putStrLn (addPrefix (encodeAllSpaces (makeItLowerCase url)))
    <span class="hljs-keyword">where</span> url = <span class="hljs-string">"www.SITE.com/test me/Start page"</span>
</code></pre>
<p>Вывод будет таким:</p>
<pre><code class="lang-bash">http://www.site.com/test%<span class="hljs-number">20</span>me/start%<span class="hljs-number">20</span>page
</code></pre>
<p>Обратите внимание: мы импортировали новый модуль <code>Data.String.Utils</code>. Этот модуль является частью пакета <code>MissingH</code>, содержащего кучу разных полезных утилит. Установим этот пакет:</p>
<pre><code class="lang-bash">$ cabal install MissingH
</code></pre>
<p>Упомянем его в файле <code>Real.cabal</code>:</p>
<pre><code class="lang-haskell">    build-depends: base ==<span class="hljs-number">4.6</span>.\*, <span class="hljs-type">MissingH</span>
</code></pre>
<p>В модуле <code>Data.String.Utils</code> присутствуют различные вкусности для работы со строками, но нам понадобилась лишь одна функция <code>startswith</code>, проверяющая, является ли одна строка началом другой строки. Кстати, вы заметили? Мы обернули эту функцию в нашу собственную:</p>
<pre><code class="lang-haskell"><span class="hljs-title">startsWith</span> url prefix = startswith prefix url
</code></pre>
<p>Ничего особенного, просто переставили аргументы местами. Сделано это для того, чтобы вызов функция правильно смотрелась в инфиксной форме:</p>
<pre><code class="lang-haskell"><span class="hljs-title">if</span> url `startsWith` prefix
</code></pre>
<p>Идём дальше. Вы, вероятно, обратили внимание на две необычные строки:</p>
<pre><code class="lang-haskell"><span class="hljs-title">encodeAllSpaces</span> = replace <span class="hljs-string">" "</span> <span class="hljs-string">"%20"</span>

<span class="hljs-title">makeItLowerCase</span> = map toLower
</code></pre>
<p>Что это? Вроде бы похоже на функции, определённые без объявления, но где же тут аргументы? А они здесь не нужны. Чтобы стало понятнее, напишем одну из них с аргументом:</p>
<pre><code class="lang-haskell"><span class="hljs-title">makeItLowerCase</span> url = map toLower url
</code></pre>
<p>Это - полная форма. Но мы можем сократить её, убрав аргумент. Почему? Потому что такой инструкцией:</p>
<pre><code class="lang-haskell"><span class="hljs-title">makeItLowerCase</span> = map toLower
</code></pre>
<p>мы объявляем: &quot;Всё, теперь <code>makeItLowerCase</code> - это псевдоним для функциональной записи <code>map toLower</code>. Поэтому везде, где мы напишем <code>makeItLowerCase arg</code>, мы будем подразумевать запись <code>map toLower arg</code>&quot;.</p>
<p>Итак, у нас имеются три функции, каждая из которых делает с нашим URL простую исправительную операцию: <code>makeItLowerCase</code> переводит все символы в нижний регистр, <code>encodeAllSpaces</code> заменяет пробелы строкой <code>&quot;%20&quot;</code>, <code>addPrefix</code> добавляет префикс, если таковой отсутствует. То есть у нас есть цепочка из трёх функций: на входе этой цепочки неправильный URL, а на выходе - исправленный URL. Рассмотрим эту цепочку поближе:</p>
<pre><code class="lang-haskell"><span class="hljs-title">addPrefix</span> (encodeAllSpaces (makeItLowerCase url))
</code></pre>
<p>Каждая из функций принимает на вход URL и возвращает уже обработанный ею URL, поступающий на вход следующей функции.</p>
<p>И всё бы хорошо, но есть в такой цепочке один минус - многовато круглых скобок (да простят меня программисты Lisp). Проблема усугубилась бы, если бы функций-исправителей было не три, а больше. Существует два способа сделать такую цепочку красивее.</p>
<h3 id="-">Функция композиции</h3>
<p>Функция композиции (function composition) выглядит как точка. Её назначение - компоновать функции в цепочку. Вот так:</p>
<pre><code class="lang-haskell">(addPrefix . encodeAllSpaces . makeItLowerCase) url
</code></pre>
<p>Функция композиции берёт наши три функции и объединяет их в одну конструкцию, которая один раз применяется к нашему <code>url</code>, и результат будет точно таким же, как если бы мы написали так:</p>
<pre><code class="lang-haskell"><span class="hljs-title">addPrefix</span> (encodeAllSpaces (makeItLowerCase url))
</code></pre>
<p>Можно сказать, что функция композиции создала стек из трёх функций: перечислены они слева направо, а вызываться будут справа налево. Таким образом, строка <code>url</code> едет по конвейеру, заезжая в него с правого края и выезжая с левого.</p>
<h3 id="-">Функция применения</h3>
<p>А ещё есть функция применения (function application), иногда говорят &quot;функция аппликации&quot;. Выглядит она как значок доллара. Её назначение - компоновать функции в цепочку. Вот так:</p>
<pre><code class="lang-haskell"><span class="hljs-title">addPrefix</span> $ encodeAllSpaces $ makeItLowerCase url
</code></pre>
<p>Здесь мы обошлись вообще без скобок. И такое написание также аналогично исходному:</p>
<pre><code class="lang-haskell"><span class="hljs-title">addPrefix</span> (encodeAllSpaces (makeItLowerCase url))
</code></pre>
<p>Здесь тоже получился стек из функций: перечислены слева направо, а вызываются справа налево. Такой вызов справа налево называют ещё правоассоциативным (right-associative).</p>
<h3 id="-">Вместе</h3>
<p>Вероятно, вам интересно, а в чём же разница между этими двумя способами? Ведь и первый и второй предназначены для организации стековой цепочки функций.</p>
<p>Главная разница состоит в том, что функция применения позволяет объединять не только функции, но также функцию с её аргументом:</p>
<pre><code class="lang-haskell"><span class="hljs-title">main</span> = print $ <span class="hljs-string">"Hi master!"</span>
</code></pre>
<p>Долларовый оператор объединил значение и применяемую к этому значению функцию, а вот функция композиции не позволила бы проделать такой фокус.</p>
<p>Вы спросите, зачем всё это нужно? Рассмотрим вот такой вызов:</p>
<pre><code class="lang-haskell"><span class="hljs-title">main</span> = print (<span class="hljs-string">"Hi master '"</span> ++ name ++ <span class="hljs-string">"', have a nice day!"</span>)
</code></pre>
<p>Функция <code>print</code> готова работать исключительно с одним аргументом, поэтому три литерала, объединяющиеся в один, необходимо взять в скобки. Значительно удобнее написать так:</p>
<pre><code class="lang-haskell"><span class="hljs-title">main</span> = print $ <span class="hljs-string">"Hi master '"</span> ++ name ++ <span class="hljs-string">"', have a nice day!"</span>
</code></pre>
<p>Мы избавились от скобок, объединив функцию и её аргумент в маленькую цепочку. Именно благодаря такому свойству функции композиции и применения часто используют вместе:</p>
<pre><code class="lang-haskell"><span class="hljs-title">addPrefix</span> . encodeAllSpaces . makeItLowerCase $ url
</code></pre>
<p>Точка объединяет функции, а доллар привязывает их к аргументу. Кстати, в реальных Haskell-проектах чаще всего используется именно такая &quot;бесскобочная&quot; форма вызова.</p>
<p>Всё, теперь вы знаете о функциональных цепочках.</p>

                            
                        
                    </article>
                
            
        </section>
        
    
        
        <section>
            <article id="about-lists/README.md" class="new-chapter">
                <h1>О списках</h1>
            </article>

            
                
                    <article id="about-lists/lists-at-a-glance.md">
                    
                            
                                <h2 id="-">Списки - одним взглядом</h2>
<p>Списки в Haskell - это наборы элементов одного типа. И когда вы видите в коде квадратные скобки - значит, список где-то рядом.</p>
<p>Вот список из трёх целочисленных элементов:</p>
<pre><code class="lang-haskell">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
</code></pre>
<p>а вот пустой список:</p>
<pre><code class="lang-haskell">[]
</code></pre>
<p>Элементами списка могут быть значения любого типа, в том числе и другие списки. Мы даже можем создать список функций, но после прочтения предыдущих глав вас этот факт не должен удивлять.</p>
<h3 id="-">Простейшие действия</h3>
<p>Если списки создаются - значит это кому-нибудь нужно. Вот функция, возвращающая список из трёх строк:</p>
<pre><code class="lang-haskell"><span class="hljs-title">listOfNames</span> :: <span class="hljs-type">String</span> -&gt; [<span class="hljs-type">String</span>]
<span class="hljs-title">listOfNames</span> prefix = 
    [prefix ++ <span class="hljs-string">"John"</span>, prefix ++ <span class="hljs-string">"Anna"</span>, prefix ++ <span class="hljs-string">"Andrew"</span>]

<span class="hljs-title">main</span> = print $ listOfNames <span class="hljs-string">"Dear "</span>
</code></pre>
<p>Результат:</p>
<pre><code class="lang-bash">[<span class="hljs-string">"Dear John"</span>,<span class="hljs-string">"Dear Anna"</span>,<span class="hljs-string">"Dear Andrew"</span>]
</code></pre>
<p>Обратите внимание на объявление этой функции:</p>
<pre><code class="lang-haskell"><span class="hljs-title">listOfNames</span> :: <span class="hljs-type">String</span> -&gt; [<span class="hljs-type">String</span>]
</code></pre>
<p>Тип <code>[String]</code> - это тип списка строк. А, например, список символов объявляется как <code>[Char]</code>. Кстати, строка - это и есть список символов, то есть тип <code>String</code> эквивалентен типу <code>[Char]</code>. Поэтому объявление может быть и таким:</p>
<pre><code class="lang-haskell"><span class="hljs-title">listOfNames</span> :: <span class="hljs-type">String</span> -&gt; [[<span class="hljs-type">Char</span>]]  <span class="hljs-comment">-- Возвращает список списков символов.</span>
</code></pre>
<p>Вот так можно узнать размер списка:</p>
<pre><code class="lang-haskell"><span class="hljs-title">main</span> =
    print $ length listOfAnimals
    <span class="hljs-keyword">where</span> listOfAnimals = [<span class="hljs-string">"Bear"</span>, <span class="hljs-string">"Tiger"</span>, <span class="hljs-string">"Lion"</span>, <span class="hljs-string">"Wolf"</span>]
</code></pre>
<p>А так можно узнать, присутствует ли заданное значение в списке:</p>
<pre><code class="lang-haskell"><span class="hljs-title">thisIsAWildAnimal</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Bool</span>
<span class="hljs-title">thisIsAWildAnimal</span> name =
    name `elem` wildAnimals
    <span class="hljs-keyword">where</span> wildAnimals = [<span class="hljs-string">"Bear"</span>, <span class="hljs-string">"Tiger"</span>, <span class="hljs-string">"Lion"</span>, <span class="hljs-string">"Wolf"</span>]

<span class="hljs-title">main</span> = print $ <span class="hljs-keyword">if</span> thisIsAWildAnimal <span class="hljs-string">"Cat"</span> <span class="hljs-keyword">then</span> <span class="hljs-string">"Yes!"</span> <span class="hljs-keyword">else</span> <span class="hljs-string">"No!"</span>
</code></pre>
<p>Здесь функция стандартная функция <code>elem</code>, записанная в инфиксной форме (то есть между двумя своими аргументами), проверяет наличие строки <code>&quot;Cat&quot;</code> в списке диких животных.</p>
<p>Стандартная библиотека Haskell позволяет делать со списком самые разные вещи, такие как получение минимального значения, вычисления суммы элементов, извлечение части списка, проверка на пустоту и равенство и так далее и в том же духе.</p>
<h3 id="-">Неизменность списка</h3>
<p>Как вы знаете, все значения в Haskell неизменны, как Египетские пирамиды. Списки - не исключение: мы не можем изменить список, мы можем лишь создать на его основе новый список. Например:</p>
<pre><code class="lang-haskell"><span class="hljs-title">addNewHostToFront</span> :: <span class="hljs-type">String</span> -&gt; [<span class="hljs-type">String</span>] -&gt; [<span class="hljs-type">String</span>]
<span class="hljs-title">addNewHostToFront</span> newHost listOfHosts = newHost : listOfHosts

<span class="hljs-title">main</span> =
    print $ addNewHostToFront <span class="hljs-string">"124.67.54.90"</span> listOfHosts
    <span class="hljs-keyword">where</span> listOfHosts = [<span class="hljs-string">"45.67.78.89"</span>, <span class="hljs-string">"123.45.65.54"</span>, <span class="hljs-string">"127.0.0.1"</span>]
</code></pre>
<p>Вывод:</p>
<pre><code class="lang-bash">[<span class="hljs-string">"124.67.54.90"</span>,<span class="hljs-string">"45.67.78.89"</span>,<span class="hljs-string">"123.45.65.54"</span>,<span class="hljs-string">"127.0.0.1"</span>]
</code></pre>
<p>С концептуальной точки зрения функция <code>addNewHostToFront</code> добавила новый адрес в начало переданного ей списка. Но в действительности никакого добавления не произошло: функция просто взяла значение <code>newHost</code> и список <code>listOfHosts</code> и создала на их основе новый список, содержащий уже четыре адреса вместо трёх.</p>
<h3 id="-">Действия над элементами</h3>
<p>Мы создаём список для того, чтобы что-то делать с его элементами. Например, такая функция:</p>
<pre><code class="lang-haskell"><span class="hljs-title">removeAllEmptyNamesFrom</span> :: [<span class="hljs-type">String</span>] -&gt; [<span class="hljs-type">String</span>]
<span class="hljs-title">removeAllEmptyNamesFrom</span> listOfNames =
    filter notEmptyName listOfNames
    <span class="hljs-keyword">where</span> notEmptyName = not . null 

<span class="hljs-title">main</span> =
    print $ removeAllEmptyNamesFrom listOfNames
    <span class="hljs-keyword">where</span> listOfNames = [<span class="hljs-string">"John"</span>, <span class="hljs-string">""</span>, <span class="hljs-string">"Ann"</span>]
</code></pre>
<p>Стандартная функция <code>filter</code> последовательно применяет предикат <code>notEmptyName</code> к каждой строке в списке и конструирует новый список лишь из тех строк, которые удовлетворяют этому предикату. В качестве предиката выступает функция, применяющаяся к одной строке и возвращающая значение <code>True</code> только в том случае, если эта строка не <code>null</code> (то есть непустая). Обратите внимание, мы вновь использовали короткую форму записи функции notEmptyName, опустив имя аргумента. </p>
<p>Вот и всё. Помимо функций <code>map</code> и <code>filter</code>, в стандартной библиотеке Haskell есть и многие другие вкусности для работы с элементами (проверки, замены, сортировки, перестановки и тому подобное).</p>

                            
                        
                    </article>
                
            
                
                    <article id="about-lists/ranges.md">
                    
                            
                                <h2 id="-">Диапазоны</h2>
<p>Диапазон - это конструкция, автоматически создающая список по заданному признаку.</p>
<h3 id="-">Суть</h3>
<p>Если нам нужно создать список целых чисел от 1 до 10, мы можем написать так:</p>
<pre><code class="lang-haskell">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]
</code></pre>
<p>а можем просто задать диапазон:</p>
<pre><code class="lang-haskell">[<span class="hljs-number">1.</span><span class="hljs-number">.10</span>]
</code></pre>
<p>Готово.</p>
<p>Разумеется, такой фокус можно проделать не только с числами. Например, вот так мы получим список всех букв английского алфавита в нижнем регистре:</p>
<pre><code class="lang-haskell"><span class="hljs-title">main</span> = print ['a'..'z']
</code></pre>
<p>На выходе получим красивый список символов, или простую строку:</p>
<pre><code class="lang-bash"><span class="hljs-string">"abcdefghijklmnopqrstuvwxyz"</span>
</code></pre>
<h3 id="-">Умные диапазоны</h3>
<p>Диапазоны можно задавать весьма гибко. Например, так мы можем получить список всех чётных чисел от 2 до 30:</p>
<pre><code class="lang-haskell"><span class="hljs-title">main</span> = print [<span class="hljs-number">2</span>,<span class="hljs-number">4.</span><span class="hljs-number">.30</span>]
</code></pre>
<p>Мы задали шаг между значениями элементов, а остальные значения были созданы уже автоматически. Можно и в порядке убывания:</p>
<pre><code class="lang-haskell"><span class="hljs-title">main</span> = print [<span class="hljs-number">120</span>,<span class="hljs-number">110.</span><span class="hljs-number">.10</span>]
</code></pre>
<p>На выходе получим список с десятками:</p>
<pre><code class="lang-bash">[<span class="hljs-number">120</span>,<span class="hljs-number">110</span>,<span class="hljs-number">100</span>,<span class="hljs-number">90</span>,<span class="hljs-number">80</span>,<span class="hljs-number">70</span>,<span class="hljs-number">60</span>,<span class="hljs-number">50</span>,<span class="hljs-number">40</span>,<span class="hljs-number">30</span>,<span class="hljs-number">20</span>,<span class="hljs-number">10</span>]
</code></pre>
<p>А вот чего компилятор не потерпит, так это излишних указаний с вашей стороны. Поэтому не пишите так:</p>
<pre><code class="lang-haskell"><span class="hljs-title">main</span> = print [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6.</span><span class="hljs-number">.30</span>]
</code></pre>
<p>и так тоже не пишите:</p>
<pre><code class="lang-haskell"><span class="hljs-title">main</span> = print [<span class="hljs-number">2</span>,<span class="hljs-number">4.</span><span class="hljs-number">.28</span>,<span class="hljs-number">30</span>]
</code></pre>
<p>Компилятор обидится на вас, ведь вы пытаетесь сказать ему то, что он и сам прекрасно понимает.</p>
<h3 id="-">Без конца</h3>
<p>Как вы помните, ленивость языка Haskell позволяет нам оперировать бесконечными списками. И мы можем создать такой список через диапазон.</p>
<p>Например, вот такой диапазон:</p>
<pre><code class="lang-haskell">[<span class="hljs-number">1.</span>.]
</code></pre>
<p>создаст бесконечный список целых чисел, начиная с 1. Но, как вы уже знаете, в действительности созданный этим диапазоном список будет вовсе не бесконечным, а лишь <em>достаточно</em> большим:</p>
<pre><code class="lang-haskell"><span class="hljs-title">main</span> = print $ take <span class="hljs-number">5</span> [<span class="hljs-number">1.</span>.]
</code></pre>
<p>Вывод:</p>
<pre><code class="lang-bash">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]
</code></pre>
<p>Мы можем задать и шаг:</p>
<pre><code class="lang-haskell"><span class="hljs-title">main</span> = print $ take <span class="hljs-number">5</span> [<span class="hljs-number">2</span>,<span class="hljs-number">4.</span>.]
</code></pre>
<p>В этом случае вывод будет таким:</p>
<pre><code class="lang-bash">[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>]
</code></pre>
<p>Вот такие они, эти диапазоны. Теперь вы и про них знаете.</p>

                            
                        
                    </article>
                
            
                
                    <article id="about-lists/tuples.md">
                    
                            
                                <h2 id="-">Кортежи</h2>
<p>Кортеж - это особый вид списка. Он тоже хранит в себе набор элементов, однако имеет три фундаментальных отличия от списка:</p>
<ol>
<li>круглые скобки вместо квадратных;</li>
<li>гетерогенность;</li>
<li>тип, зависящий от размера.</li>
</ol>
<p>С первым отличием всё очевидно:</p>
<pre><code class="lang-haskell">[<span class="hljs-string">"Denis"</span>, <span class="hljs-string">"Shevchenko"</span>]  <span class="hljs-comment">-- Это список из двух строк.</span>
(<span class="hljs-string">"Denis"</span>, <span class="hljs-string">"Shevchenko"</span>)  <span class="hljs-comment">-- Это кортеж из двух строк.</span>
</code></pre>
<p>Второе отличие - это способность кортежа хранить в себе элементы разных типов:</p>
<pre><code class="lang-haskell">[<span class="hljs-string">"Denis"</span>, <span class="hljs-number">1.234</span>]  <span class="hljs-comment">-- Будьте уверены, компиляция не пройдёт...</span>
(<span class="hljs-string">"Denis"</span>, <span class="hljs-number">1.234</span>)  <span class="hljs-comment">-- А тут - без проблем!</span>
</code></pre>
<p>Теперь о третьем отличии. Если у нас есть два разных по размеру списка строк:</p>
<pre><code class="lang-haskell">[<span class="hljs-string">"Denis"</span>, <span class="hljs-string">"Vasil`evich"</span>, <span class="hljs-string">"Shevchenko"</span>]
[<span class="hljs-string">"Denis"</span>, <span class="hljs-string">"Shevchenko"</span>]
</code></pre>
<p>тип обоих этих списков одинаков, а именно <code>[String]</code>. Тип списка не зависит от количества элементов в нём.</p>
<p>С кортежами всё обстоит совершенно иначе. Если у нас есть два кортежа, разных по длине:</p>
<pre><code class="lang-haskell">(<span class="hljs-string">"Denis"</span>, <span class="hljs-string">"Vasil`evich"</span>, <span class="hljs-string">"Shevchenko"</span>)
(<span class="hljs-string">"Denis"</span>, <span class="hljs-string">"Shevchenko"</span>)
</code></pre>
<p>типы этих кортежей абсолютно разные: тип первого <code>(String, String, String)</code>, а тип второго <code>(String, String)</code>. Поэтому если функцию, в качестве аргумента ожидающую кортеж из двух строк, применить к кортежу из трёх строк, компилятор выразит свой категорический протест:</p>
<pre><code class="lang-bash">Couldn<span class="hljs-string">'t match expected type `(String, String)'</span>
            with actual <span class="hljs-built_in">type</span> `([Char], [Char], [Char])<span class="hljs-string">'</span>
</code></pre>
<p>Оно и понятно: ожидали кортеж из двух строк, а тут вдруг - из трёх!</p>
<p>Кстати, кортеж похож на список ещё и тем, что тоже может быть пустым, то есть не содержать в себе ни одного элемента. Пустой кортеж используется как отражение понятия &quot;ничего&quot;. Скоро мы увидим такие случаи.</p>
<h3 id="-">Что с ними можно делать</h3>
<p>Единственное, что можно сделать с кортежем - извлечь хранящиеся в нём элементы. Всё.</p>
<p>На практике чаще всего используют кортежи из двух элементов. Такой кортеж ещё называют парой (pair). Чтобы извлечь хранящиеся в нём элементы, используют стандартные функции <code>fst</code> и <code>snd</code>.</p>
<p>Определим функцию, применяющуюся к кортежу, хранящему две части шахматного хода:</p>
<pre><code class="lang-haskell"><span class="hljs-title">chessMove</span> :: (<span class="hljs-type">String</span>, <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">String</span>
<span class="hljs-title">chessMove</span> pair = fst pair ++ <span class="hljs-string">"-"</span> ++ snd pair

<span class="hljs-title">main</span> = print $ chessMove (<span class="hljs-string">"e2"</span>, <span class="hljs-string">"e4"</span>)
</code></pre>
<p>Мы последовательно извлекли первый и второй элементы из полученной пары и сделали из них единую строку:</p>
<pre><code class="lang-bash">e2<span class="hljs-operator">-e</span>4
</code></pre>
<p>Но что же мы будем делать, если количество элементов в кортеже больше двух? Ведь функции <code>fst</code> и <code>snd</code> работают только с парами. Если элементов больше двух, извлекать их нужно иным способом.</p>
<h3 id="-">Неудобный способ</h3>
<p>Первый способ неудобен, ибо нам придётся самим определять необходимые функции. Но нас трудности не страшат, поэтому сделаем это:</p>
<pre><code class="lang-haskell"><span class="hljs-title">get1</span> (element, _, _, _) = element
<span class="hljs-title">get2</span> (_, element, _, _) = element
<span class="hljs-title">get3</span> (_, _, element, _) = element
<span class="hljs-title">get4</span> (_, _, _, element) = element
</code></pre>
<p>Подразумевается, что мы хотим работать с кортежем из четырёх элементов. В этом случае есть лишь четыре варианта извлечения, поэтому определим четыре функции для извлечения первого элемента, второго, третьего и четвёртого соответственно. Кстати, говоря &quot;первый элемент&quot;, мы подразумеваем именно первый по счёту, поэтому цифра <code>1</code> в имени <code>get1</code> - это порядковый номер, а не индекс.</p>
<p>А теперь рассмотрим определение первой функции:</p>
<pre><code class="lang-haskell"><span class="hljs-title">get1</span> (element, _, _, _) = element
</code></pre>
<p>Эта функция применяется к кортежу из четырёх элементов и возвращает первый из них. Обратите внимание на странные символы подчёркивания. Воспринимайте этот символ как &quot;нечто&quot;, &quot;что бы то ни было&quot;. Мы говорим: &quot;Да, в этом кортеже есть четыре элемента, но нас абсолютно не интересует, что там под номером два, и что под номером три, и что под номером четыре. Нас интересует только то, что под номером один. Вот этот номер один мы и вернём&quot;.</p>
<p>Так же и вторая функция:</p>
<pre><code class="lang-haskell"><span class="hljs-title">get2</span> (_, element, _, _) = element
</code></pre>
<p>Получаем четыре элемента, и хотя что-то там стоит под номерами один, три и четыре, нас это не волнует, нам нужен только элемент под номером два, поэтому именно его и возвращаем.</p>
<p>А теперь пишем:</p>
<pre><code class="lang-haskell"><span class="hljs-title">main</span> = print $ get3 (<span class="hljs-string">"One"</span>, <span class="hljs-string">"Two"</span>, <span class="hljs-string">"Three"</span>, <span class="hljs-string">"Four"</span>)
</code></pre>
<p>и получаем ожидаемый результат:</p>
<pre><code class="lang-bash"><span class="hljs-string">"Three"</span>
</code></pre>
<h3 id="-">Удобный способ</h3>
<p>Зачем делать самому то, что уже сделали другие? А другие уже сделали пакет <code>tuple</code> из Hackage. Живёт пакет <a href="http://hackage.haskell.org/package/tuple" target="_blank">здесь</a>. Установим его командой:</p>
<pre><code class="lang-bash">$ cabal install tuple
</code></pre>
<p>Затем добавим имя этого пакета к параметру <code>build-depends</code> в файле <code>Real.cabal</code>:</p>
<pre><code class="lang-haskell">    build-depends:  base ==<span class="hljs-number">4.6</span>.\*, <span class="hljs-type">MissingH</span>, tuple
</code></pre>
<p>Импортируем модуль <code>Data.Tuple.Select</code>, и сразу же можем приступить:</p>
<pre><code class="lang-haskell"><span class="hljs-import"><span class="hljs-keyword">import</span> Data.Tuple.Select</span>

<span class="hljs-title">main</span> = print $ sel3 (<span class="hljs-string">"One"</span>, <span class="hljs-string">"Two"</span>, <span class="hljs-string">"Three"</span>, <span class="hljs-string">"Four"</span>)
</code></pre>
<p>Метод <code>sel3</code> извлекает третий элемент кортежа. Просто и удобно. Кстати, в модуле <code>Data.Tuple.Select</code> определены функции от <code>sel1</code> до <code>sel15</code>. Авторы этого пакета вполне резонно предположили, что создавать кортеж из более чем 15 элементов никакому вменяемому программисту в голову не придёт...</p>
<p>А кстати, как же насчёт безопасности? Что будет, если мы по ошибке попытаемся извлечь из этого кортежа пятый элемент? Попробуем:</p>
<pre><code class="lang-haskell"><span class="hljs-import"><span class="hljs-keyword">import</span> Data.Tuple.Select</span>

<span class="hljs-title">main</span> = print $ sel5 (<span class="hljs-string">"One"</span>, <span class="hljs-string">"Two"</span>, <span class="hljs-string">"Three"</span>, <span class="hljs-string">"Four"</span>)
</code></pre>
<p>Итак, пытаемся извлечь пятый элемент при наличии только четырёх. Получили трудноуловимую ошибку? Или, может, будет брошено исключение? Вовсе нет. Такой код просто не пройдёт компиляцию:</p>
<pre><code class="lang-bash">src/Main.hs:<span class="hljs-number">23</span>:<span class="hljs-number">12</span>:
    No instance <span class="hljs-keyword">for</span> (Sel5 ([Char], [Char], [Char], [Char]) a0)
      arising from a use of `sel5<span class="hljs-string">'</span>
</code></pre>
<p>Как мы помним, тип кортежа жёстко привязан к количеству хранящихся в нём значений. Именно поэтому такого рода ошибки будут выявлены на стадии компиляции.</p>
<p>Всё. Теперь вы и о кортежах знаете.</p>

                            
                        
                    </article>
                
            
                
                    <article id="about-lists/list-comprehension.md">
                    
                            
                                <h2 id="list-comprehension">List comprehension</h2>
<p>Не удивляйтесь, что название этой главы не переведено на русский. Корректный перевод понятия &quot;list comprehension&quot; я так и не смог подобрать, долго размышлял - и в итоге решил оставить как есть.</p>
<p>Речь пойдёт об одной хитрой конструкции, предназначенной для прохода по элементам списка(ов) и применения к ним некоторых действий. Да-да, это похоже на уже известные нам функции <code>map</code> и <code>filter</code>, но есть некоторые дополнительные вкусности.</p>
<h3 id="-">Хитрый список</h3>
<p>Вот как это выглядит:</p>
<pre><code class="lang-haskell"><span class="hljs-import"><span class="hljs-keyword">import</span> Data.Char </span>

<span class="hljs-title">main</span> = print [toUpper c | c &lt;- <span class="hljs-string">"http"</span>]
</code></pre>
<p>На выходе получим:</p>
<pre><code class="lang-bash"><span class="hljs-string">"HTTP"</span>
</code></pre>
<p>Рассмотрим поближе:</p>
<pre><code class="lang-haskell">[toUpper c | c &lt;- <span class="hljs-string">"http"</span>]
</code></pre>
<p>Мы видим квадратные скобки... То есть перед нами список? Не совсем. Можно сказать, что перед нами генератор списка. Скелет такой конструкции можно представить так:</p>
<pre><code>[OPERATION ELEM | ELEM &lt;- LIST] 
</code></pre><p>где <code>LIST</code> - список, <code>ELEM</code> - элемент этого списка, а <code>OPERATION</code> - функция, применяемая к каждому элементу. Мы говорим: &quot;Возьми список <code>LIST</code>, последовательно пройдись по всем его элементам и примени к каждому из них функцию <code>OPERATION</code>&quot;. В результате значения, возвращаемые функцией <code>OPERATION</code>, породят новый список.</p>
<p>В данном случае мы пройдём по всем символам строки <code>http</code> и применим к каждому из её символов функцию <code>toUpper</code>, которая в свою очередь переведёт этот символ в верхний регистр. В результате мы получим новую строку <code>&quot;HTTP&quot;</code>.</p>
<h3 id="-">Добавляем предикат</h3>
<p>Мы можем добавить предикат в эту конструкцию. Тогда её скелет станет таким:</p>
<p>[OPERATION ELEM | ELEM &lt;- LIST, PREDICATE]</p>
<p>В этом случае мы говорим: &quot;Возьми список LIST, последовательно пройдись по всем его элементам и примени функцию OPERATION только к тем элементам, которые удовлетворят предикату PREDICATE&quot;.</p>
<p>Например:</p>
<p>import Data.Char</p>
<p>main = print [toUpper c | c &lt;- &quot;http&quot;, c == &#39;t&#39;]</p>
<p>На выходе будет:</p>
<p>&quot;TT&quot;</p>
<p>Мы прошлись по всем четырём символам строки http, но функция toUpper была применена только к тем символам, которые удовлетворили предикату c == &#39;t&#39;. Именно поэтому на выходе мы получили строку из двух символов, ибо только они удовлетворили этому предикату.</p>
<p>Предикатов, кстати, может быть несколько. Например, так:</p>
<p>import Data.Char</p>
<p>main = print [toUpper c | c &lt;- &quot;http&quot;, c /= &#39;h&#39;, c /= &#39;p&#39;]</p>
<p>Вывод в этом случае будет таким же:</p>
<p>&quot;TT&quot;</p>
<p>Здесь два предиката, c /= &#39;h&#39; и c /= &#39;p&#39;. Они соединяются в единый предикат через логическое &quot;И&quot;, поэтому мы можем написать и так:</p>
<p>[toUpper c | c &lt;- &quot;http&quot;, c /= &#39;h&#39; &amp;&amp; c /= &#39;p&#39;]</p>
<p>Результат будет таким же.</p>
<p>Обратите внимание на комбинацию символов /=. Это оператор &quot;не равно&quot;, аналог оператора != в языке C. Кстати, он тоже носит математический окрас. Сравните:</p>
<p>/=   - Haskell-форма</p>
<p>≠    - математическая форма</p>
<p>Симпатично, не правда ли? Прямое сходство, мы лишь передвинули перечеркивающую косую палочку.</p>
<h3 id="-">Больше списков</h3>
<p>Мы можем использовать эту конструкцию для совместной работы с несколькими списками. Скелет в этом случае будет таким:</p>
<p>[OPERATION_with_ELEMs | ELEM1 &lt;- LIST1, ..., ELEMN &lt;- LISTN ]</p>
<p>Здесь мы работаем сразу с N списками, а OPERATION_with_ELEMs представляет собой функцию, в которую передаются все элементы наших списков. Например:</p>
<p>main =</p>
<pre><code>print [prefix ++ <span class="hljs-property">name</span> | <span class="hljs-property">name</span> &lt;- names, prefix &lt;- namePrefix]

<span class="hljs-keyword">where</span> names = [<span class="hljs-string">"James"</span>, <span class="hljs-string">"Victor"</span>, <span class="hljs-string">"Denis"</span>, <span class="hljs-string">"Michael"</span>]

      namePrefix = [<span class="hljs-string">"Mr. "</span>]
</code></pre><p>На выходе получим:</p>
<p>[&quot;Mr. James&quot;,&quot;Mr. Victor&quot;,&quot;Mr. Denis&quot;,&quot;Mr. Michael&quot;]</p>
<p>Мы последовательно прошлись по всем элементам списков names и namePrefix.</p>
<p>Обратите внимание, в списке namePrefix лишь один префикс. Вот что будет, если префиксов два:</p>
<p>main =</p>
<pre><code>print [prefix ++ <span class="hljs-property">name</span> | <span class="hljs-property">name</span> &lt;- names, prefix &lt;- namePrefix]

<span class="hljs-keyword">where</span> names = [<span class="hljs-string">"James"</span>, <span class="hljs-string">"Victor"</span>, <span class="hljs-string">"Denis"</span>, <span class="hljs-string">"Michael"</span>]

      namePrefix = [<span class="hljs-string">"Mr. "</span>, <span class="hljs-string">"sir "</span>]  <span class="hljs-comment">-- Теперь префиксов два</span>
</code></pre><p>В этом случае на выходе будет:</p>
<p>[&quot;Mr. James&quot;,&quot;sir James&quot;,&quot;Mr. Victor&quot;,&quot;sir Victor&quot;,&quot;Mr. Denis&quot;,&quot;sir Denis&quot;,&quot;Mr. Michael&quot;,&quot;sir Michael&quot;]</p>
<p>Мы последовательно использовали каждый элемент из списка names и каждый элемент из списка namePrefix.</p>
<h3 id="-">Добавляем условие</h3>
<p>Предикат не всегда применим к элементам списка. В ряде случаев нам нужно условие. Добавим его:</p>
<p>main =</p>
<pre><code><span class="hljs-built_in">print</span> [<span class="hljs-keyword">if</span> car == <span class="hljs-string">"Bentley"</span> <span class="hljs-keyword">then</span> <span class="hljs-string">"Wow!"</span> <span class="hljs-keyword">else</span> <span class="hljs-string">"Good!"</span> | car &lt;- cars]

where cars = [<span class="hljs-string">"Mercedes"</span>,

              <span class="hljs-string">"BMW"</span>,

              <span class="hljs-string">"Bentley"</span>,

              <span class="hljs-string">"Audi"</span>,

              <span class="hljs-string">"Bentley"</span>]
</code></pre><p>Результат:</p>
<p>[&quot;Good!&quot;,&quot;Good!&quot;,&quot;Wow!&quot;,&quot;Good!&quot;,&quot;Wow!&quot;]</p>
<p>Мы прошлись по списку марок автомобилей и применили к каждой из них условие, которое вернуло строку &quot;Wow!&quot; или строку &quot;Good!&quot;.</p>
<h3 id="-">Добавляем локальное выражение</h3>
<p>Мы можем добавить сюда и локальное выражение с помощью уже известного нам let. Например так:</p>
<p>import Data.Char</p>
<p>main = print [toUpper c | c &lt;- &quot;http&quot;,</p>
<pre><code>                      <span class="hljs-built_in">let</span> hletter = <span class="hljs-string">'h'</span> <span class="hljs-keyword">in</span> c /= hletter]
</code></pre><p>Промежуточное значение может быть использовано во избежание дубляжа при наличии нескольких предикатов.</p>
<h3 id="-">Пример</h3>
<p>Разберём более практичный пример:</p>
<p>import Data.String.Utils</p>
<p>checkGooglerBy :: String -&gt; String</p>
<p>checkGooglerBy email =</p>
<pre><code><span class="hljs-keyword">if</span> email `endsWith` <span class="hljs-string">"gmail.com"</span>

then nameFrom email ++ <span class="hljs-string">" is a Googler!"</span>

<span class="hljs-keyword">else</span> email

where endsWith <span class="hljs-keyword">str</span> suffix = endswith suffix <span class="hljs-keyword">str</span>

      nameFrom fullEmail = takeWhile (/= <span class="hljs-string">'@'</span>) fullEmail
</code></pre><p>main = print [checkGooglerBy email | email &lt;- [&quot;adam@gmail.com&quot;,</p>
<pre><code>                                           <span class="hljs-string">"bob<span class="hljs-variable">@yahoo</span>.com"</span>,

                                           <span class="hljs-string">"richard<span class="hljs-variable">@gmail</span>.com"</span>,

                                           <span class="hljs-string">"elena<span class="hljs-variable">@yandex</span>.ru"</span>,

                                           <span class="hljs-string">"denis<span class="hljs-variable">@gmail</span>.com"</span>]]
</code></pre><p>Результат:</p>
<p>[&quot;adam is a Googler!&quot;,&quot;bob@yahoo.com&quot;,&quot;richard is a Googler!&quot;,&quot;elena@yandex.ru&quot;,&quot;denis is a Googler!&quot;]</p>
<p>Мы проанализировали список email-адресов, и заменили все gmail-адреса фразой, начинающейся с имени пользователя. А теперь по шагам.</p>
<p>Из уже знакомого нам модуля Data.String.Utils мы возьмём функцию endswith, проверяющую, завершается ли одна строка другой строкой. Для красивого инфиксного использования мы обернули её собственной функцией endsWith, в результате чего код приобретает литературно точный вид:</p>
<p>if &quot;adam@gmail.com&quot; <code>endsWith</code> &quot;gmail.com&quot;</p>
<p>Теперь рассмотрим эту строку:</p>
<p>takeWhile (/= &#39;@&#39;) fullEmail</p>
<p>Скелет стандартной функции takeWhile можно отобразить так:</p>
<p>takeWhile PREDICATE LIST</p>
<p>Здесь мы говорим: &quot;Последовательно забирай (take) элементы из списка LIST до тех пор (While), пока PREDICATE, применённый к этим элементам, возвращает True. Если наткнёшься на элемент, не соответствующий этому предикату, прекращай работу и возвращай список из ранее полученных элементов&quot;. Мы хотим извлечь имя пользователя из его email-адреса, а значит, мы бежим по email до тех пор, пока символы не равны &#39;@&#39;, что и отражается предикатом (/= &#39;@&#39;). Как только натыкаемся на собачку - возвращаем всё, находящееся перед ней.</p>
<p>Вот и всё. Теперь вы знаете, что такое list comprehension и как его можно использовать в вашем коде.</p>

                            
                        
                    </article>
                
            
        </section>
        
    
        
        <section>
            <article id="about-user-types/README.md" class="new-chapter">
                <h1>О пользовательских типах</h1>
            </article>

            
                
                    <article id="about-user-types/types-at-a-glance.md">
                    
                            
                                <h2 id="-">Лирическое вступление</h2>
<p>Пара слов о том, кто я, почему решил написать эту книгу и кому, кроме меня, она нужна.</p>

                            
                        
                    </article>
                
            
                
                    <article id="about-user-types/about-value-constructors.md">
                    
                            
                                <h2 id="-">Лирическое вступление</h2>
<p>Пара слов о том, кто я, почему решил написать эту книгу и кому, кроме меня, она нужна.</p>

                            
                        
                    </article>
                
            
                
                    <article id="about-user-types/type-context.md">
                    
                            
                                <h2 id="-">Лирическое вступление</h2>
<p>Пара слов о том, кто я, почему решил написать эту книгу и кому, кроме меня, она нужна.</p>

                            
                        
                    </article>
                
            
                
                    <article id="about-user-types/composite-types.md">
                    
                            
                                <h2 id="-">Лирическое вступление</h2>
<p>Пара слов о том, кто я, почему решил написать эту книгу и кому, кроме меня, она нужна.</p>

                            
                        
                    </article>
                
            
                
                    <article id="about-user-types/deriving.md">
                    
                            
                                <h2 id="-">Лирическое вступление</h2>
<p>Пара слов о том, кто я, почему решил написать эту книгу и кому, кроме меня, она нужна.</p>

                            
                        
                    </article>
                
            
                
                    <article id="about-user-types/own-type-classes.md">
                    
                            
                                <h2 id="-">Лирическое вступление</h2>
<p>Пара слов о том, кто я, почему решил написать эту книгу и кому, кроме меня, она нужна.</p>

                            
                        
                    </article>
                
            
                
                    <article id="about-user-types/newtype.md">
                    
                            
                                <h2 id="-">Лирическое вступление</h2>
<p>Пара слов о том, кто я, почему решил написать эту книгу и кому, кроме меня, она нужна.</p>

                            
                        
                    </article>
                
            
        </section>
        
    
        
        <section>
            <article id="io/README.md" class="new-chapter">
                <h1>Ввод и вывод</h1>
            </article>

            
                
                    <article id="io/functions-with-side-effects.md">
                    
                            
                                <h2 id="-">Лирическое вступление</h2>
<p>Пара слов о том, кто я, почему решил написать эту книгу и кому, кроме меня, она нужна.</p>

                            
                        
                    </article>
                
            
                
                    <article id="io/IO-a.md">
                    
                            
                                <h2 id="-">Лирическое вступление</h2>
<p>Пара слов о том, кто я, почему решил написать эту книгу и кому, кроме меня, она нужна.</p>

                            
                        
                    </article>
                
            
                
                    <article id="io/do-imperative-world.md">
                    
                            
                                <h2 id="-">Лирическое вступление</h2>
<p>Пара слов о том, кто я, почему решил написать эту книгу и кому, кроме меня, она нужна.</p>

                            
                        
                    </article>
                
            
                
                    <article id="io/exceptions-handling.md">
                    
                            
                                <h2 id="-">Лирическое вступление</h2>
<p>Пара слов о том, кто я, почему решил написать эту книгу и кому, кроме меня, она нужна.</p>

                            
                        
                    </article>
                
            
                
                    <article id="io/own-exceptions.md">
                    
                            
                                <h2 id="-">Лирическое вступление</h2>
<p>Пара слов о том, кто я, почему решил написать эту книгу и кому, кроме меня, она нужна.</p>

                            
                        
                    </article>
                
            
        </section>
        
    
        
        <section>
            <article id="delicious/README.md" class="new-chapter">
                <h1>Деликатесы</h1>
            </article>

            
                
                    <article id="delicious/monads-essence.md">
                    
                            
                                <h2 id="-">Лирическое вступление</h2>
<p>Пара слов о том, кто я, почему решил написать эту книгу и кому, кроме меня, она нужна.</p>

                            
                        
                    </article>
                
            
                
                    <article id="delicious/monads-IO.md">
                    
                            
                                <h2 id="-">Лирическое вступление</h2>
<p>Пара слов о том, кто я, почему решил написать эту книгу и кому, кроме меня, она нужна.</p>

                            
                        
                    </article>
                
            
                
                    <article id="delicious/monads-practice.md">
                    
                            
                                <h2 id="-">Лирическое вступление</h2>
<p>Пара слов о том, кто я, почему решил написать эту книгу и кому, кроме меня, она нужна.</p>

                            
                        
                    </article>
                
            
                
                    <article id="delicious/maybe.md">
                    
                            
                                <h2 id="-">Лирическое вступление</h2>
<p>Пара слов о том, кто я, почему решил написать эту книгу и кому, кроме меня, она нужна.</p>

                            
                        
                    </article>
                
            
                
                    <article id="delicious/functors.md">
                    
                            
                                <h2 id="-">Лирическое вступление</h2>
<p>Пара слов о том, кто я, почему решил написать эту книгу и кому, кроме меня, она нужна.</p>

                            
                        
                    </article>
                
            
                
                    <article id="delicious/applicative-functors.md">
                    
                            
                                <h2 id="-">Лирическое вступление</h2>
<p>Пара слов о том, кто я, почему решил написать эту книгу и кому, кроме меня, она нужна.</p>

                            
                        
                    </article>
                
            
        </section>
        
    
        
        <section>
            <article id="miscellaneous/README.md" class="new-chapter">
                <h1>Остальное</h1>
            </article>

            
                
                    <article id="miscellaneous/about-modules.md">
                    
                            
                                <h2 id="-">Лирическое вступление</h2>
<p>Пара слов о том, кто я, почему решил написать эту книгу и кому, кроме меня, она нужна.</p>

                            
                        
                    </article>
                
            
                
                    <article id="miscellaneous/recursive-functions.md">
                    
                            
                                <h2 id="-">Лирическое вступление</h2>
<p>Пара слов о том, кто я, почему решил написать эту книгу и кому, кроме меня, она нужна.</p>

                            
                        
                    </article>
                
            
                
                    <article id="miscellaneous/about-apostrophe.md">
                    
                            
                                <h2 id="-">Лирическое вступление</h2>
<p>Пара слов о том, кто я, почему решил написать эту книгу и кому, кроме меня, она нужна.</p>

                            
                        
                    </article>
                
            
                
                    <article id="miscellaneous/about-formatting.md">
                    
                            
                                <h2 id="-">Лирическое вступление</h2>
<p>Пара слов о том, кто я, почему решил написать эту книгу и кому, кроме меня, она нужна.</p>

                            
                        
                    </article>
                
            
                
                    <article id="miscellaneous/about-hlint.md">
                    
                            
                                <h2 id="-">Лирическое вступление</h2>
<p>Пара слов о том, кто я, почему решил написать эту книгу и кому, кроме меня, она нужна.</p>

                            
                        
                    </article>
                
            
        </section>
        
    
        
        <section>
            <article id="integration/README.md" class="new-chapter">
                <h1>Интеграция</h1>
            </article>

            
                
                    <article id="integration/c-from-haskell.md">
                    
                            
                                <h2 id="-">Для кого</h2>
<p>Если вы дочитали до этого места — значит эта книга для вас. И не беспокойтесь об уровне своей квалификации: если вы уже знаете, что такое компилятор, зачем нужны пользовательские типы и чем объявление функции отличается от её определения — смело продолжайте читать.</p>
<p>Признаюсь вам: на момент написания этой книги я ещё не имел опыта разработки на Haskell и даже не завершил изучение этого языка. Многие удивятся: как же может человек, не имеющий весомого опыта и глубоких знаний в области функционального программирования, браться за написание книги о Haskell?!</p>
<p>Главное препятствие на пути популяризации этого языка (равно как и функционального программирования в целом) заключается в том, что рассказывающие о нём люди зачастую слишком далеки от обыкновенных разработчиков и от обыкновенных задач, решаемых этими разработчиками. И многие из нас, читая какой-нибудь труд, написанный аспирантом МФТИ, часто ловят себя на мысли, мол, куда уж мне до его мозгов...</p>
<p>Именно поэтому автор этой книги — самый обыкновенный программист. Я рассматриваю Haskell не как объект научного исследования, а как инструмент для решения моих повседневных задач. Таких как я — большинство. И если я смог ухватить суть этой функциональщины — значит и вы сможете.</p>
<p>Возможно, вы влюбитесь в этот язык. Возможно, он вызовет у вас отвращение. Могу обещать одно: скучно не будет.</p>
<p>Начнём.</p>

                            
                        
                    </article>
                
            
        </section>
        
    
        
        <section>
            <article id="end/README.md" class="new-chapter">
                <h1>Заключение</h1>
            </article>

            
                
                    <article id="end/is-this-end.md">
                    
                            
                                <h2 id="-">Для кого</h2>
<p>Если вы дочитали до этого места — значит эта книга для вас. И не беспокойтесь об уровне своей квалификации: если вы уже знаете, что такое компилятор, зачем нужны пользовательские типы и чем объявление функции отличается от её определения — смело продолжайте читать.</p>
<p>Признаюсь вам: на момент написания этой книги я ещё не имел опыта разработки на Haskell и даже не завершил изучение этого языка. Многие удивятся: как же может человек, не имеющий весомого опыта и глубоких знаний в области функционального программирования, браться за написание книги о Haskell?!</p>
<p>Главное препятствие на пути популяризации этого языка (равно как и функционального программирования в целом) заключается в том, что рассказывающие о нём люди зачастую слишком далеки от обыкновенных разработчиков и от обыкновенных задач, решаемых этими разработчиками. И многие из нас, читая какой-нибудь труд, написанный аспирантом МФТИ, часто ловят себя на мысли, мол, куда уж мне до его мозгов...</p>
<p>Именно поэтому автор этой книги — самый обыкновенный программист. Я рассматриваю Haskell не как объект научного исследования, а как инструмент для решения моих повседневных задач. Таких как я — большинство. И если я смог ухватить суть этой функциональщины — значит и вы сможете.</p>
<p>Возможно, вы влюбитесь в этот язык. Возможно, он вызовет у вас отвращение. Могу обещать одно: скучно не будет.</p>
<p>Начнём.</p>

                            
                        
                    </article>
                
            
                
                    <article id="end/gratitudes.md">
                    
                            
                                <h2 id="-">Зачем</h2>
<p>Функциональное программирование — это своеобразное гетто посреди мирового мегаполиса программной разработки. Доля функциональных языков на рынке очень мала, а программистов, использующих эти языки, считают либо недосягаемой элитой, либо асоциальными идиотами. Цель данной книги — разрушить такое представление.</p>
<p>В частности, я докажу ложность двух представлений о языке Haskell, а именно а) представление о колоссальной сложности его освоения и б) убеждение в том, что этот язык пригоден исключительно для научных лабораторий MIT.</p>
<p>Да, в прошлом оба эти представления соответствовали действительности. Haskell официально существует с 1990 года, однако его выход в &quot;широкий свет&quot; начался лишь в 2003. Таким образом, в течение 13 лет этот язык действительно был уделом лабораторий, и изучить его было нелегко, поскольку вся имеющаяся на тот момент документация по нему была напичкана математикой. Тогда язык был медленным. Тогда было мало библиотек. Однако то, что было актуально тогда, уже неактуально сегодня.</p>
<p>И ещё об ожиданиях. Не ждите от этой книги всеохватной полноты рассмотрения Haskell и его экосистемы. Кроме того, это не справочник. Я не буду копировать сюда всё содержимое официального сайта Haskell или переводить на русский язык стандарт Haskell 2010. Также здесь не приводится информация, которую госпожа Википедия выдаст вам в один момент (например, повествование об истории языка).</p>
<p>Цель этой книги — протянуть новичкам руку помощи в самом начале их пути.</p>
<pre><code class="lang-haskell"><span class="hljs-title">main</span> = putStrLn <span class="hljs-string">"Hi"</span>
</code></pre>

                            
                        
                    </article>
                
            
        </section>
        
    
        
        <section>
            <article id="appendix/README.md" class="new-chapter">
                <h1>Приложения</h1>
            </article>

            
                
                    <article id="appendix/useful-links.md">
                    
                            
                                <h2 id="-">Для кого</h2>
<p>Если вы дочитали до этого места — значит эта книга для вас. И не беспокойтесь об уровне своей квалификации: если вы уже знаете, что такое компилятор, зачем нужны пользовательские типы и чем объявление функции отличается от её определения — смело продолжайте читать.</p>
<p>Признаюсь вам: на момент написания этой книги я ещё не имел опыта разработки на Haskell и даже не завершил изучение этого языка. Многие удивятся: как же может человек, не имеющий весомого опыта и глубоких знаний в области функционального программирования, браться за написание книги о Haskell?!</p>
<p>Главное препятствие на пути популяризации этого языка (равно как и функционального программирования в целом) заключается в том, что рассказывающие о нём люди зачастую слишком далеки от обыкновенных разработчиков и от обыкновенных задач, решаемых этими разработчиками. И многие из нас, читая какой-нибудь труд, написанный аспирантом МФТИ, часто ловят себя на мысли, мол, куда уж мне до его мозгов...</p>
<p>Именно поэтому автор этой книги — самый обыкновенный программист. Я рассматриваю Haskell не как объект научного исследования, а как инструмент для решения моих повседневных задач. Таких как я — большинство. И если я смог ухватить суть этой функциональщины — значит и вы сможете.</p>
<p>Возможно, вы влюбитесь в этот язык. Возможно, он вызовет у вас отвращение. Могу обещать одно: скучно не будет.</p>
<p>Начнём.</p>

                            
                        
                    </article>
                
            
        </section>
        
    


    
    

        
    </body>
</html>
