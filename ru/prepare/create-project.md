Готовимся к работе
===============================================
С корабля на бал. Создаём настоящий проект и готовимся к реальной работе.

## Создаём проект

Мы не можем начать изучение языка без испытательного полигона. Поэтому скачайте и установите [Haskell Platform](http://www.haskell.org/platform/).

В состав Haskell Platform входит два важнейших компонента, о которых вам нужно знать:

1.  `ghc`, компилятор Haskell (Glasgow Haskell Compiler);
2.  `ghci`, интерпретатор Haskell.

Запомнили? А теперь можете забыть. Особенно про интерпретатор. Ведь вы планируете использовать Haskell в реальной работе, а это значит, все ваши проекты будут компилироваться. Да, интерпретатор  бывает полезен в ряде случаев, но без него вполне можно обойтись. Однако и непосредственное использование компилятора вам тоже едва ли понадобится.

В реальной работе вы не будете создавать файлик `Main.hs` на рабочем столе для последующего скармливания его компилятору. Напротив, вы создадите нормальный рабочий проект с логичной внутренней структурой. Так давайте и создадим такой с самого начала. А поможет нам в этом удобная утилита из Haskell Platform с необычным названием `cabal`. Эта утилита предназначена для сборки проектов. Уверен, вы слышали о вещах типа `cmake` или `qmake`, так вот воспринимайте `cabal` как `cmake` для Haskell.

Как вы уже поняли, `.hs` - стандартное расширение для файлов с исходным кодом на Haskell.

Начнём творить. Разумеется, все описываемые ниже действия подразумевают вашу крепкую дружбу с командной строкой. Я буду приводить Unix-овые команды, если же вы используете Windows - адаптируйте примеры под себя.

### Готовим структуру

Открываем терминал и творим:
```bash
$ mkdir -p Real/src/Utils
$ touch Real/src/Main.hs
$ touch Real/src/Utils/Helpers.hs
```
Итак, у нас появился каталог Real с привычной структурой: 
```bash
Real/
    src/
        Main.hs
        Utils/
            Helpers.hs
```
Есть корневой каталог `src`, внутри которой лежат все наши исходники, некоторым образом сгруппированные.

Кстати, об именах. Вам, вероятно, интересно, почему имена файлов и каталогов внутри каталога `src` начинаются с большой буквы? Чуть позже я объясню причину. А пока откроем файл `Main.hs` и напишем в нём:
```haskell
main = putStrLn "Hi, haskeller!"
```
Закрываем, возвращаемся в корень проекта.

### Настраиваем

Выполняем команду:
```bash
$ cabal init
```
Мы попадём в интерактивный диалог, в ходе которого нам будет предложено ответить на несколько вопросов о нашем проекте. В конце этого диалога будут автоматически созданы файлы проекта, и наш каталог приобретёт следующее содержимое:
```haskell
Real.cabal
Setup.hs
src/
    Main.hs
    Utils/
        Helpers.hs
```
Кстати, если вдруг вы увидите вот такое предупреждение:
```bash
Generating LICENSE...
Warning: unknown license type, you must put a copy in LICENSE yourself.
```
не беспокойтесь. Просто добавьте файл `LICENSE` вручную, для поддержания классического вида проекта.

Как уже было упомянуто, в корневом каталоге нашего проекта появились два новых файла, `Real.cabal` и `Setup.hs`. Второй файл нам не так интересен, а вот первый - это и есть сборочный файл нашего проекта. Откроем его:
```haskell
-- Initial Real.cabal generated by cabal init.  For further documentation,
-- see http://haskell.org/cabal/users-guide/

name:                Real
version:             0.1.0.0
synopsis:            Real project in Haskell
-- description:         
-- license:             
license-file:        LICENSE
author:              Denis Shevchenko
maintainer:          me@dshevchenko.biz
-- copyright:           
-- category:            
build-type:          Simple
cabal-version:       >=1.8

executable Real
  -- main-is:             
  -- other-modules:       
  build-depends:       base ==4.6.*
  hs-source-dirs:      src
```
Здесь уже сохранены те самые значения, которые мы вводили в процессе вышеупомянутого диалога. Однако собрать проект прямо сейчас мы не сможем, потому что строка:
```haskell
  -- main-is:
```
закомментирована. В этом файле принят синтаксис, подобный синтаксису Haskell, и поэтому однострочные комментарии здесь, как и в программном коде, начинаются с двух минусов подряд. Многострочный комментарий, который вам тоже понадобится, заключается между символами `{-` и `-}`.

Нам необходимо раскомментировать эту строку и прописать в ней имя файла `Main.hs`, содержащего функцию `main`:
```haskell
  main-is: Main.hs
```

### Конфигурируем

Выполняем:
```bash
$ cabal configure
```
В результате произойдёт подготовка проекта к сборке. Но прежде чем перейти к этой самой сборке, обращаю ваше внимание на последнюю часть файла `Real.cabal`:
```haskell
executable Real
  main-is:             Main.hs             
  -- other-modules:       
  build-depends:       base ==4.6.*
  hs-source-dirs:      src
```
Видите отступ в два пробела перед четырьмя последними строчками? Оказывается, этот отступ необходим, и без него проект не соберётся. Кроме того, отступ этот должен быть не менее двух пробелов. Я рекомендую четыре, для красоты.

И ещё одна деталь. Это необязательно, но лишним не будет. Допишем в секцию executable Real ещё одну строку:
```haskell
  ghc-options:         -W
```
Параметр `ghc-options` позволяет задавать флаги `ghc`. В частности, флаг `-W` вежливо попросит `ghc` показывать все основные предупреждения при компиляции. Не пренебрегайте этой возможностью.

### Собираем

Выполняем:
```bash
$ cabal build
Building Real-0.1.0.0...
Preprocessing executable 'Real' for Real-0.1.0.0...
[1 of 1] Compiling Main             ( src/Main.hs, dist/build/Real/Real-tmp/Main.o )
Linking dist/build/Real/Real ...
```
Готово. В нашем каталоге появилось кое-что новенькое:
```bash
LICENSE
Real.cabal
Setup.hs
dist/
    build/
        Real/
            Real  <- Это и есть исполняемый файл.
...
```
Остальное содержимое каталога `dist` нас пока не интересует.

### Запускаем

Пришло время запустить наше приложение. Находясь в корне проекта, выполняем:
```bash
$ ./dist/build/Real/Real
Hi haskeller!
```
Вот и всё. Теперь вы знаете, как создавать, настраивать и собирать Haskell-проект. Вероятно, вас интересует, зачем мы создавали файл `Helpers.hs` в подкаталоге `Utils`? Какой в нём смысл, если он всё равно остался пустым? В следующей главе вы это узнаете.

