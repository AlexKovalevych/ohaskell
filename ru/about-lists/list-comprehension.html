<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>List comprehension | О Haskell по-человечески</title>
        
        <link rel="stylesheet" type="text/css" href="../../css/default.css" />
        <link rel="icon" type="image/x-icon" href="../../images/favicon.ico" />
    </head>
    <body>
        <div id="wrapper">

            <div class="ribbon">
                <a href="https://github.com/denisshevchenko/ohaskell">Живу на GitHub</a>
            </div>

            <div id="wrapper_2">
            <div id="header">
                <div id="logo">
                    <a href="../../ru/index.html" title="Домой">О Haskell по-человечески</a><span class="logo-note">для обыкновенных программистов</span>
                </div>
                <div id="navigation">
                    <a href="../../ru/chapters.html">ОГЛАВЛЕНИЕ</a>
                </div>
            </div>

            

            <div id="content">
                <h1>List comprehension</h1>

                <div style="padding-top: 10px;"></div>

<div id="prev_arrow">
    <a href="../../ru/about-lists/tuples.html">❮</a>
</div>

<div id="next_arrow">
    <a href="../../ru/about-user-types/index.html">❯</a>
</div>

<p>Не удивляйтесь, что название этой главы не переведено на русский. Корректный перевод понятия “list comprehension” я так и не смог подобрать, долго размышлял - и в итоге решил оставить как есть. В русскоязычной литературе иногда предлагается вариант “преобразование списков”, но мне такой перевод кажется не вполне корректным.</p>
<p>Речь пойдёт об одной хитрой конструкции, предназначенной для прохода по элементам списка(ов) и применения к ним некоторых действий. Да-да, это похоже на уже известные нам функции <code>map</code> и <code>filter</code>, однако есть некоторые дополнительные вкусности.</p>
<h2 id="хитрый-список">Хитрый список</h2>
<p>Вот как это выглядит:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Char</span> 

main <span class="fu">=</span> print [toUpper c <span class="fu">|</span> c <span class="ot">&lt;-</span> <span class="st">&quot;http&quot;</span>]</code></pre>
<p>На выходе получим:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="st">&quot;HTTP&quot;</span></code></pre>
<p>Рассмотрим поближе:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">[toUpper c <span class="fu">|</span> c <span class="ot">&lt;-</span> <span class="st">&quot;http&quot;</span>]</code></pre>
<p>Мы видим квадратные скобки… То есть перед нами список? Не совсем. Можно сказать, что перед нами генератор списка. Скелет такой конструкции можно представить так:</p>
<pre><code>[OPERATION ELEM | ELEM &lt;- LIST] </code></pre>
<p>где <code>LIST</code> - список, <code>ELEM</code> - элемент этого списка, а <code>OPERATION</code> - функция, применяемая к каждому элементу. Мы говорим: “Возьми список <code>LIST</code>, последовательно пройдись по всем его элементам и примени к каждому из них функцию <code>OPERATION</code>”. В результате значения, возвращаемые функцией <code>OPERATION</code>, породят новый список.</p>
<p>В данном случае мы пройдём по всем символам строки <code>http</code> и применим к каждому из её символов функцию <code>toUpper</code>, которая в свою очередь переведёт этот символ в верхний регистр. В результате мы получим новую строку <code>&quot;HTTP&quot;</code>.</p>
<h2 id="добавляем-предикат">Добавляем предикат</h2>
<p>Мы можем добавить предикат в эту конструкцию. Тогда её скелет станет таким:</p>
<pre><code>[OPERATION ELEM | ELEM &lt;- LIST, PREDICATE]</code></pre>
<p>В этом случае мы говорим: “Возьми список <code>LIST</code>, последовательно пройдись по всем его элементам и примени функцию <code>OPERATION</code> только к тем элементам, которые удовлетворят предикату <code>PREDICATE</code>”.</p>
<p>Например:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Char</span>

main <span class="fu">=</span> print [toUpper c <span class="fu">|</span> c <span class="ot">&lt;-</span> <span class="st">&quot;http&quot;</span>, c <span class="fu">==</span> <span class="ch">'t'</span>]</code></pre>
<p>На выходе будет:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="st">&quot;TT&quot;</span></code></pre>
<p>Мы прошлись по всем четырём символам строки <code>http</code>, но функция <code>toUpper</code> была применена только к тем символам, которые удовлетворили предикату <code>c == 't'</code>. Именно поэтому на выходе мы получили строку лишь из этих двух символов.</p>
<p>Предикатов, кстати, может быть несколько. Например, так:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Char</span>

main <span class="fu">=</span> print [toUpper c <span class="fu">|</span> c <span class="ot">&lt;-</span> <span class="st">&quot;http&quot;</span>, c <span class="fu">/=</span> <span class="ch">'h'</span>, c <span class="fu">/=</span> <span class="ch">'p'</span>]</code></pre>
<p>Вывод в этом случае будет таким же:  </p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="st">&quot;TT&quot;</span></code></pre>
<p>Здесь два предиката, <code>c /= 'h'</code> и <code>c /= 'p'</code>. Они соединяются в единый предикат через логическое “И”, поэтому мы можем написать и так:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">[toUpper c <span class="fu">|</span> c <span class="ot">&lt;-</span> <span class="st">&quot;http&quot;</span>, c <span class="fu">/=</span> <span class="ch">'h'</span> <span class="fu">&amp;&amp;</span> c <span class="fu">/=</span> <span class="ch">'p'</span>]</code></pre>
<p>Результат будет таким же.</p>
<p>Обратите внимание на комбинацию символов <code>/=</code>. Это функция проверки на неравенство, аналог оператора <code>!=</code> в языке C. Кстати, он тоже носит математический окрас. Сравните:</p>
<pre><code>/=   -- Haskell-форма
≠    -- математическая форма</code></pre>
<p>Симпатично, не правда ли? Прямое сходство, мы лишь передвинули перечеркивающую косую палочку.</p>
<h2 id="больше-списков">Больше списков</h2>
<p>Мы можем использовать эту конструкцию для совместной работы с несколькими списками. Скелет в этом случае будет таким:</p>
<pre><code>[OPERATION_with_ELEMs | ELEM1 &lt;- LIST1, ..., ELEMN &lt;- LISTN ] </code></pre>
<p>Здесь мы работаем сразу с <code>N</code> списками, а <code>OPERATION_with_ELEMs</code> представляет собой функцию, в которую передаются все элементы наших списков. Например:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span>
    print [prefix <span class="fu">++</span> name <span class="fu">|</span> name <span class="ot">&lt;-</span> names, prefix <span class="ot">&lt;-</span> namePrefix]
    where names <span class="fu">=</span> [<span class="st">&quot;James&quot;</span>, <span class="st">&quot;Victor&quot;</span>, <span class="st">&quot;Denis&quot;</span>, <span class="st">&quot;Michael&quot;</span>]
          namePrefix <span class="fu">=</span> [<span class="st">&quot;Mr. &quot;</span>]</code></pre>
<p>На выходе получим:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">[<span class="st">&quot;Mr. James&quot;</span>,<span class="st">&quot;Mr. Victor&quot;</span>,<span class="st">&quot;Mr. Denis&quot;</span>,<span class="st">&quot;Mr. Michael&quot;</span>]</code></pre>
<p>Мы последовательно прошлись по всем элементам списков <code>names</code> и <code>namePrefix</code>. Обратите внимание, в списке <code>namePrefix</code> лишь один префикс. Вот что будет, если префиксов два:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span>
    print [prefix <span class="fu">++</span> name <span class="fu">|</span> name <span class="ot">&lt;-</span> names, prefix <span class="ot">&lt;-</span> namePrefix]
    where names <span class="fu">=</span> [<span class="st">&quot;James&quot;</span>, <span class="st">&quot;Victor&quot;</span>, <span class="st">&quot;Denis&quot;</span>, <span class="st">&quot;Michael&quot;</span>]
          namePrefix <span class="fu">=</span> [<span class="st">&quot;Mr. &quot;</span>, <span class="st">&quot;sir &quot;</span>]  <span class="co">-- Теперь префиксов два</span></code></pre>
<p>В этом случае на выходе будет:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">[<span class="st">&quot;Mr. James&quot;</span>,<span class="st">&quot;sir James&quot;</span>,<span class="st">&quot;Mr. Victor&quot;</span>,<span class="st">&quot;sir Victor&quot;</span>,<span class="st">&quot;Mr. Denis&quot;</span>,<span class="st">&quot;sir Denis&quot;</span>,<span class="st">&quot;Mr. Michael&quot;</span>,<span class="st">&quot;sir Michael&quot;</span>]</code></pre>
<p>В этом случае мы последовательно использовали <em>каждый</em> элемент из списка <code>names</code> и <em>каждый</em> элемент из списка <code>namePrefix</code>.</p>
<h2 id="добавляем-условие">Добавляем условие</h2>
<p>Предикат не всегда применим к элементам списка. В ряде случаев нам нужно условие. Добавим его:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span>
    print [<span class="kw">if</span> car <span class="fu">==</span> <span class="st">&quot;Bentley&quot;</span> <span class="kw">then</span> <span class="st">&quot;Wow!&quot;</span> <span class="kw">else</span> <span class="st">&quot;Good!&quot;</span> <span class="fu">|</span> car <span class="ot">&lt;-</span> cars]
    where cars <span class="fu">=</span> [<span class="st">&quot;Mercedes&quot;</span>,
                  <span class="st">&quot;BMW&quot;</span>,
                  <span class="st">&quot;Bentley&quot;</span>,
                  <span class="st">&quot;Audi&quot;</span>,
                  <span class="st">&quot;Bentley&quot;</span>]</code></pre>
<p>Результат:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">[<span class="st">&quot;Good!&quot;</span>,<span class="st">&quot;Good!&quot;</span>,<span class="st">&quot;Wow!&quot;</span>,<span class="st">&quot;Good!&quot;</span>,<span class="st">&quot;Wow!&quot;</span>]</code></pre>
<p>Мы прошлись по списку марок автомобилей и применили к каждой из них условие, которое вернуло строку <code>&quot;Wow!&quot;</code> или строку <code>&quot;Good!&quot;</code>.</p>
<h2 id="добавляем-локальное-выражение">Добавляем локальное выражение</h2>
<p>Мы можем добавить сюда и локальное выражение с помощью уже известного нам <code>let</code>. Например так:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Char</span>

main <span class="fu">=</span> print [toUpper c <span class="fu">|</span> c <span class="ot">&lt;-</span> <span class="st">&quot;http&quot;</span>,
                          let hletter <span class="fu">=</span> <span class="ch">'h'</span> <span class="kw">in</span> c <span class="fu">/=</span> hletter]</code></pre>
<p>Промежуточное значение может быть использовано во избежание дубляжа при наличии нескольких предикатов.</p>
<h2 id="пример">Пример</h2>
<p>Разберём более практичный пример:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.List</span>

<span class="ot">checkGooglerBy ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
checkGooglerBy email <span class="fu">=</span>
    if <span class="st">&quot;gmail.com&quot;</span> <span class="ot">`isSuffixOf`</span> email
    then nameFrom email <span class="fu">++</span> <span class="st">&quot; is a Googler!&quot;</span>
    else email
    where nameFrom fullEmail <span class="fu">=</span> takeWhile (<span class="fu">/=</span> <span class="ch">'@'</span>) fullEmail

main <span class="fu">=</span> print [checkGooglerBy email <span class="fu">|</span> email <span class="ot">&lt;-</span> [<span class="st">&quot;adam@gmail.com&quot;</span>,
                                               <span class="st">&quot;bob@yahoo.com&quot;</span>,
                                               <span class="st">&quot;richard@gmail.com&quot;</span>,
                                               <span class="st">&quot;elena@yandex.ru&quot;</span>,
                                               <span class="st">&quot;denis@gmail.com&quot;</span>]]</code></pre>
<p>Результат:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">[<span class="st">&quot;adam is a Googler!&quot;</span>,<span class="st">&quot;bob@yahoo.com&quot;</span>,<span class="st">&quot;richard is a Googler!&quot;</span>,<span class="st">&quot;elena@yandex.ru&quot;</span>,<span class="st">&quot;denis is a Googler!&quot;</span>]</code></pre>
<p>Мы проанализировали список email-адресов, и заменили все gmail-адреса фразой, начинающейся с имени пользователя.</p>
<p>Рассмотрим эту строку:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">takeWhile (<span class="fu">/=</span> <span class="ch">'@'</span>) fullEmail</code></pre>
<p>Скелет стандартной функции <code>takeWhile</code> можно отобразить так:</p>
<pre><code>takeWhile PREDICATE LIST </code></pre>
<p>Здесь мы говорим: “Последовательно забирай (take) элементы из списка <code>LIST</code> до тех пор (While), пока <code>PREDICATE</code>, применённый к этим элементам, возвращает <code>True</code>. Если наткнёшься на элемент, не соответствующий этому предикату, немедленно прекращай работу и возвращай список из ранее полученных элементов”. Нам нужно извлечь имя пользователя из его email-адреса, а значит, мы бежим по email до тех пор, пока символы не равны <code>'@'</code>, что и отражается предикатом <code>(/= '@')</code>. Как только натыкаемся на собачку - возвращаем всё, находящееся перед ней.</p>
<h2 id="в-сухом-остатке">В сухом остатке</h2>
<ul>
<li>List comprehension - это конструкция, порождающая новый список из одного или нескольких имеющихся списов.</li>
<li>Новый список порождается в результате применения различных функций к элементам имеющегося списка/списков.</li>
</ul>

<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'ohaskell'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
 

            </div>
            
            <div id="footer">
                <div id="social">
                    © Денис Шевченко 2013-2014
                </div>
                <div id="hakyll_mark">
                    Книга создана с помощью <a href="http://jaspervdj.be/hakyll">Hakyll</a>
                </div>
            </div>

            <div id="search_form">
                <script>
                  (function() {
                    var cx = '007697214108744450483:au850gpbupm';
                    var gcse = document.createElement('script');
                    gcse.type = 'text/javascript';
                    gcse.async = true;
                    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
                        '//www.google.com/cse/cse.js?cx=' + cx;
                    var s = document.getElementsByTagName('script')[0];
                    s.parentNode.insertBefore(gcse, s);
                  })();
                </script>
                <gcse:search></gcse:search>
            </div>
            </div>
        </div>
    </body>
</html>
