List comprehension
------------------

Не удивляйтесь, что название этой главы не переведено на русский. Корректный перевод понятия "list comprehension" я так и не смог подобрать, долго размышлял - и в итоге решил оставить как есть. В русскоязычной литературе иногда предлагается вариант "преобразование списков", но мне такой перевод кажется не вполне корректным.

Речь пойдёт об одной хитрой конструкции, предназначенной для прохода по элементам списка(ов) и применения к ним некоторых действий. Да-да, это похоже на уже известные нам функции `map` и `filter`, но есть некоторые дополнительные вкусности.

### Хитрый список

Вот как это выглядит:

```haskell
import Data.Char 

main = print [toUpper c | c <- "http"]
```

На выходе получим:

```bash
"HTTP"
```

Рассмотрим поближе:

```haskell
[toUpper c | c <- "http"]
```

Мы видим квадратные скобки... То есть перед нами список? Не совсем. Можно сказать, что перед нами генератор списка. Скелет такой конструкции можно представить так:

    [OPERATION ELEM | ELEM <- LIST] 

где `LIST` - список, `ELEM` - элемент этого списка, а `OPERATION` - функция, применяемая к каждому элементу. Мы говорим: "Возьми список `LIST`, последовательно пройдись по всем его элементам и примени к каждому из них функцию `OPERATION`". В результате значения, возвращаемые функцией `OPERATION`, породят новый список.

В данном случае мы пройдём по всем символам строки `http` и применим к каждому из её символов функцию `toUpper`, которая в свою очередь переведёт этот символ в верхний регистр. В результате мы получим новую строку `"HTTP"`.

### Добавляем предикат

Мы можем добавить предикат в эту конструкцию. Тогда её скелет станет таким:

    [OPERATION ELEM | ELEM <- LIST, PREDICATE]

В этом случае мы говорим: "Возьми список `LIST`, последовательно пройдись по всем его элементам и примени функцию `OPERATION` только к тем элементам, которые удовлетворят предикату `PREDICATE`".

Например:

```haskell
import Data.Char

main = print [toUpper c | c <- "http", c == 't']
``` 

На выходе будет:

```bash
"TT"
``` 

Мы прошлись по всем четырём символам строки `http`, но функция `toUpper` была применена только к тем символам, которые удовлетворили предикату `c == 't'`. Именно поэтому на выходе мы получили строку лишь из этих двух символов.

Предикатов, кстати, может быть несколько. Например, так:

```haskell
import Data.Char

main = print [toUpper c | c <- "http", c /= 'h', c /= 'p']
```

Вывод в этом случае будет таким же:
 
```bash
"TT"
```

Здесь два предиката, `c /= 'h'` и `c /= 'p'`. Они соединяются в единый предикат через логическое "И", поэтому мы можем написать и так:

```haskell
[toUpper c | c <- "http", c /= 'h' && c /= 'p']
``` 

Результат будет таким же.

Обратите внимание на комбинацию символов `/=`. Это функция проверки на неравенство, аналог оператора `!=` в языке C. Кстати, он тоже носит математический окрас. Сравните:

    /=   -- Haskell-форма
    ≠    -- математическая форма

Симпатично, не правда ли? Прямое сходство, мы лишь передвинули перечеркивающую косую палочку.

### Больше списков

Мы можем использовать эту конструкцию для совместной работы с несколькими списками. Скелет в этом случае будет таким:

    [OPERATION_with_ELEMs | ELEM1 <- LIST1, ..., ELEMN <- LISTN ] 

Здесь мы работаем сразу с `N` списками, а `OPERATION_with_ELEMs` представляет собой функцию, в которую передаются все элементы наших списков. Например:

```haskell
main =
    print [prefix ++ name | name <- names, prefix <- namePrefix]
    where names = ["James", "Victor", "Denis", "Michael"]
          namePrefix = ["Mr. "]
```

На выходе получим:

```bash
["Mr. James","Mr. Victor","Mr. Denis","Mr. Michael"]
```

Мы последовательно прошлись по всем элементам списков `names` и `namePrefix`. Обратите внимание, в списке `namePrefix` лишь один префикс. Вот что будет, если префиксов два:

```haskell
main =
    print [prefix ++ name | name <- names, prefix <- namePrefix]
    where names = ["James", "Victor", "Denis", "Michael"]
          namePrefix = ["Mr. ", "sir "]  -- Теперь префиксов два
```

В этом случае на выходе будет:

```bash
["Mr. James","sir James","Mr. Victor","sir Victor","Mr. Denis","sir Denis","Mr. Michael","sir Michael"]
```

В этом случае мы последовательно использовали _каждый_ элемент из списка `names` и _каждый_ элемент из списка `namePrefix`.

### Добавляем условие

Предикат не всегда применим к элементам списка. В ряде случаев нам нужно условие. Добавим его:

```haskell
main =
    print [if car == "Bentley" then "Wow!" else "Good!" | car <- cars]
    where cars = ["Mercedes",
                  "BMW",
                  "Bentley",
                  "Audi",
                  "Bentley"]
```

Результат:

```bash
["Good!","Good!","Wow!","Good!","Wow!"]
```

Мы прошлись по списку марок автомобилей и применили к каждой из них условие, которое вернуло строку `"Wow!"` или строку `"Good!"`.

### Добавляем локальное выражение

Мы можем добавить сюда и локальное выражение с помощью уже известного нам `let`. Например так:

```haskell
import Data.Char

main = print [toUpper c | c <- "http",
                          let hletter = 'h' in c /= hletter]
```

Промежуточное значение может быть использовано во избежание дубляжа при наличии нескольких предикатов.

### Пример

Разберём более практичный пример:

```haskell
import Data.List

checkGooglerBy :: String -> String
checkGooglerBy email =
    if "gmail.com" `isSuffixOf` email
    then nameFrom email ++ " is a Googler!"
    else email
    where nameFrom fullEmail = takeWhile (/= '@') fullEmail

main = print [checkGooglerBy email | email <- ["adam@gmail.com",
                                               "bob@yahoo.com",
                                               "richard@gmail.com",
                                               "elena@yandex.ru",
                                               "denis@gmail.com"]]
```

Результат:

```haskell
["adam is a Googler!","bob@yahoo.com","richard is a Googler!","elena@yandex.ru","denis is a Googler!"]
```

Мы проанализировали список email-адресов, и заменили все gmail-адреса фразой, начинающейся с имени пользователя.

Рассмотрим эту строку:

```haskell
takeWhile (/= '@') fullEmail
```

Скелет стандартной функции `takeWhile` можно отобразить так:

    takeWhile PREDICATE LIST 

Здесь мы говорим: "Последовательно забирай (take) элементы из списка `LIST` до тех пор (While), пока `PREDICATE`, применённый к этим элементам, возвращает `True`. Если наткнёшься на элемент, не соответствующий этому предикату, немедленно прекращай работу и возвращай список из ранее полученных элементов". Нам нужно извлечь имя пользователя из его email-адреса, а значит, мы бежим по email до тех пор, пока символы не равны `'@'`, что и отражается предикатом `(/= '@')`. Как только натыкаемся на собачку - возвращаем всё, находящееся перед ней.

### В сухом остатке

* List comprehension - это конструкция, порождающая новый список из одного или нескольких имеющихся списов.
* Новый список порождается в результате применения различных функций к элементам имеющегося списка/списков.

### Пробуем

Код из этой главы доступен онлайн.

<span><a href="https://www.fpcomplete.com/ide?title=list-comprehension&paste=https://raw.githubusercontent.com/denisshevchenko/ohaskell-code/master/code/about-lists/list-comprehension/Main.hs" class="fpcomplete_code" target="_blank">Открыть в FP IDE</a></span>
<span class="buttons_space"></span>
<span><a href="https://github.com/denisshevchenko/ohaskell-code/blob/master/code/about-lists/list-comprehension/Main.hs" class="github_code" target="_blank">Открыть на GitHub</a></span>

