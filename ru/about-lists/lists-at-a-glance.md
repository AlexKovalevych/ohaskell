Списки - одним взглядом
-----------------------

Списки в Haskell - это наборы элементов одного типа. И когда вы видите в коде квадратные скобки - значит, список где-то рядом.

Вот список из трёх целочисленных элементов:
 
```haskell
[1, 2, 3]
```

а вот пустой список:

```haskell
[]
``` 

Элементами списка могут быть значения любого типа, в том числе и другие списки. Мы даже можем создать список функций, но после прочтения предыдущих глав вас этот факт не должен удивлять.

### Простейшие действия

Если списки создаются - значит это кому-нибудь нужно. Вот функция, возвращающая список из трёх строк:

```haskell
listOfNames :: String -> [String]
listOfNames prefix = 
    [prefix ++ "John", prefix ++ "Anna", prefix ++ "Andrew"]

main = print $ listOfNames "Dear "
``` 

Результат:

```bash
["Dear John","Dear Anna","Dear Andrew"]
```

Обратите внимание на объявление этой функции:

```haskell
listOfNames :: String -> [String]
```

Тип `[String]` - это тип списка строк. А, например, список символов объявляется как `[Char]`. Кстати, строка - это и есть список символов, то есть тип `String` эквивалентен типу `[Char]`. Поэтому объявление может быть и таким:

```haskell
listOfNames :: String -> [[Char]]  -- Возвращает список списков символов.
```

Вот так можно узнать размер списка:

```haskell
main =
    print $ length listOfAnimals
    where listOfAnimals = ["Bear", "Tiger", "Lion", "Wolf"]
```

А так можно узнать, присутствует ли заданное значение в списке:

```haskell
thisIsAWildAnimal :: String -> Bool
thisIsAWildAnimal name =
    name `elem` wildAnimals
    where wildAnimals = ["Bear", "Tiger", "Lion", "Wolf"]

main = print $ if thisIsAWildAnimal "Cat" then "Yes!" else "No!"
```

Здесь функция стандартная функция `elem`, записанная в инфиксной форме (то есть между двумя своими аргументами), проверяет наличие строки `"Cat"` в списке диких животных.

Стандартная библиотека Haskell позволяет делать со списком самые разные вещи, такие как получение минимального значения, вычисления суммы элементов, извлечение части списка, проверка на пустоту и равенство и так далее и в том же духе.

### Неизменность списка

Как вы знаете, все значения в Haskell неизменны, как Египетские пирамиды. Списки - не исключение: мы не можем изменить список, мы можем лишь создать на его основе новый список. Например:

```haskell
addNewHostToFront :: String -> [String] -> [String]
addNewHostToFront newHost listOfHosts = newHost : listOfHosts

main =
    print $ addNewHostToFront "124.67.54.90" listOfHosts
    where listOfHosts = ["45.67.78.89", "123.45.65.54", "127.0.0.1"]
```

Вывод:
 
```bash
["124.67.54.90","45.67.78.89","123.45.65.54","127.0.0.1"]
```

С концептуальной точки зрения функция `addNewHostToFront` добавила новый адрес в начало переданного ей списка. Но в действительности никакого добавления не произошло: функция просто взяла значение `newHost` и список `listOfHosts` и создала на их основе новый список, содержащий уже четыре адреса вместо трёх.

### Действия над элементами

Мы создаём список для того, чтобы что-то делать с его элементами. Например, такая функция:

```haskell
removeAllEmptyNamesFrom :: [String] -> [String]
removeAllEmptyNamesFrom listOfNames =
    filter notEmptyName listOfNames
    where notEmptyName = not . null 

main =
    print $ removeAllEmptyNamesFrom listOfNames
    where listOfNames = ["John", "", "Ann"]
```

Стандартная функция `filter` последовательно применяет предикат `notEmptyName` к каждой строке в списке и конструирует новый список лишь из тех строк, которые удовлетворяют этому предикату. В качестве предиката выступает функция, применяющаяся к одной строке и возвращающая значение `True` только в том случае, если эта строка не `null` (то есть непустая). Обратите внимание, мы вновь использовали короткую форму записи функции notEmptyName, опустив имя аргумента. 

Вот и всё. Помимо функций `map` и `filter`, в стандартной библиотеке Haskell есть и многие другие вкусности для работы с элементами (проверки, замены, сортировки, перестановки и тому подобное).

