Типы - одним взглядом
---------------------

В настоящих проектах нам обязательно понадобятся наши собственные типы. О них и поговорим.

Прежде всего познакомимся с новыми ключевыми словами. Слово `data` служит для определения типа. Слово `class` используется для определения класса типов. А слово `instance` необходимо для определения экземпляра класса типов.

### Собственный тип

Определим тип для IP-адреса:
 
```haskell
data IPAddress = IPAddress String
```

Готово. Перед нами - простейший пользовательский тип. Значение этого типа фактически будет представлять собой значение типа `String` с меткой `IPAddress`. Рассматривайте метку как пояснительный идентификатор. Многие типы не имеют метки, поэтому их можно инициализировать значениями непосредственно. Например, если у нас есть некая функция, принимающая значение типа Int, то при её вызове мы будем писать просто:

```haskell
show 6
```

Однако если эта же функция будет применена к значению нашего типа `IPAddress`, мы должны будем явно указать это:

```haskell
show $ IPAddress "127.0.0.1"
```

Выражение `IPAddress "127.0.0.1"` породит значение типа `IPAddress`, содержащее в себе строку `"127.0.0.1"`.

Кстати, метку принято называть конструктором значения.

Запомните: имя типа не может начинаться с маленькой буквы. Поэтому такой код:

```haskell
data ipAddress = ipAddress String
```

будет отвергнут компилятором.

### Класс типов

Проблема в том, что тип `IPAddress` в его нынешнем виде настолько примитивен, что не представляет для нас большого интереса. Мы, создав значение этого типа, даже не сможем вывести его на экран. И если мы прямо сейчас напишем так:

```haskell
main = putStrLn $ show $ IPAddress "127.0.0.1"
```

компилятор выдаст нам следующее:

```bash
No instance for (Show IPAddress) arising from a use of `show'
```

И мы не имеем права обижаться на компилятор, он поступил совершенно правильно: стандартная функция `show`, преобразующая переданный ей аргумент в строковый вид, не имеет ни малейшего понятия о том, как представить объект типа `IPAddress` в виде строки. И она не узнает это до тех пор, пока мы явно не расскажем ей об этом. Вот тут-то и выходят на сцену классы типов.

Класс типов - это логическая группа типов. Она несёт в себе черты, общие для всех этих типов. А чертами этими являются методы, объявленные в данном классе, и каждый тип, имеющий к этому классу отношение, должен предоставлять свою реализацию этих методов. Класс типов можно рассматривать как абстрактный интерфейс.

Например, стандартный класс типов `Show`. Он обобщает все типы, объекты которых могут быть "показаны" (shown), то есть отображены в виде стандартной строки. Вот определение этого класса:

```haskell
class Show a where
    show :: a -> String
```

Здесь присутствует один-единственный метод `show`, принимающий в качестве аргумента объект типа a и возвращающий строковое отображение этого объекта.

Вы спросите, что это за тип такой - `a`? Ранее я уже упоминал термин полиморфный тип, так вот обозначенное буквой `a` - это он и есть. Благодаря этому метод `show` может применяться к значениям самых разных типов. Программисты из мира C++ сразу вспомнят шаблоны... По сложившейся традиции полиморфные типы принято именовать одной буквой, однако вы можете называть их как угодно.

Но откуда же метод `show` узнаёт, как ему стрингифицировать объект конкретного типа? Ведь мы можем применить его к объектам разных типов, для которых понятие "показать" может иметь абсолютно разный смысл. Встречайте экземпляр класса типов.

### Экземпляр класса типов

Если класс типов `Show` - это логическая группа для типов, объекты которых можно показать, то экземпляр класса типов `Show` - это реальное объяснение того, _как_ можно показать объект того или иного типа. И если мы хотим показывать объекты нашего типа `IPAddress`, мы обязаны предоставить экземпляр класса типов `Show` для типа `IPAddress`. Сделаем же это:

```haskell
instance Show IPAddress where
    show (IPAddress address) =
        if address == "127.0.0.1" then "localhost" else address
```

Мы использовали ключевое слово `instance`, а полиморфный тип `a` заменили на тип `IPAddress`. Далее следует определение метода `show`, которое и объясняет, как отобразить значение типа `IPAddress` в виде строки. Этот метод принимает объект типа `IPAddress`, порождённый выражением `IPAddress address`. Далее следует простое условие, выводящее слово `"localhost"` в том случае, если адрес равен `"127.0.0.1"`.

А теперь пишем:

```haskell
main = putStrLn $ show $ IPAddress "127.0.0.1"
```

И получаем ожидаемый вывод:

```bash
localhost
```

### В сухом остатке

* Если видим слово `data` - перед нами пользовательский тип.
* Класс типов - это абстрактный интерфейс, отражающий некие общие черты для набора типов.
* Каждый тип, желающий породниться с неким классом, предоставляет свой экземпляр этого класса, определяя его методы на свой лад.

### Пробуем

Код из этой главы доступен онлайн.

<span><a href="https://www.fpcomplete.com/ide?title=types-at-a-glance&paste=https://raw.githubusercontent.com/denisshevchenko/ohaskell-code/master/code/about-user-types/types-at-a-glance/Main.hs" class="fpcomplete_code" target="_blank">Открыть в FP IDE</a></span>
<span class="buttons_space"></span>
<span><a href="https://github.com/denisshevchenko/ohaskell-code/blob/master/code/about-user-types/types-at-a-glance/Main.hs" class="github_code" target="_blank">Открыть на GitHub</a></span>

