<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content>
        <meta name="author" content="Денис Шевченко">
        <link rel="icon" href="../../static/images/favicon.ico">

        <title>Чистые функции</title>

        <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>

        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">

        <link href="../../static/css/default.css" rel="stylesheet">
        
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>

        <script>
          window.___gcfg = {
            lang: 'ru'
          };
        </script>

        <script src="https://apis.google.com/js/platform.js" async defer>
        </script>
    </head>

  <body>
    <div class="container">
        <nav class="navbar navbar-default navbar-fixed-top">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <div id="logo">
                <a class="navbar-brand" href="../../ru/index.html" title="Домой">
                  О Haskell по-человечески
                </a>
              </div>
            </div>
            
            <div id="navbar" class="collapse navbar-collapse">
              <ul class="nav navbar-nav navbar-right">
                <li><a href="../../ru/chapters.html">Оглавление</a></li>
              </ul>
            </div>
          </div>
        </nav>

        <div id="content">
            <h1>Чистые функции</h1>

            <p>Раз уж Haskell - чисто функциональный язык программирования, поговорим о чистых функциях, как об одном из краеугольных камней этого языка.</p>
<p>Для начала вспомним школьный курс математики и сформулируем простейшее определение функции:</p>
<blockquote>
<p><strong>Функция - это описание зависимости чего-то от чего-то.</strong></p>
</blockquote>
<p>Так вот чистые функции в Haskell - это и есть функции в математическом смысле. Они представляют собой описание того, как входное значение определяет выходное значение.</p>
<p>Отсюда вытекает важнейшая характеристика чистых функций, а именно отсутствие побочных эффектов. Значение на входе чистой функции всецело и полностью определяет значение на выходе. Поэтому если мы миллион раз подадим на вход одно и то же значение, то на выходе мы миллион раз гарантированно получим один и тот же результат.</p>
<h2 id="объявляем">Объявляем</h2>
<p>Как и во многих других языках программирования, функцию сначала нужно объявить. Сделаем же это:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">simpleSum ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></code></pre>
<p>До символа <code>::</code> указывается имя функции, а после - тип.</p>
<pre><code>simpleSum :: Int -&gt; Int
|       |    |        |
   имя          тип </code></pre>
<p>Я понимаю, словосочетание “тип функции” звучит странно, но в мире Haskell так: чистая функция - это значение, имеющее тип функции. Рассмотрим описание этого типа:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></code></pre>
<p>Обратите внимание на стрелочку. Именно эта стрелочка и говорит нам о том, что перед нами - чистая функция. Слева от неё указан тип единственного аргумента (в данном случае это стандартный тип <code>Int</code>), а справа от неё - тип выходного значения (тот же <code>Int</code>). Саму же стрелочку можно воспринимать как ментальное указание на поток информации, движущийся через функцию: от её входа к выходу, слева направо.</p>
<p>Напоминаю, что чистая функция обязана иметь хотя бы один аргумент и обязана что-то возвращать, ведь это и отражает суть математической функции: что-то обязательно подаём на вход и что-то обязательно получаем на выходе.</p>
<p>Кстати, о количестве аргументов. Разумеется, чистая функция может принимать и несколько аргументов. Вот тип функции, принимающей три аргумента:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></code></pre>
<p>Читать эту запись следует так: ищем последнюю по счёту (самую правую) стрелочку - она-то и будет тем самым разделителем: слева от неё идёт список типов аргументов, справа - тип возвращаемого выражения:</p>
<pre><code>Int -&gt; Int -&gt; Int -&gt; Int
типы аргументов  |  |тип возвращаемого значения</code></pre>
<h2 id="определяем">Определяем</h2>
<p>Теперь функцию необходимо определить. Кстати, определить нужно обязательно. Например, в языке C или C++ мы можем спокойно объявить функцию и не определять её (при условии, что она никогда не вызывается). В Haskell более строгий подход: если объявил функцию - будь добр и определить её, в противном случае компилятор выскажет своё категорическое недовольство.</p>
<p>Поэтому сразу же после объявления пишем определение:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">simpleSum ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
simpleSum value <span class="fu">=</span> value <span class="fu">+</span> value</code></pre>
<p>Здесь ментальным разделителем является знак равенства. Скелет данного выражения можно представить так:</p>
<pre><code>NAME ARGUMENTS = BODY_EXPRESSION </code></pre>
<p>где <code>NAME</code> - имя функции, <code>ARGUMENTS</code> - список имён аргументов (имён, а не типов), а <code>BODY_EXPRESSION</code> - тело функции. В данном случае у нас имеется один-единственный аргумент по имени <code>value</code>, а также имеется простое тело, в котором мы просто складываем аргумент с самим собой.</p>
<h2 id="вызываем">Вызываем</h2>
<p>Теперь нашу функцию можно вызывать. Сделаем же это с аргументом <code>4</code>, или, как принято говорить в мире ФП, применим нашу функцию к аргументу <code>4</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> putStrLn (show (simpleSum <span class="dv">4</span>))</code></pre>
<p>Стандартная функция <code>putStrLn</code> выводит строку на экран с завершающим <code>\n</code>. Результат выполнения этого кода вполне ожидаем:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">8</span></code></pre>
<p>Готово. А теперь необходимо уточнить некоторые важные детали.</p>
<h2 id="выход-из-функции">Выход из функции</h2>
<p>В языке C, если у нас есть функция с возвращаемым значением, мы обязаны где-то в её теле указать точку выхода с помощью инструкции <code>return</code>. Кроме того, точек выхода может быть несколько.</p>
<p>В Haskell всё обстоит совершенно иначе. Во-первых, точка выхода из чистой функции может быть только одна, а во-вторых, аналога инструкции <code>return</code> в Haskell нет. И если мы вспомним математическую природу чистой функции, то поймём, что иначе и быть не может. Ведь чистая функция представляет собой описание зависимости выходного значения от входных значений, поэтому её тело представляет собой совокупность выражений, которые вычисляются и в конечном итоге оставляют одно-единственное, последнее выражение. Так вот это последнее выражение и будет являться “точкой выхода” из функции.</p>
<p>Приведу пример:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">indicate ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
indicate address <span class="fu">=</span>
    if address <span class="fu">==</span> <span class="st">&quot;127.0.0.1&quot;</span> <span class="kw">then</span> <span class="st">&quot;localhost&quot;</span> <span class="kw">else</span> address</code></pre>
<p>Эта функция принимает единственный аргумент стандартного типа <code>String</code>, соответствующий некоторому IP-адресу. В теле функции происходит проверка аргумента на равенство адресу <code>127.0.0.1</code>, в результате чего мы окажемся в одной из двух логических ветвей. В C++ это выглядело бы так:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">std::string indicate( <span class="dt">const</span> std::string&amp; address ) {
    if( address == <span class="st">&quot;127.0.0.1&quot;</span> ) {
        return <span class="st">&quot;localhost&quot;</span>;
    }

    return address;
}</code></pre>
<p>Мы явно указали две точки выхода из функции. Но в Haskell этого делать не нужно, потому что когда мы окажемся в одной из двух логических ветвей, то выражение, на котором мы окажемся, и будет возвращено.</p>
<p>Чтобы стало понятнее, перепишем тело этой функции так, чтобы избавиться от выражения <code>if-then-else</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">indicate ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
indicate <span class="st">&quot;127.0.0.1&quot;</span> <span class="fu">=</span> <span class="st">&quot;localhost&quot;</span>
indicate address <span class="fu">=</span> address</code></pre>
<p>Haskell позволяет вводить несколько определений для одной функции. Рассматривайте это как особый вариант перегрузки. Здесь мы говорим: “Если входной аргумент будет равен ‘127.0.0.1’, пусть будет использовано тело №1, в противном случае пусть будет использовано тело №2”. Следовательно, когда компилятор увидит вызов этой функции в коде, он просто подставит на место этого вызова соответствующее выражение: либо строку “localhost”, в случае использования первого тела, либо фактически переданный аргумент, в случае использования второго тела.</p>
<p>Теперь всё встало на свои места: явно определять точку выхода из чистой функции не нужно потому, что конечное выражение в теле этой функции просто заменит собою вызов функции. То есть если написано так:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> putStrLn (indicate <span class="st">&quot;127.0.0.1&quot;</span>)</code></pre>
<p>это то же самое, как если бы было написано просто:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> putStrLn <span class="st">&quot;localhost&quot;</span></code></pre>
<p>Это - важное свойство чистых функций: мы всегда можем безопасно заменить места их вызова соответствующими возвращённым значениями, и работа приложения при этом останется неизменной. Именно поэтому работать с чистой функцией легко.</p>
<h2 id="охрана">Охрана</h2>
<p>Существует ещё один способ задать выбор внутри функции без использования <code>if-then-else</code>. Называется он охрана (guard), хотя можно перевести и как “защита” или “стража”. Перепишем нашу функцию:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">indicate ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
indicate address
    <span class="fu">|</span> address <span class="fu">==</span> <span class="st">&quot;127.0.0.1&quot;</span> <span class="fu">=</span> <span class="st">&quot;localhost&quot;</span>
    <span class="fu">|</span> null address <span class="fu">=</span> <span class="st">&quot;empty IP-address&quot;</span>
    <span class="fu">|</span> otherwise <span class="fu">=</span> address</code></pre>
<p>Символ <code>|</code> отражает выбор, как если бы мы написали вместо него слово “либо”. После него идёт логическое условие и соответствующее ему итоговое значение функции:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="fu">...</span>
    <span class="fu">|</span> address <span class="fu">==</span> <span class="st">&quot;127.0.0.1&quot;</span> <span class="fu">=</span> <span class="st">&quot;localhost&quot;</span>
    <span class="fu">|</span> null address           <span class="fu">=</span> <span class="st">&quot;empty IP-address&quot;</span>
    <span class="fu">...</span>
      <span class="co">-- логическое условие  = итоговое значение</span></code></pre>
<p>Кстати, ветку <code>otherwise</code> необходимо использовать всегда. Если вы её пропустите, код пройдёт компиляцию, однако в вашем коде поселится коварная ошибка. В частности, если вы напишете так:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">indicate ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
indicate address
    <span class="fu">|</span> address <span class="fu">==</span> <span class="st">&quot;127.0.0.1&quot;</span> <span class="fu">=</span> <span class="st">&quot;localhost&quot;</span>
    <span class="fu">|</span> null address <span class="fu">=</span> <span class="st">&quot;empty IP-address&quot;</span></code></pre>
<p>а потом примените эту функцию к непустой строке, отличающейся от “127.0.0.1”, вы получите ошибку времени выполнения:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">Real</span>: src/Main.hs:(23,1)<span class="kw">-</span>(25,36)<span class="kw">:</span> Non-exhaustive patterns in function indicate</code></pre>
<p>Будьте внимательны.</p>
<h2 id="локальные-выражения">Локальные выражения</h2>
<p>Локальное выражение в теле функции - штука очень полезная, спасающая нас от магических чисел и от дубляжа.</p>
<p>Например, у нас есть такая функция:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prepareLength ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
prepareLength line <span class="fu">=</span> line <span class="fu">*</span> <span class="fl">0.4959</span></code></pre>
<p>Здесь мы готовим длину некой линии путём умножения её первоначальной длины на заданный поправочный коэффициент. Но перед нами - классическое магическое число, смысл которого непонятен, и это плохо. Добавлять комментарий - не самое лучшее решение. Поэтому добавим локальное поясняющее выражение:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prepareLength ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
prepareLength line <span class="fu">=</span>
    line <span class="fu">*</span> coefficient
    where coefficient <span class="fu">=</span> <span class="fl">0.4959</span></code></pre>
<p>Ключевое слово <code>where</code> вводит выражение, которое можно использовать в теле функции. Рассматривайте его как псевдоним: идентификатор <code>coefficient</code> теперь можно использовать как аналог числового значения <code>0.4959</code>.</p>
<p>Локальных выражений может быть и несколько:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">...</span>
    line <span class="fu">*</span> coefficient <span class="fu">-</span> correction
    where coefficient <span class="fu">=</span> <span class="fl">0.4959</span>
          correction <span class="fu">=</span> <span class="fl">0.0012</span></code></pre>
<p>Есть ещё один способ ввести локальное вспомогательное выражение, а именно с помощью ключевого слова <code>let</code>. На примере нашей последней функции это будет выглядеть так:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prepareLength ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
prepareLength line <span class="fu">=</span>
    let coefficient <span class="fu">=</span> <span class="fl">12.4959</span>
        correction <span class="fu">=</span> <span class="fl">0.0012</span>
    in
    line <span class="fu">*</span> coefficient <span class="fu">-</span> correction</code></pre>
<p>Общая модель такая:</p>
<pre><code>let bindings in expression,</code></pre>
<p>где <code>bindings</code> - локальные выражения, а <code>expression</code> - то место, где мы собираемся использовать эти локальные выражения.</p>
<p>Вы спросите, в чём же разница между <code>where</code> и <code>let</code>?</p>
<p>Во-первых, выражение <code>where</code> может быть только одно и только в конце тела функции, в то время как выражение <code>let</code> может присутствовать многократно и в любой части тела функции.</p>
<p>Во-вторых, выражение, введённое ключевым словом <code>where</code>, видимо в любой точке тела функции, в то время как выражение, введённое ключевым словом <code>let</code>, может быть “супер-локальным”. Например:  </p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">...</span>
    let coefficient <span class="fu">=</span> <span class="fl">12.4959</span>
        correction <span class="fu">=</span> <span class="fl">0.0012</span>
    in
    line <span class="fu">*</span> coefficient <span class="fu">-</span> correction <span class="fu">-</span> (<span class="kw">let</span> s <span class="fu">=</span> <span class="fl">10.9</span> <span class="kw">in</span> s <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">-</span> s</code></pre>
<p>Здесь мы ввели “супер-локальное” выражение с именем <code>s</code>, которое существует только внутри круглых скобок. Именно поэтому этот код не пройдёт компиляцию, ведь второе выражение <code>s</code> находится уже за пределами круглых скобок.</p>
<h2 id="без-объявления">Без объявления</h2>
<p>Как вы помните, нельзя объявить функцию и при этом не определить её. А можно ли определить функцию без объявления? Ответ: можно. Однако важно помнить, что общепринятой практикой является объявлять функцию и тут же определять её. Да, мы можем написать так:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Объявления нет, сразу определение</span>
prepareLength line <span class="fu">=</span>
    <span class="fu">...</span></code></pre>
<p>однако для сложных функций делать так крайне не рекомендуется, поскольку определение становится беднее, ведь описание типов аргументов и возвращаемого значения помогает лучше понять работу функции. Кроме того, если вы не укажете эти типы, они станут полиморфными, но об этом мы поговорим позже.</p>
<p>Впрочем, если речь идёт о действительно тривиальных функциях, состоящих из одной-двух строк, говорящих сами за себя, тогда указание типов аргументов и возвращаемого значения будет выглядеть избыточным. В этом случае опускайте их.</p>
<h2 id="в-сухом-остатке">В сухом остатке</h2>
<ul>
<li>Чистые функции (далее ЧФ) - это функции в математическом смысле слова. Они не имеют побочных эффектов, всегда что-то принимают и всегда что-то возвращают.</li>
<li><code>f x</code> - это вызов функции <code>f</code> с аргументом <code>x</code>, или применение функции <code>f</code> к значению <code>x</code>.</li>
<li>Мы всегда можем заменить вызов ЧФ возвращаемым ею значением, и у нас ничего не сломается.</li>
<li>Порядок вычислений в теле ЧФ не важен, ибо от перестановки слагаемых сумма не меняется.</li>
<li>Мы не можем явно указать точку выхода из ЧФ.</li>
<li>В теле ЧФ можно ввести одно или более локальных выражений, с помощью <code>where</code> и <code>let</code>.</li>
<li>Объявление тривиальных ЧФ рекомендуется опускать.</li>
</ul>

<div class="row">
    <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6">
        <div class="clear-button text-left">
            <div class="chapters-selector">
                <a href="../../ru/about-functions/index.html" title="Предыдущая глава"><span class="fa fa-hand-o-left"></span></a>
            </div>
        </div>
    </div>
    
    <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6">
        <div class="clear-button text-right">
            <div class="chapters-selector">
                <a href="../../ru/about-functions/lambda-functions.html" title="Следующая глава"><span class="fa fa-hand-o-right"></span></a>
            </div>
        </div>
    </div>
</div>
<div style="padding-top: 40px;"><div>

<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'ohaskell'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
 

        </div> 

        <footer class="footer">
            Книга создана с помощью <strong><a href="http://jaspervdj.be/hakyll/" target="_blank">Hakyll</a></strong> и живёт на <strong><a href="https://github.com/denisshevchenko/ohaskell" target="_blank">GitHub</a></strong>.
            <div class="copyright-note">
                Исходный код сайта и содержимое книги распространяются на условиях <a href="https://github.com/denisshevchenko/ohaskell/blob/master/LICENSE" target="_blank">свободной лицензии MIT</a>.
            </div>
        </footer>
    </div>
  </body>
</html>


