<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="description" content>
        <meta name="author" content="Денис Шевченко">
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0" />

        <link rel="icon" href="../../static/images/favicon.ico">

        <title>Чистые функции</title>

        <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" rel="stylesheet">

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>

        <!--Import Google Icon Font-->
        <link href="http://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

        <!-- Compiled and minified CSS -->
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.1/css/materialize.min.css">

        <!-- Compiled and minified JavaScript -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.1/js/materialize.min.js"></script>

        <link href="../../static/css/default.css" rel="stylesheet">
        <script src="../../static/js/default.js"></script>

        <script>
          window.___gcfg = {
            lang: 'ru'
          };
        </script>

        <script src="https://apis.google.com/js/platform.js" async defer>
        </script>
    </head>

    <body>
        <div class="navbar-fixed">
            <nav>
                <div class="nav-wrapper">
                    <a href="../../ru/index.html" class="brand-logo center">
                        #ohaskell
                    </a>

                    <!-- <form>
                        <div class="input-field">
                            <input id="search" type="search" required>
                            <label for="search"><i class="material-icons">search</i></label>
                            <i class="material-icons">close</i>
                        </div>
                    </form> -->

                    <a href="#" data-activates="mobile-demo" class="button-collapse show-on-large" style="padding-left: 15px;">
                        <i class="material-icons">toc</i>
                    </a>

                    <ul class="side-nav" id="mobile-demo">
                        <li><a href="../../ru/intro/index.html">Лирическое вступление</a></li>
                          <li><a href="../../ru/intro/who.html">Кто</a></li>
                          <li><a href="../../ru/intro/why.html">Почему</a></li>
                          <li><a href="../../ru/intro/what-for.html">Зачем</a></li>
                          <li><a href="../../ru/intro/for-whom.html">Для кого</a></li>
                        
                        <li><a href="../../ru/prepare/index.html">Готовимся к работе</a></li>
                          <li><a href="../../ru/prepare/create-project.html">Создаём проект</a></li>
                          <li><a href="../../ru/prepare/about-modules-minimum.html">О модулях, минимум</a></li>
                          <li><a href="../../ru/prepare/about-hackage.html">О Hackage</a></li>
                          <li><a href="../../ru/prepare/about-sandbox.html">О песочнице</a></li>

                        <li><a href="../../ru/about-haskell/index.html">Несколько слов о Haskell</a></li>
                          <li><a href="../../ru/about-haskell/pure-functionality.html">Чистая функциональность</a></li>
                          <li><a href="../../ru/about-haskell/types-three-foundations.html">Три кита типизации</a></li>
                          <li><a href="../../ru/about-haskell/immutability.html">Неизменность данных</a></li>
                          <li><a href="../../ru/about-haskell/laziness.html">Лень</a></li>
                          <li><a href="../../ru/about-haskell/where.html">Где его использовать</a></li>

                        <li><a href="../../ru/about-functions/index.html">О функциях</a></li>
                          <li><a href="../../ru/about-functions/pure-functions.html">Чистые функции</a></li>
                          <li><a href="../../ru/about-functions/lambda-functions.html">λ-функции</a></li>
                          <li><a href="../../ru/about-functions/higher-order-functions.html">Функции высшего порядка</a></li>
                          <li><a href="../../ru/about-functions/functional-chains.html">Функциональные цепочки</a></li>
                          <li><a href="../../ru/about-functions/functions-and-operators.html">Функции и операторы</a></li>

                        <li><a href="../../ru/about-lists/index.html">О списках</a></li>
                          <li><a href="../../ru/about-lists/lists-at-a-glance.html">Списки &mdash; одним взглядом</a></li>
                          <li><a href="../../ru/about-lists/ranges.html">Диапазоны</a></li>
                          <li><a href="../../ru/about-lists/tuples.html">Кортежи</a></li>
                          <li><a href="../../ru/about-lists/list-comprehension.html">Генераторы списков</a></li>

                        <li><a href="../../ru/about-user-types/index.html">О пользовательских типах</a></li>
                          <li><a href="../../ru/about-user-types/types-at-a-glance.html">Типы &mdash; одним взглядом</a></li>
                          <li><a href="../../ru/about-user-types/about-value-constructors.html">О конструкторах значений</a></li>
                          <li><a href="../../ru/about-user-types/type-context.html">Контекст типа</a></li>
                          <li><a href="../../ru/about-user-types/composite-types.html">Составные типы</a></li>
                          <li><a href="../../ru/about-user-types/deriving.html">Наследуемые типы</a></li>
                          <li><a href="../../ru/about-user-types/own-type-classes.html">Собственные классы типов</a></li>
                          <li><a href="../../ru/about-user-types/newtype.html">Новый тип</a></li>

                        <li><a href="../../ru/io/index.html">Ввод и вывод</a></li>
                          <li><a href="../../ru/io/functions-with-side-effects.html">Побочные эффекты</a></li>
                          <li><a href="../../ru/io/IO-a.html">IO a</a></li>
                          <li><a href="../../ru/io/do-imperative-world.html">do: императивный мир</a></li>
                          <li><a href="../../ru/io/exceptions-handling.html">Обработка исключений</a></li>
                          <li><a href="../../ru/io/own-exceptions.html">Собственные исключения</a></li>

                        <li><a href="../../ru/delicious/index.html">Деликатесы</a></li>
                          <li><a href="../../ru/delicious/monads-essence.html">Монады: суть</a></li>
                          <li><a href="../../ru/delicious/monads-IO.html">Монады: на примере IO</a></li>
                          <li><a href="../../ru/delicious/monads-practice.html">Монады: практика</a></li>
                          <li><a href="../../ru/delicious/maybe.html">Может быть</a></li>
                          <li><a href="../../ru/delicious/functors.html">Функторы</a></li>
                          <li><a href="../../ru/delicious/applicative-functors.html">Аппликативные функторы</a></li>
                          <li><a href="../../ru/delicious/transformers-first-meeting.html">Трансформеры: начало</a></li>
                          <li><a href="../../ru/delicious/transformers-reader.html">Трансформеры: читатель</a></li>
                          <li><a href="../../ru/delicious/transformers-writer.html">Трансформеры: писатель</a></li>
                          <li><a href="../../ru/delicious/transformers-state.html">Трансформеры: состояние</a></li>
                          <li><a href="../../ru/delicious/transformers-error.html">Трансформеры: ошибка</a></li>

                        <li><a href="../../ru/miscellaneous/index.html">Разное</a></li>
                          <li><a href="../../ru/miscellaneous/about-modules.html">О модулях</a></li>
                          <li><a href="../../ru/miscellaneous/pattern-matching.html">Сравнение с образцом</a></li>
                          <li><a href="../../ru/miscellaneous/map.html">Контейнеры: словарь</a></li>
                          <li><a href="../../ru/miscellaneous/set.html">Контейнеры: множество</a></li>
                          <li><a href="../../ru/miscellaneous/recursive-functions.html">Рекурсивные функции</a></li>
                          <li><a href="../../ru/miscellaneous/about-apostrophe.html">Про апостроф</a></li>
                          <li><a href="../../ru/miscellaneous/about-formatting.html">О форматировании</a></li>
                          <li><a href="../../ru/miscellaneous/about-hlint.html">Про hlint</a></li>

                        <li><a href="../../ru/integration/index.html">Интеграция</a></li>
                          <li><a href="../../ru/integration/c-from-haskell.html">C из Haskell</a></li>

                        <li><a href="../../ru/end/index.html">Заключение</a></li>
                          <li><a href="../../ru/end/is-this-end.html">И что, это всё??</a></li>
                          <li><a href="../../ru/end/gratitudes.html">Благодарности</a></li>
                    </ul>

                    <ul id="nav-mobile" class="right">
                        <li><a href="https://github.com/denisshevchenko/ohaskell" target="_blank"><span class="fa fa-github"></span></a></li>
                    </ul>
                </div>
            </nav>
        </div>

        <div class="container">
            <h1>Чистые функции</h1>

            <p>Ранее мною уже были упомянуты так называемые <em>чистые</em> функции. И раз уж Haskell является чисто функциональным языком, пришла пора поговорить об этих чистых функциях. Тем более что они являются одним из краеугольных камней этого языка.</p>
<p>Для начала вспомним школьный курс математики и сформулируем простейшее определение функции:</p>
<blockquote>
<p><strong>Функция - это описание зависимости чего-то от чего-то.</strong></p>
</blockquote>
<p>То есть функциия представляет собою закон, определяющий то, <em>как</em> одному конкретному значению соответствует другое конкретное значение. Например, уже известная нам функция <code>f1</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">f1 x <span class="fu">=</span> x <span class="fu">*</span> x</code></pre></div>
<p>В рамках данной функции каждому целочисленному значению однозначно соответствует его квадрат. Так вот чистые функции в Haskell - это и есть функции в математическом смысле. Они представляют собой описание того, <em>как</em> конкретное входное значение определяет конкретное выходное значение.</p>
<p>Отсюда вытекает важнейшая характеристика чистых функций, а именно отсутствие побочных эффектов. Значение на входе чистой функции всецело и полностью определяет значение на выходе. Поэтому если мы миллион раз подадим на вход функции <code>f1</code> одно и то же значение, то на выходе мы миллион раз получим один и тот же результат. Гарантированно.</p>
<p>Кстати, по поводу побочных эффектов. Чистая функция не способна взаимодействовать с внешним миром. Не существует никакого способа заставить чистую функцию записать строчку в файл, прочитать запись из БД, отправить HTTP-запрос или получить текст, вводимый пользователем с клавиатуры. А раз так, чистая функция является в высшей степени предсказуемой конструкцией: она никогда не преподнесёт нам сюрприз, потому что единственное что она делает, это определяет зависимость своего выходного значения от своих аргументов.</p>
<h2 id="объявляем">Объявляем</h2>
<p>Сначала функцию рекомендуется объявить. Сделаем же это:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">simpleSum ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></code></pre></div>
<p>До символа <code>::</code> указывается имя функции, а после - её тип.</p>
<pre><code>simpleSum :: Int -&gt; Int
|       |    |        |
   имя          тип </code></pre>
<p>Я понимаю, словосочетание “тип функции” звучит странно, но в мире Haskell так: чистая функция - это значение, имеющее тип функции. Рассмотрим описание этого типа:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></code></pre></div>
<p>Обратите внимание на стрелочку. В объявлении всех чистых функций всегда присутствует эта стрелочка. Слева от неё указан тип единственного аргумента (в данном случае это стандартный тип <code>Int</code>), а справа от неё - тип выходного значения (тот же <code>Int</code>). Саму же стрелочку можно воспринимать как ментальное указание на поток информации, движущийся через функцию: от её входа к выходу, слева направо.</p>
<p>Я повторю эту важную мысль ещё раз: чистая функция - это значение. В императивном программировании данные и функции - это совершенно разные вещи. Но в чисто функциональном языке данные и функции - это одно и то же. И на протяжении последущих глав мы много раз будем возвращаться к этой простой и важной мысли. Да, если вы имеете опыт разработки на императивном языке, эта мысль не кажется вам такой уж простой (а вероятно, она вообще кажется вам абсурдной), но вскоре всё встанет на свои места.</p>
<p>Кстати, вы заметили, что выше было упомянуто о том, что функцию рекомендуется объявить? Строго говоря, в Haskell делать это необязательно. Однако объявление показывает нам типы аргументов и тип возвращаемого значения, а это делает код значительно более читабельным.</p>
<p>Напоминаю, что чистая функция обязана иметь хотя бы один аргумент и обязана что-то возвращать, ведь это и отражает суть математической функции: что-то обязательно подаём на вход и что-то обязательно получаем на выходе.</p>
<p>Разумеется, чистая функция может принимать и несколько аргументов. Вот тип функции, принимающей три аргумента:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></code></pre></div>
<p>Читать эту запись следует так: ищем последнюю по счёту (самую правую) стрелочку - она-то и будет тем самым разделителем: слева от неё идёт список типов аргументов, справа - тип возвращаемого выражения:</p>
<pre><code>Int -&gt; Int -&gt; Int -&gt; Int
типы аргументов  |  |тип возвращаемого значения</code></pre>
<h2 id="определяем">Определяем</h2>
<p>Теперь функцию необходимо определить. Да, определить нужно <em>обязательно</em>. Например, в языке C или C++ мы можем спокойно объявить функцию и не определять её (при условии, что она никогда не вызывается). В Haskell более строгий подход: если объявил функцию - будь добр и определить её, в противном случае компилятор выскажет своё категорическое недовольство.</p>
<p>Поэтому сразу же после объявления пишем определение:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">simpleSum ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
simpleSum value <span class="fu">=</span> value <span class="fu">+</span> value</code></pre></div>
<p>Здесь ментальным разделителем является знак равенства. Скелет данного выражения можно представить так:</p>
<pre><code>NAME ARGUMENTS = BODY_EXPRESSION </code></pre>
<p>где <code>NAME</code> - имя функции, <code>ARGUMENTS</code> - список имён аргументов (имён, а не типов), а <code>BODY_EXPRESSION</code> - тело функции. В данном случае у нас имеется один-единственный аргумент по имени <code>value</code>, а также имеется простое тело, в котором мы просто складываем аргумент с самим собой.</p>
<h2 id="вызываем">Вызываем</h2>
<p>Теперь нашу функцию можно вызывать. Сделаем же это с аргументом <code>4</code>, или, как принято говорить в мире функционального программирования, применим функцию к аргументу <code>4</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> putStrLn (show (simpleSum <span class="dv">4</span>))</code></pre></div>
<p>Стандартная функция <code>putStrLn</code> выводит строку на экран с завершающим <code>\n</code>. Результат выполнения этого кода вполне ожидаем:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">8</span></code></pre></div>
<p>Готово. А теперь необходимо уточнить некоторые важные детали.</p>
<h2 id="выход-из-функции">Выход из функции</h2>
<p>В языке C, если у нас есть функция с возвращаемым значением, мы обязаны где-то в её теле указать точку выхода с помощью инструкции <code>return</code>. Кроме того, точек выхода может быть несколько.</p>
<p>В Haskell всё обстоит совершенно иначе. Во-первых, точка выхода из чистой функции может быть только одна, а во-вторых, аналога инструкции <code>return</code> в Haskell нет. Да, существует специальная фукнция <code>return</code>, но, как будет упомянуто в следующих главах, она несёт совершено иной смысл.</p>
<p>Почему же в Haskell нет C-подобной инструкции <code>return</code>? Если мы вспомним математическую природу чистой функции, то поймём, что иначе и быть не может. Ведь чистая функция представляет собой описание зависимости выходного значения от входных значений, поэтому её тело представляет собой совокупность выражений, которые вычисляются и в конечном итоге оставляют одно-единственное, последнее выражение. Так вот это последнее выражение и будет являться “точкой выхода” из функции.</p>
<p>Приведу пример:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">indicate ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
indicate address <span class="fu">=</span>
    if address <span class="fu">==</span> <span class="st">&quot;127.0.0.1&quot;</span> <span class="kw">then</span> <span class="st">&quot;localhost&quot;</span> <span class="kw">else</span> address</code></pre></div>
<p>Эта функция принимает единственный аргумент стандартного типа <code>String</code>, соответствующий некоторому IP-адресу. В теле функции происходит проверка аргумента на равенство адресу <code>127.0.0.1</code>, в результате чего мы окажемся в одной из двух логических ветвей. В C++ это выглядело бы так:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::string indicate( <span class="dt">const</span> std::string&amp; address ) {
    if( address == <span class="st">&quot;127.0.0.1&quot;</span> ) {
        return <span class="st">&quot;localhost&quot;</span>;
    }

    return address;
}</code></pre></div>
<p>Мы явно указали две точки выхода из функции. Но в Haskell этого делать не нужно, потому что когда мы окажемся в одной из двух логических ветвей, то выражение, на котором мы окажемся, и будет возвращено.</p>
<p>Чтобы стало понятнее, перепишем тело этой функции так, чтобы избавиться от выражения <code>if-then-else</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">indicate ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
indicate <span class="st">&quot;127.0.0.1&quot;</span> <span class="fu">=</span> <span class="st">&quot;localhost&quot;</span>
indicate address <span class="fu">=</span> address</code></pre></div>
<p>Haskell позволяет вводить несколько определений для одной функции. Рассматривайте это как особый вариант перегрузки. Здесь мы говорим: “Если входной аргумент будет равен ‘127.0.0.1’, пусть будет использовано тело №1, в противном случае пусть будет использовано тело №2”. Следовательно, когда компилятор увидит вызов этой функции в коде, он просто подставит на место этого вызова соответствующее выражение: либо строку “localhost”, в случае использования первого тела, либо фактически переданный аргумент, в случае использования второго тела.</p>
<p>Кстати, порядок указания тел функции важен. Если бы мы написали так:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">indicate ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
indicate address <span class="fu">=</span> address
indicate <span class="st">&quot;127.0.0.1&quot;</span> <span class="fu">=</span> <span class="st">&quot;localhost&quot;</span></code></pre></div>
<p>то функция всегда возвращала бы свой фактический адрес. Ведь любое строковое значение удовлетворяло бы телу №1, и до второго тела мы никогда бы не дошли. Таким образом, если у чистой функции несколько тел, указывать их следует от частного к общему, но не наоборот.</p>
<p>Теперь всё встало на свои места: явно определять точку выхода из чистой функции не нужно потому, что конечное выражение в теле этой функции просто заменит собою её вызов. То есть если написано так:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> putStrLn (indicate <span class="st">&quot;127.0.0.1&quot;</span>)</code></pre></div>
<p>это то же самое, как если бы было написано просто:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> putStrLn <span class="st">&quot;localhost&quot;</span></code></pre></div>
<p>Это чрезвычайно важное свойство чистых функций: мы всегда можем безопасно заменить места их вызова соответствующими возвращёнными значениями, и работа приложения при этом гарантированно останется неизменной. А всё потому, что чистая функция - это и есть возвращённое ею значение. Именно поэтому работать с чистой функцией очень легко.</p>
<h2 id="охрана">Охрана</h2>
<p>Существует ещё один способ задать выбор внутри функции без использования конструкции <code>if-then-else</code>. Называется он охрана (guard), хотя можно перевести и как “защита” или “стража”. Перепишем нашу функцию:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">indicate ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
indicate address
    <span class="fu">|</span> address <span class="fu">==</span> <span class="st">&quot;127.0.0.1&quot;</span> <span class="fu">=</span> <span class="st">&quot;localhost&quot;</span>
    <span class="fu">|</span> null address <span class="fu">=</span> <span class="st">&quot;empty IP-address&quot;</span>
    <span class="fu">|</span> otherwise <span class="fu">=</span> address</code></pre></div>
<p>Символ <code>|</code> отражает выбор, как если бы мы написали вместо него слово “либо”. После него идёт логическое условие и соответствующее ему итоговое значение функции:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="fu">...</span>
    <span class="fu">|</span> address <span class="fu">==</span> <span class="st">&quot;127.0.0.1&quot;</span> <span class="fu">=</span> <span class="st">&quot;localhost&quot;</span>
    <span class="fu">|</span> null address           <span class="fu">=</span> <span class="st">&quot;empty IP-address&quot;</span>
    <span class="fu">...</span>
      <span class="co">-- логическое условие  = итоговое значение</span></code></pre></div>
<p>Кстати, ветку <code>otherwise</code> необходимо использовать всегда. Если вы её пропустите, код пройдёт компиляцию, однако в вашем коде поселится коварная ошибка. В частности, если вы напишете так:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">indicate ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
indicate address
    <span class="fu">|</span> address <span class="fu">==</span> <span class="st">&quot;127.0.0.1&quot;</span> <span class="fu">=</span> <span class="st">&quot;localhost&quot;</span>
    <span class="fu">|</span> null address <span class="fu">=</span> <span class="st">&quot;empty IP-address&quot;</span></code></pre></div>
<p>а потом примените эту функцию к непустой строке, отличающейся от “127.0.0.1”, вы получите ошибку времени выполнения:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">Real</span>: src/Main.hs:(23,1)<span class="kw">-</span>(25,36)<span class="kw">:</span> Non-exhaustive patterns in function indicate</code></pre></div>
<p>Будьте внимательны.</p>
<h2 id="отступы">Отступы</h2>
<p>Обратите внимание, что в функции <code>indicate</code> перед символами <code>|</code> находится отступ. Этот отступ очень важен! В Haskell-коде форматирование имеет большое значение, и если оно, это форматирование, неправильное, компиляция не пройдёт. Подробнее о практических примерах форматирования рассказано в главе <a href="../../ru/miscellaneous/about-formatting.html">О форматировании</a>.</p>
<h2 id="локальные-выражения">Локальные выражения</h2>
<p>Локальное выражение в теле функции - штука очень полезная, спасающая нас от магических чисел и от дубляжа кода.</p>
<p>Например, у нас есть такая функция:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prepareLength ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
prepareLength line <span class="fu">=</span> line <span class="fu">*</span> <span class="fl">0.4959</span></code></pre></div>
<p>Здесь мы готовим длину некой линии путём умножения её первоначальной длины на заданный поправочный коэффициент. Но перед нами - классическое магическое число, смысл которого непонятен, и это плохо. Добавлять комментарий - не самое лучшее решение. Поэтому добавим локальное поясняющее выражение:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prepareLength ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
prepareLength line <span class="fu">=</span>
    line <span class="fu">*</span> coefficient
    where coefficient <span class="fu">=</span> <span class="fl">0.4959</span></code></pre></div>
<p>Ключевое слово <code>where</code> вводит локальный псевдоним для выражения. Теперь идентификатор <code>coefficient</code> теперь можно использовать как аналог числового значения <code>0.4959</code>.</p>
<p>Локальных выражений может быть и несколько:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prepareLength ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
prepareLength line <span class="fu">=</span>
    line <span class="fu">*</span> coefficient <span class="fu">-</span> correction
    where coefficient <span class="fu">=</span> <span class="fl">0.4959</span>
          correction <span class="fu">=</span> <span class="fl">0.0012</span></code></pre></div>
<p>Есть ещё один способ ввести локальное вспомогательное выражение, а именно с помощью ключевого слова <code>let</code>. На примере нашей последней функции это будет выглядеть так:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prepareLength ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
prepareLength line <span class="fu">=</span>
    let coefficient <span class="fu">=</span> <span class="fl">12.4959</span>
        correction <span class="fu">=</span> <span class="fl">0.0012</span>
    in
    line <span class="fu">*</span> coefficient <span class="fu">-</span> correction</code></pre></div>
<p>Общая модель такая:</p>
<pre><code>let bindings in expression,</code></pre>
<p>где <code>bindings</code> - локальные выражения, а <code>expression</code> - то место, где мы собираемся использовать эти локальные выражения. Кстати, слово <code>in</code> не всегда обязательно, но об этом мы узнаем в следующих главах.</p>
<p>Вы спросите, в чём же разница между <code>where</code> и <code>let</code>?</p>
<p>Во-первых, выражение <code>where</code> может быть только одно и только в конце тела функции, в то время как выражение <code>let</code> может присутствовать многократно и в любой части тела функции.</p>
<p>Во-вторых, выражение, введённое ключевым словом <code>where</code>, видимо в любой точке тела функции, в то время как выражение, введённое ключевым словом <code>let</code>, может быть “супер-локальным”. Например:  </p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prepareLength ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
prepareLength line <span class="fu">=</span>
    let coefficient <span class="fu">=</span> <span class="fl">12.4959</span>
        correction <span class="fu">=</span> <span class="fl">0.0012</span>
    in
    line <span class="fu">*</span> coefficient <span class="fu">-</span> correction <span class="fu">-</span> (<span class="kw">let</span> s <span class="fu">=</span> <span class="fl">10.9</span> <span class="kw">in</span> s <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">-</span> s</code></pre></div>
<p>Здесь мы ввели “супер-локальное” выражение с именем <code>s</code>, которое существует только внутри круглых скобок. Именно поэтому этот код не пройдёт компиляцию, ведь второе выражение <code>s</code> находится уже за пределами круглых скобок.</p>
<p>Вы спросите, можем ли мы использовать и <code>let</code>, и <code>where</code> одновременно? Можем, но с одним ограничением. Пишем:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prepareLength ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
prepareLength line <span class="fu">=</span>
    <span class="kw">let</span> coefficient <span class="fu">=</span> <span class="fl">12.4959</span>
    in 
    line <span class="fu">*</span> coefficient <span class="fu">-</span> correction
    where correction <span class="fu">=</span> <span class="fl">0.0012</span></code></pre></div>
<p>Всё прекрасно работает. Мы можем написать и так:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prepareLength ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
prepareLength line <span class="fu">=</span>
    <span class="kw">let</span> coefficient <span class="fu">=</span> <span class="fl">12.4959</span> <span class="fu">-</span> specValue
    in line <span class="fu">*</span> coefficient <span class="fu">-</span> correction
    where correction <span class="fu">=</span> <span class="fl">0.0012</span>
          specValue  <span class="fu">=</span> <span class="fl">0.03</span></code></pre></div>
<p>Тоже работает. Как видите, мы ввели третий <code>where</code>-псевдоним <code>specValue</code> и смогли использовать его в <code>let</code>-выражении. А если попробовать наоборот? Вот так:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prepareLength ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
prepareLength line <span class="fu">=</span>
    <span class="kw">let</span> coefficient <span class="fu">=</span> <span class="fl">12.4959</span>
        specValue <span class="fu">=</span> <span class="fl">0.03</span>
    in line <span class="fu">*</span> coefficient <span class="fu">-</span> correction
    where correction <span class="fu">=</span> <span class="fl">0.0012</span> <span class="fu">-</span> specValue</code></pre></div>
<p>Теперь псевдоним <code>specValue</code> задан в <code>let</code>-выражении, и мы хотим использовать его в <code>where</code>-выражении. Увы, но такой код не скомпилируется, и мы увидим следующую ошибку:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">Not</span> in scope: ‘specValue’</code></pre></div>
<p>Это и есть то самое единственное ограничение: мы не можем использовать <code>let</code>-псевдонимы внутри <code>where</code>-выражения.</p>
<h2 id="в-сухом-остатке">В сухом остатке</h2>
<ol style="list-style-type: decimal">
<li>Чистые функции (далее ЧФ) - это функции в математическом смысле слова: они всегда что-то принимают и всегда что-то возвращают. Кроме того, ЧФ не могут иметь побочных эффектов и не могут взаимодействовать с внешним миром.</li>
<li><code>f x</code> - это вызов функции <code>f</code> с аргументом <code>x</code>, или применение функции <code>f</code> к значению <code>x</code>.</li>
<li>Мы всегда можем безопасно заменить вызов ЧФ возвращаемым ею значением, и у нас ничего не сломается.</li>
<li>Мы не можем явно указать точку выхода из ЧФ, потому что применительно к ЧФ это не имеет смысла.</li>
<li>В теле ЧФ можно ввести одно или более локальных выражений, с помощью ключевых слов <code>where</code> и <code>let</code>.</li>
</ol>

<div style="padding-top: 30px;"><div>
<div class="row">
    <div class="col s6">
        <div class="left">
            <a href="../../ru/about-functions/index.html" class="btn-floating btn-large waves-effect waves-light chapter-arrow">
                <span class="fa fa-angle-double-left"></span>
            </a>
        </div>
    </div>
    
    <div class="col s6">
        <div class="right">
            <a href="../../ru/about-functions/lambda-functions.html" class="btn-floating btn-large waves-effect waves-light chapter-arrow">
                <span class="fa fa-angle-double-right"></span>
            </a>
        </div>
    </div>
</div>
<div style="padding-top: 40px;"><div>

<!--
<div>
    <script>
      (function() {
        var cx = '007697214108744450483:au850gpbupm';
        var gcse = document.createElement('script');
        gcse.type = 'text/javascript';
        gcse.async = true;
        gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
            '//cse.google.com/cse.js?cx=' + cx;
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(gcse, s);
      })();
    </script>
    <gcse:search></gcse:search>
</div>
-->

<!--
<div>
    <div class="row">
        <form class="col s12" 
              id="searchbox_007697214108744450483:au850gpbupm" 
              action="http://www.google.com/cse">
          <div class="row">
            <div class="input-field col s6">
              <i class="material-icons prefix">search</i>

              <input value="007697214108744450483:au850gpbupm" name="cx" type="hidden"/>
              <input value="FORID:11" name="cof" type="hidden"/>

              <input id="icon_prefix" name="q" type="text"/>
              <label for="icon_prefix">Что ищем?</label>
            </div>
          </div>
        </form>
    </div>
</div>
-->

<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'ohaskell'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
 

        </div>
    </body>
</html>