<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content>
        <meta name="author" content="Денис Шевченко">
        <link rel="icon" href="../../static/images/favicon.ico">

        <title>Функции высшего порядка</title>

        <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>

        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">

        <link href="../../static/css/default.css" rel="stylesheet">
        
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>

        <script>
          window.___gcfg = {
            lang: 'ru'
          };
        </script>

        <script src="https://apis.google.com/js/platform.js" async defer>
        </script>
    </head>

  <body>
    <div class="container">
        <nav class="navbar navbar-default navbar-fixed-top">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <div id="logo">
                <a class="navbar-brand" href="../../ru/index.html" title="Домой">
                  О Haskell по-человечески
                </a>
              </div>
            </div>
            
            <div id="navbar" class="collapse navbar-collapse">
              <ul class="nav navbar-nav navbar-right">
                <li><a href="../../ru/chapters.html" target="_blank">Оглавление</a></li>
              </ul>
            </div>
          </div>
        </nav>

        <div id="content">
            <h1>Функции высшего порядка</h1>

            <p>Функции высшего порядка (higher-order functions) занимают важное место в языке Haskell. Из предыдущих глав вы узнали, что чистые функции - это, в конечном итоге, значения. Следовательно, чистые функции можно, во-первых, передавать другим функциям в качестве аргументов, а во-вторых, возвращать их из других функций.</p>
<p>Функцией высшего порядка называют такую функцию, которая принимает другую функцию в качестве аргумента и/или возвращает другую функцию.</p>
<h2 id="разоблачение-функций">Разоблачение функций</h2>
<p>Помните, в рассказе о чистых функциях было упомянуто, что они могут принимать как один, так и множество аргументов? Пришло время признаться в обмане, ибо правда такова:</p>
<blockquote>
<p><strong>Чистые функции в Haskell всегда принимают только один аргумент.</strong> </p>
</blockquote>
<p>Постойте, но как же мы тогда смогли определить функции, принимающие по два и даже по три аргумента?</p>
<p>Это была хитрость, и называется она “каррирование” (currying), иногда говорят “карринг”. Слово это знаменитое, ибо происходит от имени <a href="https://en.wikipedia.org/wiki/Haskell_Curry">Haskell Curry</a>. Каррирование - это превращение функции, принимающей множество аргументов, в функцию, принимающую все эти аргументы по одному.</p>
<p>Определим функцию деления двух чисел:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">divide ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
divide arg1 arg2 <span class="fu">=</span> arg1 <span class="fu">/</span> arg2</code></pre>
<p>Функция принимает два значения стандартного типа <code>Double</code> и возвращает результат деления первого значения на второе. Всё предельно просто. Но если мы заглянем “под капот” вызова этой функции:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> print (divide <span class="fl">10.03</span> <span class="fl">2.1</span>)</code></pre>
<p>то узнаем, что этот вызов происходит в два этапа:</p>
<ol style="list-style-type: decimal">
<li>Функция <code>divide</code> применяется к первому аргументу <code>10.03</code> и - внимание! - возвращает функцию типа <code>Double -&gt; Double</code>.</li>
<li>Эта возвращённая функция, в свою очередь, применяется ко второму аргументу <code>2.1</code> и возвращает конечное значение <code>4.77</code>.</li>
</ol>
<p>Мы можем явно отразить эту “двухэтапность”, переписав вызов функции так:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">(divide <span class="fl">10.03</span>) <span class="fl">2.1</span></code></pre>
<p>Функция применяется только к одному значению: сначала к <code>10.03</code>, а уже потом функция, возвращённая первым вызовом, применяется к <code>2.1</code>. Именно по причине такой “двухэтапности” объявление функции <code>divide</code> содержит две стрелочки вместо одной:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">divide ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></code></pre>
<p>С концептуальной точки зрения такое объявление звучит так: “Функция <code>divide</code> принимает два значения типа <code>Double</code> и возвращает значение типа <code>Double</code>”. Однако правильнее читать его так: “Функция <code>divide</code> применяется к первому значению типа <code>Double</code> и возвращает функцию типа <code>Double -&gt; Double</code>, которая применяется ко второму значению типа <code>Double</code> и возвращает конечное значение типа <code>Double</code>”. Кстати, правильное прочтение объявления можно отразить и в самом этом объявлении:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">divide ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> (<span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>)</code></pre>
<p>Теперь мы ясно видим, что на первом этапе происходит вызов функции от одного аргумента, возвращающей функцию типа <code>Double -&gt; Double</code>, а на втором этапе происходит вызов второй функции, возвращённой на первом этапе.</p>
<p>По аналогии, если у нас есть функция, принимающая три аргумента:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">totalSum ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
totalSum arg1 arg2 arg3 <span class="fu">=</span> arg1 <span class="fu">+</span> arg2 <span class="fu">+</span> arg3</code></pre>
<p>то её вызов:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> print (totalSum <span class="fl">10.03</span> <span class="fl">2.1</span> <span class="fl">45.7</span>)</code></pre>
<p>проходил бы в три этапа, и чтобы явно отразить этот факт, мы можем переписать объявление данной функции так:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">totalSum ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> (<span class="dt">Double</span> <span class="ot">-&gt;</span> (<span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>))</code></pre>
<p>а её вызов - так:  </p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">((totalSum <span class="fl">10.03</span>) <span class="fl">2.1</span>) <span class="fl">45.7</span></code></pre>
<p>  И чтобы всё окончательно прояснилось, изучим одну важную деталь.</p>
<h2 id="частичное-применение-функции">Частичное применение функции</h2>
<p>Несмотря на “двухэтапность” вызова функции <code>divide</code>, её тело будет выполнено один раз. Вызов один, просто он разделён на два последовательных шага. А чтобы понять суть этих шагов, изучим частичное применение функции (partial application).</p>
<p>Функцию называют частично применённой, если количество аргументов, к которым она применена, оказалось меньше ожидаемого ею количества аргументов. И здесь нам пригодятся уже известные нам λ-функции.</p>
<p>Применим функцию <code>divide</code> не к двум, а только к одному аргументу:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span>
    let temporaryFunction <span class="fu">=</span> divide <span class="fl">10.03</span>  <span class="co">-- &quot;Запомнили&quot; первое значение...</span>
    in
    print (temporaryFunction <span class="fl">2.1</span>)   <span class="co">-- А вот теперь можем выполнить работу.</span></code></pre>
<p>Теперь всё встало на свои места. Здесь наглядно показано, что же на самом деле означает выражение вида:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">(divide <span class="fl">10.03</span>) <span class="fl">2.1</span></code></pre>
<p>В результате первого вызова, когда мы применили функцию <code>divide</code> к первому аргументу, мы ещё не можем получить результат деления, ведь второго-то аргумента ещё нет! Вместо этого мы получили временную λ-функцию, которую для наглядности ассоциировали с выражением <code>temporaryFunction</code>. Эта временная λ-функция как бы запомнила значение первого аргумента, и только когда мы применим её ко второму аргументу, мы и получим результат деления.</p>
<p>По аналогии, вызов нашей функции <code>totalSum</code>, происходящий в три этапа, можно разложить так:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span>
    let firstFunction <span class="fu">=</span> totalSum <span class="fl">1.0</span>       <span class="co">-- &quot;Запомнили&quot; первый...</span>
        secondFunction <span class="fu">=</span> firstFunction <span class="fl">2.0</span> <span class="co">-- &quot;Запомнили&quot; второй...</span>
    in
    print (secondFunction <span class="fl">3.0</span>)    <span class="co">-- А вот теперь можем складывать.</span></code></pre>
<p>В процессе вызова у нас появилось уже две временные λ-функции, каждая из которых применялась к очередному аргументу и запоминала его. И только когда вторая промежуточная λ-функция была применена к третьему, последнему аргументу, мы и получили сумму.</p>
<h2 id="зачем-это-нужно">Зачем это нужно</h2>
<p>В подавляющем большинстве случаев знать вышеизложенную информацию о каррировании функций и о частичном применении не обязательно. Основное преимущество каррирования лежит в академической плоскости: выводить математические доказательства гораздо легче, если договориться, что каждая из вычисляемых функций всегда принимает строго один аргумент и возвращает строго одно значение. Но нас с вами больше интересует аспект практический. И поэтому мы возвращаемся к рассмотрению функций высшего порядка (далее - ФВП).</p>
<p>Формально функции <code>divide</code> и <code>totalSum</code> являются ФВП, в силу тех самых промежуточных λ-функций. Фактически, все функции, принимающие более одного аргумента, являются ФВП. Но все эти промежуточные λ-функции - всего лишь “подкапотные” дела, они скрыты от наших глаз. Гораздо больший интерес для нас представляют “настоящие” ФВП, которые явно объявлены как принимающие на вход функциональные значения и/или возвращающие функциональные значения.</p>
<p>Рассмотрим небольшой пример:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Login</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">Password</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">AvatarURL</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">UserId</span> <span class="fu">=</span> <span class="dt">Integer</span>

<span class="ot">userInfo ::</span> <span class="dt">Login</span> <span class="ot">-&gt;</span> <span class="dt">Password</span> <span class="ot">-&gt;</span> <span class="dt">AvatarURL</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
userInfo login password avatarURL userId <span class="fu">=</span>
    <span class="st">&quot;Full info about user @&quot;</span> <span class="fu">++</span> (show userId) <span class="fu">++</span> <span class="st">&quot;:&quot;</span> <span class="fu">++</span>
    <span class="st">&quot;\n login: &quot;</span> <span class="fu">++</span> login <span class="fu">++</span>
    <span class="st">&quot;\n password: &quot;</span> <span class="fu">++</span> password <span class="fu">++</span>
    <span class="st">&quot;\n avatar URL: &quot;</span> <span class="fu">++</span> avatarURL

<span class="kw">type</span> <span class="dt">EmptyInfo</span> <span class="fu">=</span> <span class="dt">Login</span> <span class="ot">-&gt;</span> <span class="dt">Password</span> <span class="ot">-&gt;</span> <span class="dt">AvatarURL</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">WithLogin</span> <span class="fu">=</span>          <span class="dt">Password</span> <span class="ot">-&gt;</span> <span class="dt">AvatarURL</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">AndWithPassword</span> <span class="fu">=</span>                <span class="dt">AvatarURL</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">AndWithAvatarURL</span> <span class="fu">=</span>                            <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">String</span>

<span class="ot">storeLoginIn ::</span> <span class="dt">EmptyInfo</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">WithLogin</span>
storeLoginIn emptyInfo userId <span class="fu">=</span>
    emptyInfo <span class="st">&quot;denis&quot;</span>
    <span class="co">{- В реальности логин будет получен</span>
<span class="co">       в соответствии с переданным userId -}</span>

<span class="ot">storePasswordIn ::</span> <span class="dt">WithLogin</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">AndWithPassword</span>
storePasswordIn infoWithLogin userId <span class="fu">=</span> infoWithLogin <span class="st">&quot;123456789abc&quot;</span>
    <span class="co">{- В реальности пароль будет получен</span>
<span class="co">       в соответствии с переданным userId -}</span>

<span class="ot">storeAvatarURLIn ::</span> <span class="dt">AndWithPassword</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">AndWithAvatarURL</span>
storeAvatarURLIn infoWithPassword userId <span class="fu">=</span>
    infoWithPassword <span class="st">&quot;http://dshevchenko.biz/denis_avatar.png&quot;</span>
    <span class="co">{- В реальности URL будет получен</span>
<span class="co">       в соответствии с переданным userId -}</span>

main <span class="fu">=</span>
    let userId <span class="fu">=</span> <span class="dv">1234</span>
        infoWithLogin <span class="fu">=</span> storeLoginIn userInfo userId
        infoWithPassword <span class="fu">=</span> storePasswordIn infoWithLogin userId
        infoWithAvatarURL <span class="fu">=</span> storeAvatarURLIn infoWithPassword userId
        fullInfoAboutUser <span class="fu">=</span> infoWithAvatarURL userId
    in
    putStrLn fullInfoAboutUser</code></pre>
<p>А теперь разберём это хозяйство по косточкам.</p>
<p>Во-первых, появилась новая для нас конструкция:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Login</span> <span class="fu">=</span> <span class="dt">String</span></code></pre>
<p>Ключевое слово <code>type</code> добавляет псевдоним для уже известного типа, и теперь вместо типа <code>String</code> можно использовать идентификатор <code>Login</code>.</p>
<p>Далее мы определили функцию:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">userInfo ::</span> <span class="dt">Login</span> <span class="ot">-&gt;</span> <span class="dt">Password</span> <span class="ot">-&gt;</span> <span class="dt">AvatarURL</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">String</span></code></pre>
<p>Тут всё просто: функция <code>userInfo</code> ожидает на вход логин, пароль, адрес аватара и идентификатор пользователя, а на выходе выдаёт некую описывающую строку. Обратите внимание и на двойной плюс:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="st">&quot;\n login: &quot;</span> <span class="fu">++</span> login</code></pre>
<p>Это оператор конкатенации двух списков в один. А поскольку строка есть список символов, к ней этот оператор вполне применим.</p>
<p>А вот теперь начинается самое интересное. Подразумевается, что изначально у нас имеется только идентификатор пользователя, а соответствующие ему логин, пароль и путь к аватару нам нужно откуда-то получить. К счастью, у нас есть три функции, каждая из которых знает, где взять логин, пароль и путь к аватару соответственно. И каждая из этих трёх функций является ФВП.</p>
<p>Рассмотрим псевдонимы:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">EmptyInfo</span> <span class="fu">=</span> <span class="dt">Login</span> <span class="ot">-&gt;</span> <span class="dt">Password</span> <span class="ot">-&gt;</span> <span class="dt">AvatarURL</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">WithLogin</span> <span class="fu">=</span>          <span class="dt">Password</span> <span class="ot">-&gt;</span> <span class="dt">AvatarURL</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">AndWithPassword</span> <span class="fu">=</span>                <span class="dt">AvatarURL</span> <span class="ot">-&gt;</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">AndWithAvatarURL</span> <span class="fu">=</span>                            <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">String</span></code></pre>
<p>Каждый из них вводит упрощающее имя для функционального типа, образованного “урезанием” от типа функции <code>userInfo</code>. Обратите внимание: каждый последующий тип ожидает на один аргумент меньше, чем предыдущий тип. Эти псевдонимы задают типы для очередной промежуточной λ-функции, которые нужны, как вы уже догадались, для частичного применения функции <code>userInfo</code>.</p>
<p>Рассмотрим первый вызов:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">infoWithLogin <span class="fu">=</span> storeLoginIn userInfo userId</code></pre>
<p>Здесь мы передаём функцию <code>userInfo</code> в качестве первого аргумента функции <code>storeLoginIn</code>, внутри которой мы применяем переданную функцию <code>userInfo</code> к единственному аргументу, а именно к логину. Соответственно, на выходе из функции <code>storeLoginIn</code> мы получаем первую промежуточную λ-функцию, в которой мы сохранили значение логина (именно поэтому тип этой λ-функции ассоциирован со словом <code>WithLogin</code>).</p>
<p>Далее следует вызов:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">infoWithPassword <span class="fu">=</span> storePasswordIn infoWithLogin userId</code></pre>
<p>Здесь мы передаём нашу промежуточную λ-функцию в качестве первого аргумента функции <code>storePasswordIn</code>. Эта функция, в свою очередь, применяет переданную ей λ-функцию к единственному аргументу, а именно к паролю. Таким образом, на выходе из функции <code>storePasswordIn</code> мы имеем вторую промежуточную λ-функцию, в которой сохранены уже два значения: полученный на предыдущем вызове логин и на этом вызове - пароль.</p>
<p>То же самое справедливо и для следующего вызова:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">infoWithAvatarURL <span class="fu">=</span> storeAvatarURLIn infoWithPassword userId</code></pre>
<p>На выходе из функции <code>storeAvatarURLIn</code> мы получаем третью λ-функцию, в которой сохранены уже три значения: логин, пароль и путь к аватару.</p>
<p>В итоге мы применяем эту третью λ-функцию к последнему нужному аргументу, а именно к идентификатору пользователя:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">fullInfoAboutUser <span class="fu">=</span> infoWithAvatarURL userId</code></pre>
<p>Здесь-то и происходит “полноценный” вызов функции <code>userInfo</code>, в результате которого мы и получаем описывающую строку:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">Full</span> info about user @1234:
 <span class="kw">login</span>: denis
 <span class="kw">password</span>: 123456789abc
 <span class="kw">avatar</span> URL: http://dshevchenko.biz/denis_avatar.png</code></pre>
<p>Таким образом, функция <code>userInfo</code> была частично применена трижды, каждый раз получая очередной аргумент, и лишь к четвёртому применению она получила все необходимые ей аргументы. Это можно сравнить с конвейерной цепочкой, на каждом шаге которой эта функция получала очередной аргумент.</p>
<p>Впрочем, нужны ли были такие сложности? Ведь мы можем передавать в каждую из этих трёх функций только значение <code>userId</code>, а возвращать никакую не промежуточную λ-функцию, а непосредственно логин, пароль и адрес аватара соответственно. Например, вместо функции <code>storeLoginIn</code> можно определить функцию <code>obtainLogin</code> следующего вида:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">obtainLogin ::</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">Login</span>
obtainLogin userId <span class="fu">=</span>
    <span class="co">-- Получаем откуда-то логин и просто возвращаем его.</span></code></pre>
<p>Ну а что если мы не хотим возвращать логин в явном виде? Ведь в случае с частичным применением мы упаковываем логин в промежуточную λ-функцию (то есть фактически прячем логин в неё), а в этом случае мы явно возвращаем его на показ всему миру. Первое решение может оказаться более приемлемым.</p>
<p>Или другой пример:  </p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">UserId</span> <span class="fu">=</span> <span class="dt">Integer</span>
<span class="kw">type</span> <span class="dt">Prefix</span> <span class="fu">=</span> <span class="dt">String</span>

<span class="ot">obtainLogin ::</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> (<span class="dt">Prefix</span> <span class="ot">-&gt;</span> <span class="dt">String</span>)
obtainLogin userId <span class="fu">=</span>
    loginStorage <span class="st">&quot;denis&quot;</span>  <span class="co">-- Подразумевается, что логин как-то получен.</span>
    where loginStorage login prefix <span class="fu">=</span> prefix <span class="fu">++</span> <span class="st">&quot;: &quot;</span> <span class="fu">++</span> login

main <span class="fu">=</span>
    let userId <span class="fu">=</span> <span class="dv">1234</span>
    in
    putStrLn ((obtainLogin userId) <span class="st">&quot;My login&quot;</span>)</code></pre>
<p>  Рассмотрим функцию <code>obtainLogin</code> подробнее:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">obtainLogin ::</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> (<span class="dt">Prefix</span> <span class="ot">-&gt;</span> <span class="dt">String</span>)
obtainLogin userId <span class="fu">=</span>
    loginStorage <span class="st">&quot;denis&quot;</span>
    where loginStorage login prefix <span class="fu">=</span> prefix <span class="fu">++</span> <span class="st">&quot;: &quot;</span> <span class="fu">++</span> login</code></pre>
<p>Здесь мы, на основании полученного извне идентификатора пользователя, откуда-то извлекаем логин и сразу же прячем его в λ-функцию, тут же нами и созданную. В результате функция <code>obtainLogin</code> возвращает частично применённую функцию, которую мы вторично применяем к строке-префиксу - и в результате на выходе мы получаем готовый результат:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">My</span> login: denis</code></pre>
<p>Вас, вероятно, интересует, почему я сказал о λ-функции? Вроде бы здесь нет нашего знакомого <code>\</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">where</span> loginStorage login prefix <span class="fu">=</span> prefix <span class="fu">++</span> <span class="st">&quot;: &quot;</span> <span class="fu">++</span> login</code></pre>
<p>Однако это не важно, ведь такая запись идентична λ-форме:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">where</span> loginStorage <span class="fu">=</span> \login prefix <span class="ot">-&gt;</span> prefix <span class="fu">++</span> <span class="st">&quot;: &quot;</span> <span class="fu">++</span> login</code></pre>
<p>Помните, выше я говорил, что тривиальную функцию лучше определять без объявления? Вот это тот самый случай.</p>
<h2 id="в-сухом-остатке">В сухом остатке</h2>
<ul>
<li>ФВП - это функция, принимающая другую функцию в качестве аргумента и/или возвращающая другую функцию.</li>
<li>ФВП неразрывно связаны с механизмом каррирования, когда функция от нескольких аргументов превращается в набор функций от одного аргумента каждая. Поэтому любая функция, принимающая более одного аргумента, является ФВП.</li>
<li>Каррирование базируется на частичном применении функции, когда функция принимает не все ожидаемые ею аргументы.</li>
</ul>

<div class="row">
    <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6">
        <div class="clear-button text-left">
            <div class="chapters-selector">
                <a href="../../ru/about-functions/lambda-functions.html" title="Предыдущая глава"><span class="fa fa-hand-o-left"></span></a>
            </div>
        </div>
    </div>
    
    <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6">
        <div class="clear-button text-right">
            <div class="chapters-selector">
                <a href="../../ru/about-functions/functional-chains.html" title="Следующая глава"><span class="fa fa-hand-o-right"></span></a>
            </div>
        </div>
    </div>
</div>
<div style="padding-top: 40px;"><div>

<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'ohaskell'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
 

        </div> 

        <footer class="footer">
            Книга создана с помощью <strong><a href="http://jaspervdj.be/hakyll/" target="_blank">Hakyll</a></strong> и живёт на <strong><a href="https://github.com/denisshevchenko/ohaskell" target="_blank">GitHub</a></strong>.
            <div class="copyright-note">
                Исходный код сайта и содержимое книги распространяются на условиях <a href="https://github.com/denisshevchenko/ohaskell/blob/master/LICENSE" target="_blank">свободной лицензии MIT</a>.
            </div>
        </footer>
    </div>
  </body>
</html>


