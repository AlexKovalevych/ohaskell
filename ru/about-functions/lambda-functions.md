λ-функции
---------

Теперь мы должны познакомится с любопытной и важной концепцией, а именно с λ-функциями (лямбда-функциями).

Вспомним упомянутое в предыдущей главе определение математической функции:

> **Функция - это описание зависимости чего-то от чего-то.** 

Однако в языке C (и подобных ему языках) функция никогда не ассоциировалась с таким определением. Напротив, функция там есть ни что иное, как подпрограмма, а имя функции есть ни что иное, как указатель на первую инструкцию этой подпрограммы.

Кроме того, функция в языке C является глобальной в рамках текущей единицы трансляции. И поэтому вызов функции - это своего рода глобальный `goto` в её тело, с последующим возвратом из него. Именно поэтому функция в языке C не может быть безымянной, потому что иначе её невозможно было бы вызвать.

λ-функция - совсем другой зверь.

### Что это такое

В основе λ-функций лежит λ-исчисление, названное так по имени красивой греческой буквы. У λ-исчисления довольно-таки долгая академическая история, но нас с вами интересует практическая сторона, поэтому сразу приведу пример.

Допустим, нам нужна функция, принимающая некое целочисленное значение и возвращающая квадрат этого значения. Такую функцию мы можем описать так:

    5 -> f -> 25 

Проще некуда: на входе - `5`, на выходе - `25`. Внутренности этой функции можно описать так:

    5 -> (x * x) -> 25

А теперь главный вопрос: как такую функцию описать формально? Вот тут-то на сцену и выходит λ-исчисление, ибо оно как раз и предлагает формализованный способ записи функции. Для нашей функции эта запись будет такой:

    λx.x * x 

Буква λ - это признак λ-функции. А читать это выражение следует так: "λ-функция (от) одного аргумента x, возвращающая результат умножения этого аргумента на самого себя".

Разделителем здесь является точка. Выражение слева от этой точки - список аргументов (в данном случае он один), а выражение справа от неё - тело функции.

Простое и элегантное описание, ничего лишнего. Нет даже имени. Особенностью λ-функции является её безымянность, ведь имя ей не нужно. И это принципиально отличает её от "обыкновенной" функции.

### Как это выглядит в коде

λ-функции присутствуют во многих языках, но в Haskell вид λ-выражения максимально приближен к математическому. Сравните:

    λx .  x * x  -- Математическая форма
    \x -> x * x  -- Haskell-форма

Прямое сходство. Даже `\` вначале подходит как нельзя лучше: рассматривайте его как "спинку" буквы λ. Единственное отличие - замена точки стрелочкой.

А теперь возникает резонный вопрос: как мы можем вызвать такую функцию? Вероятно, ответ удивит вас, но λ-функции, строго говоря, не вызывают. Впрочем, это лишь игра слов. Вернёмся на минутку в математику.

Идея λ-функции базируется на математическом принципе "аппликации" (application), или "применения". λ-функцию не вызывают с аргументом, а применяют (апплицируют) её к аргументу. Поэтому запись вида:

    f a 

принято читать так: "Применение функции `f` к аргументу `a`".

Вот как это выглядит в Haskell:

```haskell
(\x -> x * x) 5
``` 

λ-выражение, находящееся в скобках, порождает λ-функцию, которая сразу же применяется к аргументу `5`.

### Множество аргументов

λ-функция может применяться и к нескольким аргументам. Вот функция, возвращающая результат умножения первого значения на второе:

```haskell
main =
    print (f 5 6)
    where f = \arg1 arg2 -> arg1 * arg2
```

Между `\` и стрелочкой идёт список имён аргументов функции.

### Какая от них польза

В языке C принята стандартная последовательность из трёх шагов при работе с функцией:

1.  объявление,
2.  определение,
3.  вызов.

Например:

```c
int sq( int i ) {
    return i * i;
}

int main() {
    printf( "%d", sq( 5 ) );
}
```

Мы готовим нашу "глобальную подпрограмму", а потом заходим в неё через вызов.

А вот как это выглядит в Haskell:

```haskell
main = print ((\x -> x * x) 5)
```

Мы ничего не готовим заранее. Напротив, мы создаём функцию как значение, локально и непосредственно перед использованием. Создаём - и тут же применяем её к аргументу `5`.

Для простоты мы можем ввести пояснительное выражение для нашей функции:

```haskell
main =
    print (f 5)
    where f = \x -> x * x
```

Одно из преимуществ λ-функции как раз и заключается в её локальности. Зачем нам заранее объявлять и определять функцию, если мы можем создать и сразу использовать её непосредственно в том месте, где она нужна? Впрочем, если λ-функция используется в нескольких местах, мы можем, во избежание дубляжа, определить её глобально, связав с некоторым именем. Например:

```haskell
f = \x -> x * x

main = print ((f 5) + (f 6))
```

Выражение `f` равно нашей λ-функции, и теперь мы можем многократно применять это выражение к различным аргументам.

Готово. Теперь вы знаете, что такое λ-функции. Однако самое интересное их применение связано с функциями высшего порядка, о которых мы поговорим прямо сейчас.

