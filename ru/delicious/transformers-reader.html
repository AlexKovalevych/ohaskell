<!DOCTYPE html>
<html lang="ru">
    <head>
        <meta charset="utf-8">
        <meta name="description" content="О Haskell по-человечески. Книга о прекрасном и удивительном языке. Для обыкновенных программистов.">
        <meta name="author" content="Денис Шевченко">
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0" />
        
        <link rel="icon" href="../../static/images/favicon.ico">

        <title>Трансформеры: читатель</title>

        <link rel="stylesheet" href="../../static/fonts/font-awesome/css/font-awesome.min.css">

        <script src="../../static/js/jquery-2.1.4.min.js"></script>

        <!-- Compiled and minified CSS -->
        <link rel="stylesheet" href="../../static/css/materialize.min.css">

        <!-- Compiled and minified JavaScript -->
        <script src="../../static/js/materialize.min.js"></script>
        
        <!-- Own css and js -->
        <link href="../../static/css/default.css" rel="stylesheet">
        <script src="../../static/js/default.js"></script>

        <script>
          window.___gcfg = {
            lang: 'ru'
          };
        </script>

        <script src="https://apis.google.com/js/platform.js" async defer>
        </script>
    </head>

    <body>
        <div class="navbar-fixed">
            <nav>
                <div class="nav-wrapper">
                    <a href="../../ru/index.html" class="brand-logo center">
                        #ohaskell
                    </a>

                    <a href="#" data-activates="mobile-demo" class="button-collapse show-on-large" style="padding-left: 15px;">
                        <!-- <i class="material-icons">toc</i> -->
                        <i class="fa fa-list-ul" style="font-size: 30px;"></i>
                    </a>

                    <ul class="side-nav" id="mobile-demo">
                          <li><a href="../../ru/intro/who.html">Кто</a></li>
                          <li><a href="../../ru/intro/why.html">Почему</a></li>
                          <li><a href="../../ru/intro/what-for.html">Зачем</a></li>
                          <li><a href="../../ru/intro/for-whom.html">Для кого</a></li>
                        
                          <li><a href="../../ru/prepare/create-project.html">Создаём проект</a></li>
                          <li><a href="../../ru/prepare/about-modules-minimum.html">О модулях, минимум</a></li>
                          <li><a href="../../ru/prepare/about-hackage.html">О Hackage</a></li>
                          <li><a href="../../ru/prepare/about-sandbox.html">О песочнице</a></li>

                          <li><a href="../../ru/about-haskell/pure-functionality.html">Чистая функциональность</a></li>
                          <li><a href="../../ru/about-haskell/types-three-foundations.html">Три кита типизации</a></li>
                          <li><a href="../../ru/about-haskell/immutability.html">Неизменность данных</a></li>
                          <li><a href="../../ru/about-haskell/laziness.html">Лень</a></li>
                          <li><a href="../../ru/about-haskell/where.html">Где его использовать</a></li>

                          <li><a href="../../ru/about-functions/pure-functions.html">Чистые функции</a></li>
                          <li><a href="../../ru/about-functions/lambda-functions.html">λ-функции</a></li>
                          <li><a href="../../ru/about-functions/higher-order-functions.html">Функции высшего порядка</a></li>
                          <li><a href="../../ru/about-functions/functional-chains.html">Функциональные цепочки</a></li>
                          <li><a href="../../ru/about-functions/functions-and-operators.html">Функции и операторы</a></li>

                          <li><a href="../../ru/about-lists/lists-at-a-glance.html">Списки &mdash; одним взглядом</a></li>
                          <li><a href="../../ru/about-lists/ranges.html">Диапазоны</a></li>
                          <li><a href="../../ru/about-lists/tuples.html">Кортежи</a></li>
                          <li><a href="../../ru/about-lists/list-comprehension.html">Генераторы списков</a></li>

                          <li><a href="../../ru/about-user-types/types-at-a-glance.html">Типы &mdash; одним взглядом</a></li>
                          <li><a href="../../ru/about-user-types/about-value-constructors.html">О конструкторах значений</a></li>
                          <li><a href="../../ru/about-user-types/type-context.html">Контекст типа</a></li>
                          <li><a href="../../ru/about-user-types/composite-types.html">Составные типы</a></li>
                          <li><a href="../../ru/about-user-types/deriving.html">Наследуемые типы</a></li>
                          <li><a href="../../ru/about-user-types/own-type-classes.html">Собственные классы типов</a></li>
                          <li><a href="../../ru/about-user-types/newtype.html">Новый тип</a></li>

                          <li><a href="../../ru/io/functions-with-side-effects.html">Побочные эффекты</a></li>
                          <li><a href="../../ru/io/IO-a.html">IO a</a></li>
                          <li><a href="../../ru/io/do-imperative-world.html">do: императивный мир</a></li>
                          <li><a href="../../ru/io/exceptions-handling.html">Обработка исключений</a></li>
                          <li><a href="../../ru/io/own-exceptions.html">Собственные исключения</a></li>

                          <li><a href="../../ru/delicious/monads-essence.html">Монады: суть</a></li>
                          <li><a href="../../ru/delicious/monads-IO.html">Монады: на примере IO</a></li>
                          <li><a href="../../ru/delicious/monads-practice.html">Монады: практика</a></li>
                          <li><a href="../../ru/delicious/maybe.html">Может быть</a></li>
                          <li><a href="../../ru/delicious/functors.html">Функторы</a></li>
                          <li><a href="../../ru/delicious/applicative-functors.html">Аппликативные функторы</a></li>
                          <li><a href="../../ru/delicious/transformers-first-meeting.html">Трансформеры: начало</a></li>
                          <li><a href="../../ru/delicious/transformers-reader.html">Трансформеры: читатель</a></li>
                          <li><a href="../../ru/delicious/transformers-writer.html">Трансформеры: писатель</a></li>
                          <li><a href="../../ru/delicious/transformers-state.html">Трансформеры: состояние</a></li>
                          <li><a href="../../ru/delicious/transformers-error.html">Трансформеры: ошибка</a></li>

                          <li><a href="../../ru/miscellaneous/about-modules.html">О модулях</a></li>
                          <li><a href="../../ru/miscellaneous/pattern-matching.html">Сравнение с образцом</a></li>
                          <li><a href="../../ru/miscellaneous/map.html">Контейнеры: словарь</a></li>
                          <li><a href="../../ru/miscellaneous/set.html">Контейнеры: множество</a></li>
                          <li><a href="../../ru/miscellaneous/recursive-functions.html">Рекурсивные функции</a></li>
                          <li><a href="../../ru/miscellaneous/about-apostrophe.html">Про апостроф</a></li>
                          <li><a href="../../ru/miscellaneous/about-formatting.html">О форматировании</a></li>
                          <li><a href="../../ru/miscellaneous/about-hlint.html">Про hlint</a></li>

                          <li><a href="../../ru/integration/c-from-haskell.html">C из Haskell</a></li>

                          <li><a href="../../ru/end/is-this-end.html">И что, это всё??</a></li>
                          <li><a href="../../ru/end/gratitudes.html">Благодарности</a></li>
                    </ul>

                    <ul id="nav-mobile" class="right">
                        <li><a href="https://github.com/denisshevchenko/ohaskell" target="_blank"><span class="fa fa-github"></span></a></li>
                    </ul>
                </div>
            </nav>
        </div>

        <div class="container">
            <h1>Трансформеры: читатель</h1>

            <p>В этой главе мы познакомимся с монадным трансформером <code>ReaderT</code>. Это весьма любопытный инструмент, часто используемый в реальных проектах. Суть этого трансформера очень проста и элегантна.</p>
<h2 id="суть">Суть</h2>
<p><code>ReaderT</code> - это читатель. Он предоставляет неким функциям общее значение, которое можно прочесть. Такого рода задача возникает достаточно часто. Например, есть некое значение <code>A</code>, полученное откуда-то извне (скажем, из конфигурационного файла), и есть набор функций, каждой из которых позарез нужно это значение <code>A</code>. Вот <code>ReaderT</code> и предоставляет всем этим функциям общий доступ к значению <code>A</code>. И чтобы стало понятнее, рассмотрим пример.</p>
<h2 id="разбираем-git-репозиторий">Разбираем git-репозиторий</h2>
<p>Пусть нам захотелось покопаться во внутренностях тайного каталога <code>.git</code>, незримо присутствующего в наших репозиториях. Для простоты ограничимся выводом всех его внутренних каталогов. Вот как мы можем сделать это обычным способом, без <code>ReaderT</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">gitRoot <span class="fu">=</span> <span class="st">&quot;/.git/&quot;</span>

<span class="ot">getPathToBranches ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
getPathToBranches pathToRepo <span class="fu">=</span>
    <span class="st">&quot;Branches: &quot;</span> <span class="fu">++</span> pathToRepo <span class="fu">++</span> gitRoot <span class="fu">++</span> <span class="st">&quot;branches&quot;</span>

<span class="ot">getPathToHooks ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
getPathToHooks pathToRepo <span class="fu">=</span>
    <span class="st">&quot;Hooks: &quot;</span> <span class="fu">++</span> pathToRepo <span class="fu">++</span> gitRoot <span class="fu">++</span> <span class="st">&quot;hooks&quot;</span>

<span class="ot">getPathToLogs ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
getPathToLogs pathToRepo <span class="fu">=</span>
    <span class="st">&quot;Logs: &quot;</span> <span class="fu">++</span> pathToRepo <span class="fu">++</span> gitRoot <span class="fu">++</span> <span class="st">&quot;logs&quot;</span>

<span class="ot">getPathToObjects ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
getPathToObjects pathToRepo <span class="fu">=</span>
    <span class="st">&quot;Objects: &quot;</span> <span class="fu">++</span> pathToRepo <span class="fu">++</span> gitRoot <span class="fu">++</span> <span class="st">&quot;objects&quot;</span>

<span class="ot">getPathToRefs ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
getPathToRefs pathToRepo <span class="fu">=</span>
    <span class="st">&quot;Refs: &quot;</span> <span class="fu">++</span> pathToRepo <span class="fu">++</span> gitRoot <span class="fu">++</span> <span class="st">&quot;refs&quot;</span>

<span class="ot">getPathToInfo ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
getPathToInfo pathToRepo <span class="fu">=</span>
    <span class="st">&quot;Info: &quot;</span> <span class="fu">++</span> pathToRepo <span class="fu">++</span> gitRoot <span class="fu">++</span> <span class="st">&quot;info&quot;</span>

<span class="ot">showRepoInternalDirectories ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
showRepoInternalDirectories pathToRepo <span class="fu">=</span>
    <span class="kw">let</span> pathToBranches <span class="fu">=</span> getPathToBranches pathToRepo
        pathToHooks <span class="fu">=</span> getPathToHooks pathToRepo
        pathToLogs <span class="fu">=</span> getPathToLogs pathToRepo
        pathToObjects <span class="fu">=</span> getPathToObjects pathToRepo
        pathToRefs <span class="fu">=</span> getPathToRefs pathToRepo
        pathToInfo <span class="fu">=</span> getPathToInfo pathToRepo
    <span class="kw">in</span>
    concat [pathToBranches
            ,<span class="st">&quot;\n&quot;</span>, pathToHooks 
            ,<span class="st">&quot;\n&quot;</span>, pathToLogs 
            ,<span class="st">&quot;\n&quot;</span>, pathToObjects 
            ,<span class="st">&quot;\n&quot;</span>, pathToRefs 
            ,<span class="st">&quot;\n&quot;</span>, pathToInfo]

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    pathToRepo <span class="ot">&lt;-</span> readFile <span class="st">&quot;/Users/dshevchenko/my.conf&quot;</span>
    <span class="kw">let</span> pathWithoutTrailingNL <span class="fu">=</span> takeWhile (<span class="fu">/=</span> <span class="ch">'\n'</span>) pathToRepo
        finalInfo <span class="fu">=</span> showRepoInternalDirectories pathWithoutTrailingNL
    putStrLn finalInfo</code></pre></div>
<p>Всё просто: забираем строку из файла <code>my.conf</code> и передаём её нескольким функциям, каждая из которых указывает путь к соответствующему внутреннему служебному каталогу. Для краткости все проверки файла <code>my.conf</code> опущены: такой файл существует, мы можем его прочитать и в нём действительно лежит путь к некоторому репозиторию. Вот результат работы такого кода:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">Branches</span>: /Users/dshevchenko/repo1/.git/branches
<span class="kw">Hooks</span>: /Users/dshevchenko/repo1/.git/hooks
<span class="kw">Logs</span>: /Users/dshevchenko/repo1/.git/logs
<span class="kw">Objects</span>: /Users/dshevchenko/repo1/.git/objects
<span class="kw">Refs</span>: /Users/dshevchenko/repo1/.git/refs
<span class="kw">Info</span>: /Users/dshevchenko/repo1/.git/info</code></pre></div>
<p>Кстати, мы использовали новую функцию <code>concat</code>. Эта стандартная функция принимает список строк и объединяет их в одну. Да, мы могли бы воспользоваться оператором <code>++</code>, но с функцией <code>concat</code> красивше получилось.</p>
<h2 id="ложечка-дёгтя">Ложечка дёгтя</h2>
<p>И всё бы хорошо с этим примером, но кое-что цепляет глаз. Получив путь к репозиторию, мы вынуждены явно передавать его в качестве аргумента всем нашим функциям: сначала функции <code>showRepoInternalDirectories</code>, а затем всем вспомогательным функциям. Это выглядит громоздко. Тут-то и выходит на сцену наш читатель. Но прежде чем мы рассмотрим решение на его основе, немного теории.</p>
<h2 id="совсем-немного-теории">Совсем немного теории</h2>
<p>Вот что представляет собою тип <code>ReaderT</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">ReaderT</span> r m a </code></pre></div>
<p>Перед нами конструктор типа, параметризованный тремя значениями: * <code>r</code> - общее значение, * <code>m</code> - некая монада, * <code>a</code> - значение внутри этой монады.</p>
<p>Общее значение - это наш главный герой, ради которого всё и затевалось. Иногда его ещё называют “shared environment value”. Вы уже догадались, как это относится к нашему примеру, не так ли? Ведь у нас имеется такое общее значение, а именно полученный из конфигурационного файла путь к репозиторию! Раз этот путь нужен всем нашим функциям, мы помещаем его в общую среду (“shared environment”), к которой можно будет получить доступ. В этом и есть суть <code>ReaderT</code>: он, грубо говоря, предоставляет глобальную переменную, видимую всем нашим функциям.</p>
<p>Перейдём к <del>магии</del> практике.</p>
<h2 id="магия-практика"><del>Магия</del> Практика</h2>
<p>Определим конкретный тип для нашего случая:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.Reader</span>

<span class="kw">type</span> <span class="dt">Environment</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">PathReader</span> <span class="fu">=</span> <span class="dt">ReaderT</span> <span class="dt">Environment</span> <span class="dt">IO</span> <span class="dt">String</span></code></pre></div>
<p>Значение типа <code>Environment</code> - это и есть наше общее значение, в котором будет храниться путь к репозиторию. А вот теперь начинается немного магии. Перепишем первую вспомогательную функцию, выводящую путь к каталогу <code>branches</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">getPathToBranches ::</span> <span class="dt">PathReader</span>
getPathToBranches <span class="fu">=</span> <span class="kw">do</span>
    pathToRepo <span class="ot">&lt;-</span> ask
    return <span class="fu">$</span> <span class="st">&quot;Branches: &quot;</span> <span class="fu">++</span> pathToRepo <span class="fu">++</span> gitRoot <span class="fu">++</span> <span class="st">&quot;branches&quot;</span></code></pre></div>
<p>Необычно выглядит, не правда ли? Аргумент <code>pathToRepo</code> пропал, а возвращается уже не строка, а наш читатель. Интересной здесь является вот эта строка:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    pathToRepo <span class="ot">&lt;-</span> ask</code></pre></div>
<p>Функция <code>ask</code> имеет непосредственное отношение к <code>ReaderT</code>. Она запрашивает (англ. “ask”) ту самую строку из общей среды читателя. Значение, возвращаемое функцией <code>ask</code>, имеет монадический тип <code>ReaderT Environment</code>, поэтому идентификатор <code>pathToRepo</code> ассоциирован уже с <code>Environment</code>, то есть с этой самой строкой. И чтобы работа функции <code>ask</code> стала ещё яснее, вспомним получение пользовательской строки:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">getStringFromUser ::</span> <span class="dt">IO</span> <span class="dt">String</span>
getStringFromUser <span class="fu">=</span> <span class="kw">do</span>
    stringFromUser <span class="ot">&lt;-</span> getLine
    <span class="fu">...</span></code></pre></div>
<p>Подобно тому, как функция <code>getLine</code> идёт во внешний мир, ассоциированный с монадой <code>IO</code>, чтобы принести оттуда введённую пользователем строку, функция <code>ask</code> идёт в общую среду, ассоциированную с монадой <code>ReaderT</code>, чтобы принести оттуда то самое общее значение.</p>
<p>В этом и заключается маленькое волшебство <code>ReaderT</code>: общее значение уже не нужно явно передавать в виде аргумента, поскольку оно как бы незримо парит в воздухе, и теперь все наши функции могут запрашивать его с помощью функции <code>ask</code>. И поэтому теперь функция <code>showRepoInternalDirectories</code> выглядит так:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">showRepoInternalDirectories ::</span> <span class="dt">PathReader</span> 
showRepoInternalDirectories <span class="fu">=</span> <span class="kw">do</span>
    pathToBranches <span class="ot">&lt;-</span> getPathToBranches
    pathToHooks <span class="ot">&lt;-</span> getPathToHooks
    pathToLogs <span class="ot">&lt;-</span> getPathToLogs
    pathToObjects <span class="ot">&lt;-</span> getPathToObjects
    pathToRefs <span class="ot">&lt;-</span> getPathToRefs
    pathToInfo <span class="ot">&lt;-</span> getPathToInfo
    return <span class="fu">$</span> concat [pathToBranches
                     ,<span class="st">&quot;\n&quot;</span>, pathToHooks 
                     ,<span class="st">&quot;\n&quot;</span>, pathToLogs 
                     ,<span class="st">&quot;\n&quot;</span>, pathToObjects 
                     ,<span class="st">&quot;\n&quot;</span>, pathToRefs 
                     ,<span class="st">&quot;\n&quot;</span>, pathToInfo]</code></pre></div>
<p>Аргументов больше нет, есть лишь общая среда.</p>
<p>Но как же наша строка, извлечённая из конфигурационного файла, окажется в той самой общей среде читателя? Пришло время взглянуть на обновлённую <code>main</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    pathToRepo <span class="ot">&lt;-</span> readFile <span class="st">&quot;/Users/dshevchenko/my.conf&quot;</span>
    <span class="kw">let</span> pathWithoutTrailingNL <span class="fu">=</span> takeWhile (<span class="fu">/=</span> <span class="ch">'\n'</span>) pathToRepo
    finalInfo <span class="ot">&lt;-</span> runReaderT showRepoDirectories 
                            pathWithoutTrailingNL
    putStrLn finalInfo</code></pre></div>
<p>Функция <code>runReaderT</code> - это волшебная палочка, запускающая (англ. “run”) вышеупомянутую магию. Принимая в качестве первого аргумента функцию <code>showRepoDirectories</code>, а качестве второго - тот самый путь из конфигурационного файла, функция <code>runReaderT</code> создаёт общую среду, с которой и работают все наши функции. Грубо говоря, <code>runReaderT</code> создаёт облако и помещает в него значение <code>pathWithoutTrailingNL</code>. Вот такие “облачные технологии” внутри Haskell… :-)</p>
<h2 id="разоблачение-монады-reader">Разоблачение монады Reader</h2>
<p>Если вы прочли <a href="http://ohaskell.dshevchenko.biz/ru/delicious/transformers-first-meeting.html">главу о первой встрече с трансформерами</a>, у вас, очевидно, возник вопрос о монаде <code>Reader</code>. Ведь, как мы помним, монадный трансформер - это монадическая матрёшка два-в-одном: берём одну монаду и добавляем к ней функциональность другой монады. Мы видели это на примере <code>MaybeT</code>: есть монада <code>Maybe</code>, а есть трансформер <code>MaybeT</code>, привносящий <code>Maybe</code>-опциональность в некую другую монаду.</p>
<p>Следовательно, раз есть монадный трансформер <code>ReaderT</code>, должна быть и монада <code>Reader</code>, не так ли? Но если так, почему же мы сразу взялись за рассмотрение трансформера?</p>
<p>Пришло время узнать правду. А правда в том, что монада <code>Reader</code>… это и есть трансформер <code>ReaderT</code>. Взглянем на определение в модуле <code>Control.Monad.Reader</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Reader</span> r <span class="fu">=</span> <span class="dt">ReaderT</span> r <span class="dt">Identity</span></code></pre></div>
<p>Вот и вся правда: тип <code>Reader</code> есть не более чем псевдоним для <code>ReaderT</code>. Таким образом, если монада <code>Maybe</code> является самостоятельным типом и ничего не знает о трансформере <code>MaybeT</code>, монада <code>Reader</code>, напротив, является <em>частным случаем</em> трансформера <code>ReaderT</code>.</p>
<h2 id="зачем-нужна-reader">Зачем нужна Reader</h2>
<p>Для простоты. Вы обратили внимание, что тип <code>Reader</code> в качестве монады использует тип <code>Identity</code>? Это и делает тип <code>Reader</code> простейшим вариантом трансформера <code>ReaderT</code>, поскольку монада <code>Identity</code> - это самая простая стандартная монада из всех существующих, даже проще чем <code>Maybe</code>. <code>Identity</code> живёт в пакете <code>transformers</code> и представляет собою монаду-пустышку. Она настолько примитивна, что сама по себе не имеет никакой ценности. Взгляните:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Identity</span> a <span class="fu">=</span> <span class="dt">Identity</span> a
    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Read</span>, <span class="dt">Show</span>)

<span class="ot">runIdentity ::</span> <span class="dt">Identity</span> a <span class="ot">-&gt;</span> a
runIdentity (<span class="dt">Identity</span> x) <span class="fu">=</span> x

<span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Identity</span> <span class="kw">where</span>
    return a <span class="fu">=</span> <span class="dt">Identity</span> a
    m <span class="fu">&gt;&gt;=</span> k  <span class="fu">=</span> k (runIdentity m)</code></pre></div>
<p>Грубо говоря, это как <code>Maybe</code> с одним лишь конструктором <code>Just</code>. Единственное назначение этой монады - быть монадой-пустышкой. Поэтому, когда мы пишем так:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">PathReader</span> <span class="fu">=</span> <span class="dt">ReaderT</span> <span class="dt">Environment</span> <span class="dt">Identity</span> <span class="dt">String</span></code></pre></div>
<p>или так:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">PathReader</span> <span class="fu">=</span> <span class="dt">Reader</span> <span class="dt">Environment</span> <span class="dt">String</span></code></pre></div>
<p>то говорим: “Да, тип <code>PathReader</code> по-прежнему содержит в себе значение типа <code>String</code>, завёрнутое в монадическую обёртку, но обёртка эта столь примитивна, что её как будто и нет вовсе.” Поэтому при использовании <code>Reader</code> мы можем вообще не думать о внутренней монаде.</p>
<p>Это позволит нам упростить наш пример и написать так:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Environment</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">PathReader</span> <span class="fu">=</span> <span class="dt">Reader</span> <span class="dt">Environment</span> <span class="dt">String</span>

<span class="co">-- Все остальные функции остаются без изменений...</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    pathToRepo <span class="ot">&lt;-</span> readFile <span class="st">&quot;/Users/dshevchenko/my.conf&quot;</span>
    <span class="kw">let</span> pathWithoutTrailingNL <span class="fu">=</span> takeWhile (<span class="fu">/=</span> <span class="ch">'\n'</span>) pathToRepo
        <span class="co">-- runReader сразу вернёт String, а не IO String... </span>
        finalInfo <span class="fu">=</span> runReader showRepoInternalDirectories 
                              pathWithoutTrailingNL
    putStrLn finalInfo</code></pre></div>
<p>В самом деле, зачем нам внутренняя монада <code>IO</code> в нашем <code>PathReader</code>? В данном случае мы легко можем обойтись и без неё. Так и определение типа <code>PathReader</code> упрощается, и в функции <code>main</code> мы имеем дело сразу с результирующей строкой, без <code>IO</code>-обёртки. Обратите внимание, мы используем уже не <code>runReaderT</code>, а <code>runReader</code>.</p>
<h2 id="реальный-пример">Реальный пример</h2>
<p>Этот небольшой пример основан на использовании прекрасного пакета <code>direct-fastcgi</code>, предназначенного для создания FastCGI-скриптов. В центре нашего внимания - обработчик запросов, приходящих к нашему приложению от веб-сервера. Итак:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">handleRequest ::</span> <span class="dt">FastCGI</span> ()
handleRequest <span class="fu">=</span> <span class="kw">do</span>
    fPutStr <span class="st">&quot;Hello from Haskell world!&quot;</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> acceptLoop forkIO handleRequest</code></pre></div>
<p>Функция <code>handleRequest</code> обрабатывает поступивший запрос. А вот определение типа <code>FastCGI</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">FastCGI</span> <span class="fu">=</span> <span class="dt">ReaderT</span> <span class="dt">FastCGIState</span> <span class="dt">IO</span></code></pre></div>
<p>Вот он, наш старый друг! Использование <code>ReaderT</code> в данном случае очень удобно: мы получили из внешнего мира запрос и поместили его в наше общее “облако”. Функции <code>handleRequest</code> обязательно понадобится доступ к параметрам запроса, чтобы адекватно на него ответить. И именно благодаря <code>ReaderT</code> работа с этими параметрами очень удобна. Например:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">handleRequest ::</span> <span class="dt">FastCGI</span> ()
handleRequest <span class="fu">=</span> <span class="kw">do</span>
    queryString <span class="ot">&lt;-</span> getQueryString
    setResponseStatus <span class="dv">404</span>
    setResponseHeader <span class="dt">HttpContentType</span> <span class="st">&quot;text/plain&quot;</span>
    fPutStr <span class="fu">$</span> <span class="st">&quot;Test: &quot;</span> <span class="fu">++</span> queryString</code></pre></div>
<p>Все четыре использованные в обработчике функции работают со значением типа <code>FastCGIState</code>, но это значение не передаётся им в качестве аргумента. Однако вы уже знаете, в чём здесь секрет: каждая из этих функций извлекает значение типа <code>FastCGIState</code> из “общего облака” монады <code>ReaderT</code>. В итоге получаем красивый и компактный код.</p>
<h2 id="в-сухом-остатке">В сухом остатке</h2>
<ol style="list-style-type: decimal">
<li>Трансформер <code>ReaderT</code> полезен тогда, когда группе функций нужен доступ к некоторому общему значению.</li>
<li>Функция <code>runReaderT</code> инициализирует “облако” с общим значением и запускает работу с ним.</li>
<li>Каждая из функций, используя <code>ask</code>, “магически” извлекает общее значение из “облака”.</li>
<li>Монада <code>Reader</code> - это простейший вариант трансформера <code>ReaderT</code>.</li>
</ol>

<div style="padding-top: 30px;"><div>
<div class="row">
    <div class="col s6">
        <div class="left">
            <a href="../../ru/delicious/transformers-first-meeting.html" class="btn waves-effect waves-light chapter-arrow">
                <span class="fa fa-angle-double-left"></span>
            </a>
        </div>
    </div>
    
    <div class="col s6">
        <div class="right">
            <a href="../../ru/delicious/transformers-writer.html" class="btn waves-effect waves-light chapter-arrow">
                <span class="fa fa-angle-double-right"></span>
            </a>
        </div>
    </div>
</div>
<div style="padding-top: 40px;"><div>

<!--
<div>
    <script>
      (function() {
        var cx = '007697214108744450483:au850gpbupm';
        var gcse = document.createElement('script');
        gcse.type = 'text/javascript';
        gcse.async = true;
        gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
            '//cse.google.com/cse.js?cx=' + cx;
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(gcse, s);
      })();
    </script>
    <gcse:search></gcse:search>
</div>
-->

<!--
<div>
    <div class="row">
        <form class="col s12" 
              id="searchbox_007697214108744450483:au850gpbupm" 
              action="http://www.google.com/cse">
          <div class="row">
            <div class="input-field col s6">
              <i class="material-icons prefix">search</i>

              <input value="007697214108744450483:au850gpbupm" name="cx" type="hidden"/>
              <input value="FORID:11" name="cof" type="hidden"/>

              <input id="icon_prefix" name="q" type="text"/>
              <label for="icon_prefix">Что ищем?</label>
            </div>
          </div>
        </form>
    </div>
</div>
-->

<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'ohaskell'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
 

        </div>
    </body>
</html>