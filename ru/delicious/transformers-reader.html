<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content>
        <meta name="author" content="Денис Шевченко">
        <link rel="icon" href="../../static/images/favicon.ico">

        <title>Трансформеры: читатель</title>

        <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>

        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">

        <link href="../../static/css/default.css" rel="stylesheet">
        
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>

        <script>
          window.___gcfg = {
            lang: 'ru'
          };
        </script>

        <script src="https://apis.google.com/js/platform.js" async defer>
        </script>
    </head>

  <body>
    <div class="container">
        <nav class="navbar navbar-default navbar-fixed-top">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <div id="logo">
                <a class="navbar-brand" href="../../ru/index.html" title="Домой">
                  О Haskell по-человечески
                </a>
              </div>
            </div>
            
            <div id="navbar" class="collapse navbar-collapse">
              <ul class="nav navbar-nav navbar-right">
                <li><a href="../../ru/chapters.html" target="_blank">Оглавление</a></li>
              </ul>
            </div>
          </div>
        </nav>

        <div id="content">
            <h1>Трансформеры: читатель</h1>

            <div class="row">
    <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6">
        <div class="clear-button text-left">
            <div class="chapters-selector">
                <a href="../../ru/delicious/transformers-first-meeting.html" title="Предыдущая глава"><span class="fa fa-hand-o-left"></span></a>
            </div>
        </div>
    </div>
    
    <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6">
        <div class="clear-button text-right">
            <div class="chapters-selector">
                <a href="../../ru/delicious/transformers-writer.html" title="Следующая глава"><span class="fa fa-hand-o-right"></span></a>
            </div>
        </div>
    </div>
</div>
<div style="padding-top: 40px;"><div>

<p>В этой главе мы познакомимся с монадным трансформером <code>ReaderT</code>. Это весьма любопытный инструмент, часто используемый в реальных проектах. Суть этого трансформера очень проста и элегантна.</p>
<h2 id="суть">Суть</h2>
<p><code>ReaderT</code> - это читатель. Он предоставляет неким функциям общее значение, которое можно прочесть. Такого рода задача возникает достаточно часто. Например, есть некое значение <code>A</code>, полученное откуда-то извне (скажем, из конфигурационного файла), и есть набор функций, каждой из которых позарез нужно это значение <code>A</code>. Вот <code>ReaderT</code> и предоставляет всем этим функциям общий доступ к значению <code>A</code>. И чтобы стало понятнее, рассмотрим пример.</p>
<h2 id="разбираем-git-репозиторий">Разбираем git-репозиторий</h2>
<p>Пусть нам захотелось покопаться во внутренностях тайного каталога <code>.git</code>, незримо присутствующего в наших репозиториях. Для простоты ограничимся выводом всех его внутренних каталогов. Вот как мы можем сделать это обычным способом, без <code>ReaderT</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">gitRoot <span class="fu">=</span> <span class="st">&quot;/.git/&quot;</span>

<span class="ot">getPathToBranches ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
getPathToBranches pathToRepo <span class="fu">=</span>
    <span class="st">&quot;Branches: &quot;</span> <span class="fu">++</span> pathToRepo <span class="fu">++</span> gitRoot <span class="fu">++</span> <span class="st">&quot;branches&quot;</span>

<span class="ot">getPathToHooks ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
getPathToHooks pathToRepo <span class="fu">=</span>
    <span class="st">&quot;Hooks: &quot;</span> <span class="fu">++</span> pathToRepo <span class="fu">++</span> gitRoot <span class="fu">++</span> <span class="st">&quot;hooks&quot;</span>

<span class="ot">getPathToLogs ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
getPathToLogs pathToRepo <span class="fu">=</span>
    <span class="st">&quot;Logs: &quot;</span> <span class="fu">++</span> pathToRepo <span class="fu">++</span> gitRoot <span class="fu">++</span> <span class="st">&quot;logs&quot;</span>

<span class="ot">getPathToObjects ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
getPathToObjects pathToRepo <span class="fu">=</span>
    <span class="st">&quot;Objects: &quot;</span> <span class="fu">++</span> pathToRepo <span class="fu">++</span> gitRoot <span class="fu">++</span> <span class="st">&quot;objects&quot;</span>

<span class="ot">getPathToRefs ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
getPathToRefs pathToRepo <span class="fu">=</span>
    <span class="st">&quot;Refs: &quot;</span> <span class="fu">++</span> pathToRepo <span class="fu">++</span> gitRoot <span class="fu">++</span> <span class="st">&quot;refs&quot;</span>

<span class="ot">getPathToInfo ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
getPathToInfo pathToRepo <span class="fu">=</span>
    <span class="st">&quot;Info: &quot;</span> <span class="fu">++</span> pathToRepo <span class="fu">++</span> gitRoot <span class="fu">++</span> <span class="st">&quot;info&quot;</span>

<span class="ot">showRepoInternalDirectories ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
showRepoInternalDirectories pathToRepo <span class="fu">=</span>
    <span class="kw">let</span> pathToBranches <span class="fu">=</span> getPathToBranches pathToRepo
        pathToHooks <span class="fu">=</span> getPathToHooks pathToRepo
        pathToLogs <span class="fu">=</span> getPathToLogs pathToRepo
        pathToObjects <span class="fu">=</span> getPathToObjects pathToRepo
        pathToRefs <span class="fu">=</span> getPathToRefs pathToRepo
        pathToInfo <span class="fu">=</span> getPathToInfo pathToRepo
    <span class="kw">in</span>
    concat [pathToBranches
            ,<span class="st">&quot;\n&quot;</span>, pathToHooks 
            ,<span class="st">&quot;\n&quot;</span>, pathToLogs 
            ,<span class="st">&quot;\n&quot;</span>, pathToObjects 
            ,<span class="st">&quot;\n&quot;</span>, pathToRefs 
            ,<span class="st">&quot;\n&quot;</span>, pathToInfo]

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    pathToRepo <span class="ot">&lt;-</span> readFile <span class="st">&quot;/Users/dshevchenko/my.conf&quot;</span>
    <span class="kw">let</span> pathWithoutTrailingNL <span class="fu">=</span> takeWhile (<span class="fu">/=</span> <span class="ch">'\n'</span>) pathToRepo
        finalInfo <span class="fu">=</span> showRepoInternalDirectories pathWithoutTrailingNL
    putStrLn finalInfo</code></pre>
<p>Всё просто: забираем строку из файла <code>my.conf</code> и передаём её нескольким функциям, каждая из которых указывает путь к соответствующему внутреннему служебному каталогу. Для краткости все проверки файла <code>my.conf</code> опущены: такой файл существует, мы можем его прочитать и в нём действительно лежит путь к некоторому репозиторию. Вот результат работы такого кода:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">Branches</span>: /Users/dshevchenko/repo1/.git/branches
<span class="kw">Hooks</span>: /Users/dshevchenko/repo1/.git/hooks
<span class="kw">Logs</span>: /Users/dshevchenko/repo1/.git/logs
<span class="kw">Objects</span>: /Users/dshevchenko/repo1/.git/objects
<span class="kw">Refs</span>: /Users/dshevchenko/repo1/.git/refs
<span class="kw">Info</span>: /Users/dshevchenko/repo1/.git/info</code></pre>
<p>Кстати, мы использовали новую функцию <code>concat</code>. Эта стандартная функция принимает список строк и объединяет их в одну. Да, мы могли бы воспользоваться оператором <code>++</code>, но с функцией <code>concat</code> красивше получилось.</p>
<h2 id="ложечка-дёгтя">Ложечка дёгтя</h2>
<p>И всё бы хорошо с этим примером, но кое-что цепляет глаз. Получив путь к репозиторию, мы вынуждены явно передавать его в качестве аргумента всем нашим функциям: сначала функции <code>showRepoInternalDirectories</code>, а затем всем вспомогательным функциям. Это выглядит громоздко. Тут-то и выходит на сцену наш читатель. Но прежде чем мы рассмотрим решение на его основе, немного теории.</p>
<h2 id="совсем-немного-теории">Совсем немного теории</h2>
<p>Вот что представляет собою тип <code>ReaderT</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">ReaderT</span> r m a </code></pre>
<p>Перед нами конструктор типа, параметризованный тремя значениями: * <code>r</code> - общее значение, * <code>m</code> - некая монада, * <code>a</code> - значение внутри этой монады.</p>
<p>Общее значение - это наш главный герой, ради которого всё и затевалось. Иногда его ещё называют “shared environment value”. Вы уже догадались, как это относится к нашему примеру, не так ли? Ведь у нас имеется такое общее значение, а именно полученный из конфигурационного файла путь к репозиторию! Раз этот путь нужен всем нашим функциям, мы помещаем его в общую среду (“shared environment”), к которой можно будет получить доступ. В этом и есть суть <code>ReaderT</code>: он, грубо говоря, предоставляет глобальную переменную, видимую всем нашим функциям.</p>
<p>Перейдём к <del>магии</del> практике.</p>
<h2 id="магия-практика"><del>Магия</del> Практика</h2>
<p>Определим конкретный тип для нашего случая:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.Reader</span>

<span class="kw">type</span> <span class="dt">Environment</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">PathReader</span> <span class="fu">=</span> <span class="dt">ReaderT</span> <span class="dt">Environment</span> <span class="dt">IO</span> <span class="dt">String</span></code></pre>
<p>Значение типа <code>Environment</code> - это и есть наше общее значение, в котором будет храниться путь к репозиторию. А вот теперь начинается немного магии. Перепишем первую вспомогательную функцию, выводящую путь к каталогу <code>branches</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">getPathToBranches ::</span> <span class="dt">PathReader</span>
getPathToBranches <span class="fu">=</span> <span class="kw">do</span>
    pathToRepo <span class="ot">&lt;-</span> ask
    return <span class="fu">$</span> <span class="st">&quot;Branches: &quot;</span> <span class="fu">++</span> pathToRepo <span class="fu">++</span> gitRoot <span class="fu">++</span> <span class="st">&quot;branches&quot;</span></code></pre>
<p>Необычно выглядит, не правда ли? Аргумент <code>pathToRepo</code> пропал, а возвращается уже не строка, а наш читатель. Интересной здесь является вот эта строка:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    pathToRepo <span class="ot">&lt;-</span> ask</code></pre>
<p>Функция <code>ask</code> имеет непосредственное отношение к <code>ReaderT</code>. Она запрашивает (англ. “ask”) ту самую строку из общей среды читателя. Значение, возвращаемое функцией <code>ask</code>, имеет монадический тип <code>ReaderT Environment</code>, поэтому идентификатор <code>pathToRepo</code> ассоциирован уже с <code>Environment</code>, то есть с этой самой строкой. И чтобы работа функции <code>ask</code> стала ещё яснее, вспомним получение пользовательской строки:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">getStringFromUser ::</span> <span class="dt">IO</span> <span class="dt">String</span>
getStringFromUser <span class="fu">=</span> <span class="kw">do</span>
    stringFromUser <span class="ot">&lt;-</span> getLine
    <span class="fu">...</span></code></pre>
<p>Подобно тому, как функция <code>getLine</code> идёт во внешний мир, ассоциированный с монадой <code>IO</code>, чтобы принести оттуда введённую пользователем строку, функция <code>ask</code> идёт в общую среду, ассоциированную с монадой <code>ReaderT</code>, чтобы принести оттуда то самое общее значение.</p>
<p>В этом и заключается маленькое волшебство <code>ReaderT</code>: общее значение уже не нужно явно передавать в виде аргумента, поскольку оно как бы незримо парит в воздухе, и теперь все наши функции могут запрашивать его с помощью функции <code>ask</code>. И поэтому теперь функция <code>showRepoInternalDirectories</code> выглядит так:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">showRepoInternalDirectories ::</span> <span class="dt">PathReader</span> 
showRepoInternalDirectories <span class="fu">=</span> <span class="kw">do</span>
    pathToBranches <span class="ot">&lt;-</span> getPathToBranches
    pathToHooks <span class="ot">&lt;-</span> getPathToHooks
    pathToLogs <span class="ot">&lt;-</span> getPathToLogs
    pathToObjects <span class="ot">&lt;-</span> getPathToObjects
    pathToRefs <span class="ot">&lt;-</span> getPathToRefs
    pathToInfo <span class="ot">&lt;-</span> getPathToInfo
    return <span class="fu">$</span> concat [pathToBranches
                     ,<span class="st">&quot;\n&quot;</span>, pathToHooks 
                     ,<span class="st">&quot;\n&quot;</span>, pathToLogs 
                     ,<span class="st">&quot;\n&quot;</span>, pathToObjects 
                     ,<span class="st">&quot;\n&quot;</span>, pathToRefs 
                     ,<span class="st">&quot;\n&quot;</span>, pathToInfo]</code></pre>
<p>Аргументов больше нет, есть лишь общая среда.</p>
<p>Но как же наша строка, извлечённая из конфигурационного файла, окажется в той самой общей среде читателя? Пришло время взглянуть на обновлённую <code>main</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    pathToRepo <span class="ot">&lt;-</span> readFile <span class="st">&quot;/Users/dshevchenko/my.conf&quot;</span>
    <span class="kw">let</span> pathWithoutTrailingNL <span class="fu">=</span> takeWhile (<span class="fu">/=</span> <span class="ch">'\n'</span>) pathToRepo
    finalInfo <span class="ot">&lt;-</span> runReaderT showRepoDirectories 
                            pathWithoutTrailingNL
    putStrLn finalInfo</code></pre>
<p>Функция <code>runReaderT</code> - это волшебная палочка, запускающая (англ. “run”) вышеупомянутую магию. Принимая в качестве первого аргумента функцию <code>showRepoDirectories</code>, а качестве второго - тот самый путь из конфигурационного файла, функция <code>runReaderT</code> создаёт общую среду, с которой и работают все наши функции. Грубо говоря, <code>runReaderT</code> создаёт облако и помещает в него значение <code>pathWithoutTrailingNL</code>. Вот такие “облачные технологии” внутри Haskell… :-)</p>
<h2 id="разоблачение-монады-reader">Разоблачение монады Reader</h2>
<p>Если вы прочли <a href="http://ohaskell.dshevchenko.biz/ru/delicious/transformers-first-meeting.html">главу о первой встрече с трансформерами</a>, у вас, очевидно, возник вопрос о монаде <code>Reader</code>. Ведь, как мы помним, монадный трансформер - это монадическая матрёшка два-в-одном: берём одну монаду и добавляем к ней функциональность другой монады. Мы видели это на примере <code>MaybeT</code>: есть монада <code>Maybe</code>, а есть трансформер <code>MaybeT</code>, привносящий <code>Maybe</code>-опциональность в некую другую монаду.</p>
<p>Следовательно, раз есть монадный трансформер <code>ReaderT</code>, должна быть и монада <code>Reader</code>, не так ли? Но если так, почему же мы сразу взялись за рассмотрение трансформера?</p>
<p>Пришло время узнать правду. А правда в том, что монада <code>Reader</code>… это и есть трансформер <code>ReaderT</code>. Взглянем на определение в модуле <code>Control.Monad.Reader</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Reader</span> r <span class="fu">=</span> <span class="dt">ReaderT</span> r <span class="dt">Identity</span></code></pre>
<p>Вот и вся правда: тип <code>Reader</code> есть не более чем псевдоним для <code>ReaderT</code>. Таким образом, если монада <code>Maybe</code> является самостоятельным типом и ничего не знает о трансформере <code>MaybeT</code>, монада <code>Reader</code>, напротив, является <em>частным случаем</em> трансформера <code>ReaderT</code>.</p>
<h2 id="зачем-нужна-reader">Зачем нужна Reader</h2>
<p>Для простоты. Вы обратили внимание, что тип <code>Reader</code> в качестве монады использует тип <code>Identity</code>? Это и делает тип <code>Reader</code> простейшим вариантом трансформера <code>ReaderT</code>, поскольку монада <code>Identity</code> - это самая простая стандартная монада из всех существующих, даже проще чем <code>Maybe</code>. <code>Identity</code> живёт в пакете <code>transformers</code> и представляет собою монаду-пустышку. Она настолько примитивна, что сама по себе не имеет никакой ценности. Взгляните:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Identity</span> a <span class="fu">=</span> <span class="dt">Identity</span> a
    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Read</span>, <span class="dt">Show</span>)

<span class="ot">runIdentity ::</span> <span class="dt">Identity</span> a <span class="ot">-&gt;</span> a
runIdentity (<span class="dt">Identity</span> x) <span class="fu">=</span> x

<span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Identity</span> <span class="kw">where</span>
    return a <span class="fu">=</span> <span class="dt">Identity</span> a
    m <span class="fu">&gt;&gt;=</span> k  <span class="fu">=</span> k (runIdentity m)</code></pre>
<p>Грубо говоря, это как <code>Maybe</code> с одним лишь конструктором <code>Just</code>. Единственное назначение этой монады - быть монадой-пустышкой. Поэтому, когда мы пишем так:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">PathReader</span> <span class="fu">=</span> <span class="dt">ReaderT</span> <span class="dt">Environment</span> <span class="dt">Identity</span> <span class="dt">String</span></code></pre>
<p>или так:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">PathReader</span> <span class="fu">=</span> <span class="dt">Reader</span> <span class="dt">Environment</span> <span class="dt">String</span></code></pre>
<p>то говорим: “Да, тип <code>PathReader</code> по-прежнему содержит в себе значение типа <code>String</code>, завёрнутое в монадическую обёртку, но обёртка эта столь примитивна, что её как будто и нет вовсе.” Поэтому при использовании <code>Reader</code> мы можем вообще не думать о внутренней монаде.</p>
<p>Это позволит нам упростить наш пример и написать так:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Environment</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">PathReader</span> <span class="fu">=</span> <span class="dt">Reader</span> <span class="dt">Environment</span> <span class="dt">String</span>

<span class="co">-- Все остальные функции остаются без изменений...</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    pathToRepo <span class="ot">&lt;-</span> readFile <span class="st">&quot;/Users/dshevchenko/my.conf&quot;</span>
    <span class="kw">let</span> pathWithoutTrailingNL <span class="fu">=</span> takeWhile (<span class="fu">/=</span> <span class="ch">'\n'</span>) pathToRepo
        <span class="co">-- runReader сразу вернёт String, а не IO String... </span>
        finalInfo <span class="fu">=</span> runReader showRepoInternalDirectories 
                              pathWithoutTrailingNL
    putStrLn finalInfo</code></pre>
<p>В самом деле, зачем нам внутренняя монада <code>IO</code> в нашем <code>PathReader</code>? В данном случае мы легко можем обойтись и без неё. Так и определение типа <code>PathReader</code> упрощается, и в функции <code>main</code> мы имеем дело сразу с результирующей строкой, без <code>IO</code>-обёртки. Обратите внимание, мы используем уже не <code>runReaderT</code>, а <code>runReader</code>.</p>
<h2 id="реальный-пример">Реальный пример</h2>
<p>Этот небольшой пример основан на использовании прекрасного пакета <code>direct-fastcgi</code>, предназначенного для создания FastCGI-скриптов. В центре нашего внимания - обработчик запросов, приходящих к нашему приложению от веб-сервера. Итак:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">handleRequest ::</span> <span class="dt">FastCGI</span> ()
handleRequest <span class="fu">=</span> <span class="kw">do</span>
    fPutStr <span class="st">&quot;Hello from Haskell world!&quot;</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> acceptLoop forkIO handleRequest</code></pre>
<p>Функция <code>handleRequest</code> обрабатывает поступивший запрос. А вот определение типа <code>FastCGI</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">FastCGI</span> <span class="fu">=</span> <span class="dt">ReaderT</span> <span class="dt">FastCGIState</span> <span class="dt">IO</span></code></pre>
<p>Вот он, наш старый друг! Использование <code>ReaderT</code> в данном случае очень удобно: мы получили из внешнего мира запрос и поместили его в наше общее “облако”. Функции <code>handleRequest</code> обязательно понадобится доступ к параметрам запроса, чтобы адекватно на него ответить. И именно благодаря <code>ReaderT</code> работа с этими параметрами очень удобна. Например:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">handleRequest ::</span> <span class="dt">FastCGI</span> ()
handleRequest <span class="fu">=</span> <span class="kw">do</span>
    queryString <span class="ot">&lt;-</span> getQueryString
    setResponseStatus <span class="dv">404</span>
    setResponseHeader <span class="dt">HttpContentType</span> <span class="st">&quot;text/plain&quot;</span>
    fPutStr <span class="fu">$</span> <span class="st">&quot;Test: &quot;</span> <span class="fu">++</span> queryString</code></pre>
<p>Все четыре использованные в обработчике функции работают со значением типа <code>FastCGIState</code>, но это значение не передаётся им в качестве аргумента. Однако вы уже знаете, в чём здесь секрет: каждая из этих функций извлекает значение типа <code>FastCGIState</code> из “общего облака” монады <code>ReaderT</code>. В итоге получаем красивый и компактный код.</p>
<h2 id="в-сухом-остатке">В сухом остатке</h2>
<ul>
<li>Трансформер <code>ReaderT</code> полезен тогда, когда группе функций нужен доступ к некоторому общему значению.</li>
<li>Функция <code>runReaderT</code> инициализирует “облако” с общим значением и запускает работу с ним.</li>
<li>Каждая из функций, используя <code>ask</code>, “магически” извлекает общее значение из “облака”.</li>
<li>Монада <code>Reader</code> - это простейший вариант трансформера <code>ReaderT</code>.</li>
</ul>

<div class="row">
    <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6">
        <div class="clear-button text-left">
            <div class="chapters-selector">
                <a href="../../ru/delicious/transformers-first-meeting.html" title="Предыдущая глава"><span class="fa fa-hand-o-left"></span></a>
            </div>
        </div>
    </div>
    
    <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6">
        <div class="clear-button text-right">
            <div class="chapters-selector">
                <a href="../../ru/delicious/transformers-writer.html" title="Следующая глава"><span class="fa fa-hand-o-right"></span></a>
            </div>
        </div>
    </div>
</div>
<div style="padding-top: 40px;"><div>

<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'ohaskell'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
 

        </div> 

        <footer class="footer">
            Книга создана с помощью <strong><a href="http://jaspervdj.be/hakyll/" target="_blank">Hakyll</a></strong> и живёт на <strong><a href="https://github.com/denisshevchenko/ohaskell" target="_blank">GitHub</a></strong>.
            <div class="copyright-note">
                Исходный код сайта и содержимое книги распространяются на условиях <a href="https://github.com/denisshevchenko/ohaskell/blob/master/LICENSE" target="_blank">свободной лицензии MIT</a>.
            </div>
        </footer>
    </div>
  </body>
</html>




























<!--<?xml version="1.0" encoding="UTF-8"?>-->
<!--<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"-->
<!--"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">-->
<!--<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">-->
<!--    <head>-->
<!--        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />-->
<!--        <title>Трансформеры: читатель | О Haskell по-человечески</title>-->
<!--        -->
<!--        <link rel="stylesheet" type="text/css" href="/css/default.css" />-->
<!--        <link rel="icon" type="image/x-icon" href="/images/favicon.ico" />-->
<!--    </head>-->
<!--    <body>-->
<!--        <div id="wrapper">-->

<!--            <div class="ribbon">-->
<!--                <a href="https://github.com/denisshevchenko/ohaskell">Живу на GitHub</a>-->
<!--            </div>-->

<!--            <div id="wrapper_2">-->
<!--            <div id="header">-->
<!--                <div id="logo">-->
<!--                    <a href="/ru/index.html" title="Домой">О Haskell по-человечески</a><span class="logo-note">для обыкновенных программистов</span>-->
<!--                </div>-->
<!--                <div id="navigation">-->
<!--                    <a href="/ru/chapters.html">ОГЛАВЛЕНИЕ</a>-->
<!--                </div>-->
<!--            </div>-->

<!--            -->

<!--            <div id="content">-->
<!--                <h1>Трансформеры: читатель</h1>-->

<!--                <div class="row">
    <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6">
        <div class="clear-button text-left">
            <div class="chapters-selector">
                <a href="/ru/delicious/transformers-first-meeting.html" title="Предыдущая глава"><span class="fa fa-hand-o-left"></span></a>
            </div>
        </div>
    </div>
    
    <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6">
        <div class="clear-button text-right">
            <div class="chapters-selector">
                <a href="/ru/delicious/transformers-writer.html" title="Следующая глава"><span class="fa fa-hand-o-right"></span></a>
            </div>
        </div>
    </div>
</div>
<div style="padding-top: 40px;"><div>

<p>В этой главе мы познакомимся с монадным трансформером <code>ReaderT</code>. Это весьма любопытный инструмент, часто используемый в реальных проектах. Суть этого трансформера очень проста и элегантна.</p>
<h2 id="суть">Суть</h2>
<p><code>ReaderT</code> - это читатель. Он предоставляет неким функциям общее значение, которое можно прочесть. Такого рода задача возникает достаточно часто. Например, есть некое значение <code>A</code>, полученное откуда-то извне (скажем, из конфигурационного файла), и есть набор функций, каждой из которых позарез нужно это значение <code>A</code>. Вот <code>ReaderT</code> и предоставляет всем этим функциям общий доступ к значению <code>A</code>. И чтобы стало понятнее, рассмотрим пример.</p>
<h2 id="разбираем-git-репозиторий">Разбираем git-репозиторий</h2>
<p>Пусть нам захотелось покопаться во внутренностях тайного каталога <code>.git</code>, незримо присутствующего в наших репозиториях. Для простоты ограничимся выводом всех его внутренних каталогов. Вот как мы можем сделать это обычным способом, без <code>ReaderT</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">gitRoot <span class="fu">=</span> <span class="st">&quot;/.git/&quot;</span>

<span class="ot">getPathToBranches ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
getPathToBranches pathToRepo <span class="fu">=</span>
    <span class="st">&quot;Branches: &quot;</span> <span class="fu">++</span> pathToRepo <span class="fu">++</span> gitRoot <span class="fu">++</span> <span class="st">&quot;branches&quot;</span>

<span class="ot">getPathToHooks ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
getPathToHooks pathToRepo <span class="fu">=</span>
    <span class="st">&quot;Hooks: &quot;</span> <span class="fu">++</span> pathToRepo <span class="fu">++</span> gitRoot <span class="fu">++</span> <span class="st">&quot;hooks&quot;</span>

<span class="ot">getPathToLogs ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
getPathToLogs pathToRepo <span class="fu">=</span>
    <span class="st">&quot;Logs: &quot;</span> <span class="fu">++</span> pathToRepo <span class="fu">++</span> gitRoot <span class="fu">++</span> <span class="st">&quot;logs&quot;</span>

<span class="ot">getPathToObjects ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
getPathToObjects pathToRepo <span class="fu">=</span>
    <span class="st">&quot;Objects: &quot;</span> <span class="fu">++</span> pathToRepo <span class="fu">++</span> gitRoot <span class="fu">++</span> <span class="st">&quot;objects&quot;</span>

<span class="ot">getPathToRefs ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
getPathToRefs pathToRepo <span class="fu">=</span>
    <span class="st">&quot;Refs: &quot;</span> <span class="fu">++</span> pathToRepo <span class="fu">++</span> gitRoot <span class="fu">++</span> <span class="st">&quot;refs&quot;</span>

<span class="ot">getPathToInfo ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
getPathToInfo pathToRepo <span class="fu">=</span>
    <span class="st">&quot;Info: &quot;</span> <span class="fu">++</span> pathToRepo <span class="fu">++</span> gitRoot <span class="fu">++</span> <span class="st">&quot;info&quot;</span>

<span class="ot">showRepoInternalDirectories ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
showRepoInternalDirectories pathToRepo <span class="fu">=</span>
    <span class="kw">let</span> pathToBranches <span class="fu">=</span> getPathToBranches pathToRepo
        pathToHooks <span class="fu">=</span> getPathToHooks pathToRepo
        pathToLogs <span class="fu">=</span> getPathToLogs pathToRepo
        pathToObjects <span class="fu">=</span> getPathToObjects pathToRepo
        pathToRefs <span class="fu">=</span> getPathToRefs pathToRepo
        pathToInfo <span class="fu">=</span> getPathToInfo pathToRepo
    <span class="kw">in</span>
    concat [pathToBranches
            ,<span class="st">&quot;\n&quot;</span>, pathToHooks 
            ,<span class="st">&quot;\n&quot;</span>, pathToLogs 
            ,<span class="st">&quot;\n&quot;</span>, pathToObjects 
            ,<span class="st">&quot;\n&quot;</span>, pathToRefs 
            ,<span class="st">&quot;\n&quot;</span>, pathToInfo]

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    pathToRepo <span class="ot">&lt;-</span> readFile <span class="st">&quot;/Users/dshevchenko/my.conf&quot;</span>
    <span class="kw">let</span> pathWithoutTrailingNL <span class="fu">=</span> takeWhile (<span class="fu">/=</span> <span class="ch">&#39;\n&#39;</span>) pathToRepo
        finalInfo <span class="fu">=</span> showRepoInternalDirectories pathWithoutTrailingNL
    putStrLn finalInfo</code></pre>
<p>Всё просто: забираем строку из файла <code>my.conf</code> и передаём её нескольким функциям, каждая из которых указывает путь к соответствующему внутреннему служебному каталогу. Для краткости все проверки файла <code>my.conf</code> опущены: такой файл существует, мы можем его прочитать и в нём действительно лежит путь к некоторому репозиторию. Вот результат работы такого кода:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">Branches</span>: /Users/dshevchenko/repo1/.git/branches
<span class="kw">Hooks</span>: /Users/dshevchenko/repo1/.git/hooks
<span class="kw">Logs</span>: /Users/dshevchenko/repo1/.git/logs
<span class="kw">Objects</span>: /Users/dshevchenko/repo1/.git/objects
<span class="kw">Refs</span>: /Users/dshevchenko/repo1/.git/refs
<span class="kw">Info</span>: /Users/dshevchenko/repo1/.git/info</code></pre>
<p>Кстати, мы использовали новую функцию <code>concat</code>. Эта стандартная функция принимает список строк и объединяет их в одну. Да, мы могли бы воспользоваться оператором <code>++</code>, но с функцией <code>concat</code> красивше получилось.</p>
<h2 id="ложечка-дёгтя">Ложечка дёгтя</h2>
<p>И всё бы хорошо с этим примером, но кое-что цепляет глаз. Получив путь к репозиторию, мы вынуждены явно передавать его в качестве аргумента всем нашим функциям: сначала функции <code>showRepoInternalDirectories</code>, а затем всем вспомогательным функциям. Это выглядит громоздко. Тут-то и выходит на сцену наш читатель. Но прежде чем мы рассмотрим решение на его основе, немного теории.</p>
<h2 id="совсем-немного-теории">Совсем немного теории</h2>
<p>Вот что представляет собою тип <code>ReaderT</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">ReaderT</span> r m a </code></pre>
<p>Перед нами конструктор типа, параметризованный тремя значениями: * <code>r</code> - общее значение, * <code>m</code> - некая монада, * <code>a</code> - значение внутри этой монады.</p>
<p>Общее значение - это наш главный герой, ради которого всё и затевалось. Иногда его ещё называют “shared environment value”. Вы уже догадались, как это относится к нашему примеру, не так ли? Ведь у нас имеется такое общее значение, а именно полученный из конфигурационного файла путь к репозиторию! Раз этот путь нужен всем нашим функциям, мы помещаем его в общую среду (“shared environment”), к которой можно будет получить доступ. В этом и есть суть <code>ReaderT</code>: он, грубо говоря, предоставляет глобальную переменную, видимую всем нашим функциям.</p>
<p>Перейдём к <del>магии</del> практике.</p>
<h2 id="магия-практика"><del>Магия</del> Практика</h2>
<p>Определим конкретный тип для нашего случая:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.Reader</span>

<span class="kw">type</span> <span class="dt">Environment</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">PathReader</span> <span class="fu">=</span> <span class="dt">ReaderT</span> <span class="dt">Environment</span> <span class="dt">IO</span> <span class="dt">String</span></code></pre>
<p>Значение типа <code>Environment</code> - это и есть наше общее значение, в котором будет храниться путь к репозиторию. А вот теперь начинается немного магии. Перепишем первую вспомогательную функцию, выводящую путь к каталогу <code>branches</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">getPathToBranches ::</span> <span class="dt">PathReader</span>
getPathToBranches <span class="fu">=</span> <span class="kw">do</span>
    pathToRepo <span class="ot">&lt;-</span> ask
    return <span class="fu">$</span> <span class="st">&quot;Branches: &quot;</span> <span class="fu">++</span> pathToRepo <span class="fu">++</span> gitRoot <span class="fu">++</span> <span class="st">&quot;branches&quot;</span></code></pre>
<p>Необычно выглядит, не правда ли? Аргумент <code>pathToRepo</code> пропал, а возвращается уже не строка, а наш читатель. Интересной здесь является вот эта строка:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    pathToRepo <span class="ot">&lt;-</span> ask</code></pre>
<p>Функция <code>ask</code> имеет непосредственное отношение к <code>ReaderT</code>. Она запрашивает (англ. “ask”) ту самую строку из общей среды читателя. Значение, возвращаемое функцией <code>ask</code>, имеет монадический тип <code>ReaderT Environment</code>, поэтому идентификатор <code>pathToRepo</code> ассоциирован уже с <code>Environment</code>, то есть с этой самой строкой. И чтобы работа функции <code>ask</code> стала ещё яснее, вспомним получение пользовательской строки:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">getStringFromUser ::</span> <span class="dt">IO</span> <span class="dt">String</span>
getStringFromUser <span class="fu">=</span> <span class="kw">do</span>
    stringFromUser <span class="ot">&lt;-</span> getLine
    <span class="fu">...</span></code></pre>
<p>Подобно тому, как функция <code>getLine</code> идёт во внешний мир, ассоциированный с монадой <code>IO</code>, чтобы принести оттуда введённую пользователем строку, функция <code>ask</code> идёт в общую среду, ассоциированную с монадой <code>ReaderT</code>, чтобы принести оттуда то самое общее значение.</p>
<p>В этом и заключается маленькое волшебство <code>ReaderT</code>: общее значение уже не нужно явно передавать в виде аргумента, поскольку оно как бы незримо парит в воздухе, и теперь все наши функции могут запрашивать его с помощью функции <code>ask</code>. И поэтому теперь функция <code>showRepoInternalDirectories</code> выглядит так:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">showRepoInternalDirectories ::</span> <span class="dt">PathReader</span> 
showRepoInternalDirectories <span class="fu">=</span> <span class="kw">do</span>
    pathToBranches <span class="ot">&lt;-</span> getPathToBranches
    pathToHooks <span class="ot">&lt;-</span> getPathToHooks
    pathToLogs <span class="ot">&lt;-</span> getPathToLogs
    pathToObjects <span class="ot">&lt;-</span> getPathToObjects
    pathToRefs <span class="ot">&lt;-</span> getPathToRefs
    pathToInfo <span class="ot">&lt;-</span> getPathToInfo
    return <span class="fu">$</span> concat [pathToBranches
                     ,<span class="st">&quot;\n&quot;</span>, pathToHooks 
                     ,<span class="st">&quot;\n&quot;</span>, pathToLogs 
                     ,<span class="st">&quot;\n&quot;</span>, pathToObjects 
                     ,<span class="st">&quot;\n&quot;</span>, pathToRefs 
                     ,<span class="st">&quot;\n&quot;</span>, pathToInfo]</code></pre>
<p>Аргументов больше нет, есть лишь общая среда.</p>
<p>Но как же наша строка, извлечённая из конфигурационного файла, окажется в той самой общей среде читателя? Пришло время взглянуть на обновлённую <code>main</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    pathToRepo <span class="ot">&lt;-</span> readFile <span class="st">&quot;/Users/dshevchenko/my.conf&quot;</span>
    <span class="kw">let</span> pathWithoutTrailingNL <span class="fu">=</span> takeWhile (<span class="fu">/=</span> <span class="ch">&#39;\n&#39;</span>) pathToRepo
    finalInfo <span class="ot">&lt;-</span> runReaderT showRepoDirectories 
                            pathWithoutTrailingNL
    putStrLn finalInfo</code></pre>
<p>Функция <code>runReaderT</code> - это волшебная палочка, запускающая (англ. “run”) вышеупомянутую магию. Принимая в качестве первого аргумента функцию <code>showRepoDirectories</code>, а качестве второго - тот самый путь из конфигурационного файла, функция <code>runReaderT</code> создаёт общую среду, с которой и работают все наши функции. Грубо говоря, <code>runReaderT</code> создаёт облако и помещает в него значение <code>pathWithoutTrailingNL</code>. Вот такие “облачные технологии” внутри Haskell… :-)</p>
<h2 id="разоблачение-монады-reader">Разоблачение монады Reader</h2>
<p>Если вы прочли <a href="http://ohaskell.dshevchenko.biz/ru/delicious/transformers-first-meeting.html">главу о первой встрече с трансформерами</a>, у вас, очевидно, возник вопрос о монаде <code>Reader</code>. Ведь, как мы помним, монадный трансформер - это монадическая матрёшка два-в-одном: берём одну монаду и добавляем к ней функциональность другой монады. Мы видели это на примере <code>MaybeT</code>: есть монада <code>Maybe</code>, а есть трансформер <code>MaybeT</code>, привносящий <code>Maybe</code>-опциональность в некую другую монаду.</p>
<p>Следовательно, раз есть монадный трансформер <code>ReaderT</code>, должна быть и монада <code>Reader</code>, не так ли? Но если так, почему же мы сразу взялись за рассмотрение трансформера?</p>
<p>Пришло время узнать правду. А правда в том, что монада <code>Reader</code>… это и есть трансформер <code>ReaderT</code>. Взглянем на определение в модуле <code>Control.Monad.Reader</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Reader</span> r <span class="fu">=</span> <span class="dt">ReaderT</span> r <span class="dt">Identity</span></code></pre>
<p>Вот и вся правда: тип <code>Reader</code> есть не более чем псевдоним для <code>ReaderT</code>. Таким образом, если монада <code>Maybe</code> является самостоятельным типом и ничего не знает о трансформере <code>MaybeT</code>, монада <code>Reader</code>, напротив, является <em>частным случаем</em> трансформера <code>ReaderT</code>.</p>
<h2 id="зачем-нужна-reader">Зачем нужна Reader</h2>
<p>Для простоты. Вы обратили внимание, что тип <code>Reader</code> в качестве монады использует тип <code>Identity</code>? Это и делает тип <code>Reader</code> простейшим вариантом трансформера <code>ReaderT</code>, поскольку монада <code>Identity</code> - это самая простая стандартная монада из всех существующих, даже проще чем <code>Maybe</code>. <code>Identity</code> живёт в пакете <code>transformers</code> и представляет собою монаду-пустышку. Она настолько примитивна, что сама по себе не имеет никакой ценности. Взгляните:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Identity</span> a <span class="fu">=</span> <span class="dt">Identity</span> a
    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Read</span>, <span class="dt">Show</span>)

<span class="ot">runIdentity ::</span> <span class="dt">Identity</span> a <span class="ot">-&gt;</span> a
runIdentity (<span class="dt">Identity</span> x) <span class="fu">=</span> x

<span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Identity</span> <span class="kw">where</span>
    return a <span class="fu">=</span> <span class="dt">Identity</span> a
    m <span class="fu">&gt;&gt;=</span> k  <span class="fu">=</span> k (runIdentity m)</code></pre>
<p>Грубо говоря, это как <code>Maybe</code> с одним лишь конструктором <code>Just</code>. Единственное назначение этой монады - быть монадой-пустышкой. Поэтому, когда мы пишем так:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">PathReader</span> <span class="fu">=</span> <span class="dt">ReaderT</span> <span class="dt">Environment</span> <span class="dt">Identity</span> <span class="dt">String</span></code></pre>
<p>или так:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">PathReader</span> <span class="fu">=</span> <span class="dt">Reader</span> <span class="dt">Environment</span> <span class="dt">String</span></code></pre>
<p>то говорим: “Да, тип <code>PathReader</code> по-прежнему содержит в себе значение типа <code>String</code>, завёрнутое в монадическую обёртку, но обёртка эта столь примитивна, что её как будто и нет вовсе.” Поэтому при использовании <code>Reader</code> мы можем вообще не думать о внутренней монаде.</p>
<p>Это позволит нам упростить наш пример и написать так:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Environment</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">PathReader</span> <span class="fu">=</span> <span class="dt">Reader</span> <span class="dt">Environment</span> <span class="dt">String</span>

<span class="co">-- Все остальные функции остаются без изменений...</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    pathToRepo <span class="ot">&lt;-</span> readFile <span class="st">&quot;/Users/dshevchenko/my.conf&quot;</span>
    <span class="kw">let</span> pathWithoutTrailingNL <span class="fu">=</span> takeWhile (<span class="fu">/=</span> <span class="ch">&#39;\n&#39;</span>) pathToRepo
        <span class="co">-- runReader сразу вернёт String, а не IO String... </span>
        finalInfo <span class="fu">=</span> runReader showRepoInternalDirectories 
                              pathWithoutTrailingNL
    putStrLn finalInfo</code></pre>
<p>В самом деле, зачем нам внутренняя монада <code>IO</code> в нашем <code>PathReader</code>? В данном случае мы легко можем обойтись и без неё. Так и определение типа <code>PathReader</code> упрощается, и в функции <code>main</code> мы имеем дело сразу с результирующей строкой, без <code>IO</code>-обёртки. Обратите внимание, мы используем уже не <code>runReaderT</code>, а <code>runReader</code>.</p>
<h2 id="реальный-пример">Реальный пример</h2>
<p>Этот небольшой пример основан на использовании прекрасного пакета <code>direct-fastcgi</code>, предназначенного для создания FastCGI-скриптов. В центре нашего внимания - обработчик запросов, приходящих к нашему приложению от веб-сервера. Итак:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">handleRequest ::</span> <span class="dt">FastCGI</span> ()
handleRequest <span class="fu">=</span> <span class="kw">do</span>
    fPutStr <span class="st">&quot;Hello from Haskell world!&quot;</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> acceptLoop forkIO handleRequest</code></pre>
<p>Функция <code>handleRequest</code> обрабатывает поступивший запрос. А вот определение типа <code>FastCGI</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">FastCGI</span> <span class="fu">=</span> <span class="dt">ReaderT</span> <span class="dt">FastCGIState</span> <span class="dt">IO</span></code></pre>
<p>Вот он, наш старый друг! Использование <code>ReaderT</code> в данном случае очень удобно: мы получили из внешнего мира запрос и поместили его в наше общее “облако”. Функции <code>handleRequest</code> обязательно понадобится доступ к параметрам запроса, чтобы адекватно на него ответить. И именно благодаря <code>ReaderT</code> работа с этими параметрами очень удобна. Например:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">handleRequest ::</span> <span class="dt">FastCGI</span> ()
handleRequest <span class="fu">=</span> <span class="kw">do</span>
    queryString <span class="ot">&lt;-</span> getQueryString
    setResponseStatus <span class="dv">404</span>
    setResponseHeader <span class="dt">HttpContentType</span> <span class="st">&quot;text/plain&quot;</span>
    fPutStr <span class="fu">$</span> <span class="st">&quot;Test: &quot;</span> <span class="fu">++</span> queryString</code></pre>
<p>Все четыре использованные в обработчике функции работают со значением типа <code>FastCGIState</code>, но это значение не передаётся им в качестве аргумента. Однако вы уже знаете, в чём здесь секрет: каждая из этих функций извлекает значение типа <code>FastCGIState</code> из “общего облака” монады <code>ReaderT</code>. В итоге получаем красивый и компактный код.</p>
<h2 id="в-сухом-остатке">В сухом остатке</h2>
<ul>
<li>Трансформер <code>ReaderT</code> полезен тогда, когда группе функций нужен доступ к некоторому общему значению.</li>
<li>Функция <code>runReaderT</code> инициализирует “облако” с общим значением и запускает работу с ним.</li>
<li>Каждая из функций, используя <code>ask</code>, “магически” извлекает общее значение из “облака”.</li>
<li>Монада <code>Reader</code> - это простейший вариант трансформера <code>ReaderT</code>.</li>
</ul>

<div class="row">
    <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6">
        <div class="clear-button text-left">
            <div class="chapters-selector">
                <a href="/ru/delicious/transformers-first-meeting.html" title="Предыдущая глава"><span class="fa fa-hand-o-left"></span></a>
            </div>
        </div>
    </div>
    
    <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6">
        <div class="clear-button text-right">
            <div class="chapters-selector">
                <a href="/ru/delicious/transformers-writer.html" title="Следующая глава"><span class="fa fa-hand-o-right"></span></a>
            </div>
        </div>
    </div>
</div>
<div style="padding-top: 40px;"><div>

<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'ohaskell'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
 
-->
<!--            </div>-->
<!--            -->
<!--            <div id="footer">-->
<!--                <div id="social">-->
<!--                    &copy; Денис Шевченко 2013-2014-->
<!--                </div>-->
<!--                <div id="hakyll_mark">-->
<!--                    Книга создана с помощью <a href="http://jaspervdj.be/hakyll">Hakyll</a>-->
<!--                </div>-->
<!--            </div>-->

<!--            <div id="search_form">-->
<!--                <script>-->
<!--                  (function() {-->
<!--                    var cx = '007697214108744450483:au850gpbupm';-->
<!--                    var gcse = document.createElement('script');-->
<!--                    gcse.type = 'text/javascript';-->
<!--                    gcse.async = true;-->
<!--                    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +-->
<!--                        '//www.google.com/cse/cse.js?cx=' + cx;-->
<!--                    var s = document.getElementsByTagName('script')[0];-->
<!--                    s.parentNode.insertBefore(gcse, s);-->
<!--                  })();-->
<!--                </script>-->
<!--                <gcse:search></gcse:search>-->
<!--            </div>-->
<!--            </div>-->
<!--        </div>-->
<!--    </body>-->
<!--</html>-->
