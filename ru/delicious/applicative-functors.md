Аппликативные функторы
----------------------

Поговорим об аппликативных функторах (applicative functors). Знаю, название немного пугает, но поверьте, ничего страшного в них нет. Более того, аппликативный функтор, как вы вскоре убедитесь, очень полезный инструмент.

Суть проста. Если тип `X` является обыкновенным функтором, мы можем применить некую функцию к одному значению типа `X`. Если же тип `X` является аппликативным функтором, мы можем применить некую функцию к _нескольким_ значениям типа `X`. Начнём.

### Смотрим в код

Аппликативные функторы (далее - АФ) отражены классом `Applicative`, проживающим в стандартном модуле `Control.Applicative`. Взглянем:
 
```haskell
class Functor f => Applicative f where
    pure  :: a -> f a
    (<*>) :: f (a -> b) -> f a -> f b  -- Наш главный герой.
    (*>)  :: f a -> f b -> f b
    (<*)  :: f a -> f b -> f a
```

Перед нами класс типов, каждый из которых обязан входить в контекст класса `Functor`. Среди четырёх методов центральное место занимает оператор последовательного применения (sequential application). Взглянем на него ещё раз:

```haskell
(<*>) :: f (a -> b) -> f a -> f b
```

Пока не очень понятно, с чем это едят, но давайте поставим рядом с ним объявление нашей волшебницы `fmap`:

```haskell
(<*>) :: f (a -> b) -> f a -> f b
fmap  ::   (a -> b) -> f a -> f b
```

Сразу повеяло обычным функтором, не так ли? Почти полное сходство, за исключением одной важной детали. Если `fmap` работает с функцией и функтором, то оператор `<*>` работает с двумя функторами. Причём наибольший интерес вызывает первый по счёту функтор, потому что он содержит в себе не значение, а функцию. Именна эта функция играет роль уже известной нам волшебной палочки: оператор `<*>` извлекает её из первого функтора и применяет ко второму (правому) функтору.

Вы спросите, зачем такие трудности? Рассмотрим пример.

### Играемся с функтором

Определим тип `Distance`, очень похожий на `Year` из предыдущей главы:

```haskell
newtype Distance value = Distance value
                         deriving Show
```

Значение типа `Distance` можно инициализировать значениями разного типа, и это хорошо. Но в реальном проекте мы едва ли ограничимся выводом значений типа `Distance` на экран. Мы обязательно захотим делать с этими значениями какие-нибудь интересные вещи.

Например, сложение. Определим соответствующую функцию:

```haskell
add (Distance a) (Distance b) = Distance (a + b)
```

Теперь мы можем складывать наши дистанции: 

```haskell
main :: IO ()
main = print $ Distance 19.78 `add` Distance 1.6
```

Результат:

```bash
Distance 21.380000000000003
```

Симпатично. Однако для дистанций одного сложения, вероятно, будет маловато. Определим функцию для вычитания:

```haskell
minus (Distance a) (Distance b) = Distance (a - b)
```

Теперь можно вычитать:

```haskell
main :: IO ()
main = print $ Distance 19.78 `minus` Distance 1.6
```

Хм... Всё это, конечно, хорошо, но ведь можно ещё и умножать, и делить. Нам что, для каждой такой операции определять свою функцию? Нет, умный в гору не пойдёт. Мы ведь хотим упрощения нашей программистской жизни, а не усложнения. Тут-то и спешит нам на помощь АФ.

### Превращаем

Превратим тип `Distance` в АФ. Впрочем, я поторопился: сначала нам нужно сделать его обыкновенным функтором, а уже потом аппликативным. Пишем:

```haskell
instance Functor Distance where
    fmap magicWand (Distance value) = Distance (magicWand value)

instance Applicative Distance where
    Distance magicWand <*> functor = fmap magicWand functor
```

Для нашей первой демонстрации нам понадобится лишь один из четырёх методов класса Applicative, поэтому остальные мы определять не будем.

Также обращаю ваше внимание на несколько необычную форму определения этого оператора:

```haskell
Distance magicWand <*> functor = fmap magicWand functor
```

Более привычной для нас формой является такая:

```haskell
(<*>) (Distance magicWand) functor = fmap magicWand functor
```

Ведь мы всегда так писали: сначала идёт имя функции, а потом её аргументы. Однако если мы определяем оператор, который заточен под инфиксную форму, то и определять его можно в такой же, инфиксной форме:

    Distance magicWand <*> functor = ...
    |                      |
    первый аргумент        второй аргумент

Ну а теперь пора разобраться, зачем же мы сделали всё это?

Данный механизм освобождает нас от обязанности самостоятельно определять бинарные функции для работы со значениями типа  `Distance`. Поэтому теперь, когда нам понадобится получить сумму двух дистанций, мы напишем вот так:

```haskell
main :: IO ()
main = print $ (+) <$> Distance 19.78 <*> Distance 1.6
```

Результат:

```bash
Distance 21.380000000000003
```

Если же нужно вычесть, пишем так:

```haskell
main :: IO ()
main = print $ (-) <$> Distance 19.78 <*> Distance 1.6
```

Вполне ожидаемый результат:
 
```bash
Distance 18.18
```

### Как это работает

Скелет этой конструкции можно изобразить следующим образом:

    (+)       <$>      APPL_FTOR     <*>                APPL_FTOR
    |         |        |             |                  |
    функция   аналог   первый аппл.  оператор           второй аппл.
    сложения  fmap     функтор       последовательного  функтор
                                     применения

Сделав тип `Distance` аппликативным функтором, мы тем самым научили простые функции работать с двумя значениями типа `Distance` одновременно. Например, функцию сложения, возглавляющую эту строку. Эта функция и тип `Distance` не знакомы друг с другом, однако прекрасно работают вместе. Проследуем по шагам.

    (+) <$> APPL_FTOR 

На первом шаге оператор `<$>`, являющийся, как вы помните, инфиксной копией функции `fmap`, применил стоящую слева от него функцию сложения к функтору, стоящему справа. Чтобы понять произошедшее на этом шаге, вспомним объявление функции `fmap` для нашего типа:

```haskell
fmap magicWand (Distance value) = Distance (magicWand value)
```

Заменим волшебную палочку на функцию сложения и `value` на реальное значение:

```haskell
fmap (+) (Distance 19.78) = Distance ((+) 19.78)
```

Ба, знакомые все лица! Функция `fmap` возвращает значение типа `Distance`, но оно содержит в себе уже не число, а нашу старую подругу, частично применённую функцию. Эта функция появилась на свет благодаря применению функции сложения к единственному аргументу `19.78`.

Что же произошло на втором шаге? Взглянем:

    APPL_FTOR <*> APPL_FTOR

Здесь вступает в игру оператор последовательного применения. Вспомним его определение для нашего типа:

```haskell
Distance magicWand <*> functor = fmap magicWand functor
``` 

Подставим реальные значения для ясности:

```haskell
Distance ((+) 19.78) <*> Distance 1.6 = fmap ((+) 19.78)  Distance 1.6
```

Теперь все карты раскрыты. В результате работы оператора `<*>` внутренняя функция `fmap` применила нашу частично применённую функцию сложения к значению, содержащемуся во втором функторе. И на выходе мы получили результат сложения в виде `Distance 21.380000000000003`.

### Не только два

Раз мы смогли применить бинарную функцию к двум АФ одновременно, значит, можно и расшириться. Количество аргументов функции, поступающей на вход функторной очереди, должна соответствовать количеству функторов в этой очереди. Поэтому если нам нужно узнать общую длину трёх дистанций, мы пишем так:

```haskell
main :: IO ()
main =
    print $ totalSum <$> Distance 19.78 <*> Distance 1.6 <*> Distance 289.0
    where totalSum arg1 arg2 arg3 = arg1 + arg2 + arg3
```

Три аргумента - три функтора. Функция `totalSum` бежит по ним и потихоньку собирает их внутренние значения в общую сумму, на выходе выдавая нам:

```bash
Distance 310.38
```

### pure

Перейдём к следующему методу класса `Applicative`, а именно `pure`. Вспомним его объявление:

```haskell
pure :: a -> f a
```

Назначение этого метода предельно простое: он берёт значение (которое на самом деле является функцией) и оборачивает его в АФ-обёртку. Определим его для нашей дистанции:

```haskell
instance Applicative Distance where
    Distance magicWand <*> functor = fmap magicWand functor
    pure magicWand = Distance magicWand
```

Мы указали, что метод `pure` теперь равен нашему конструктору типа `Distance`. Мы могли бы использовать и сокращённую форму:

```haskell
pure = Distance
```

Это позволит нам переписать наш пример так:

```haskell
main :: IO ()
main =
    print $ pure totalSum <*> Distance 19.78
                          <*> Distance 1.6
                          <*> Distance 289.0
    where totalSum arg1 arg2 arg3 = arg1 + arg2 + arg3
```

Здесь уже нет оператора `<$>`, его обязанности на себя взяла функция `pure`, которая взяла функцию `totalSum` и, скажем так, подготовила её к работе с нашими аппликативными функторами. В англоязычной документации пишут, что функция `pure` подняла (lift) функцию `totalSum`. Это можно воспринимать как подъём на более высокий уровень абстрации: была просто функция, а стала... непросто функция.

### Последовательность действий

Оставшиеся два метода класса `Applicative` называют операторами последовательности действий. Вспомним их:

```haskell
(*>) :: f a -> f b -> f b
(<*) :: f a -> f b -> f a
```

Это - младшие братья оператора последовательного применения. Первый из них выбрасывает значение своего первого аргумента. Второй - выбрасывает значение второго:

    (*>) ::   f a  ->  f b -> f b
              ---      ===    ===
           игнорирую
            первый

    (<*) :: f a ->   f b   -> f a
            ===      ---      ===
                  игнорирую
                    второй

Чтобы стало понятнее, определим первый из этих операторов для нашего типа:

```haskell 
instance Applicative Distance where
    Distance magicWand <*> functor = fmap magicWand functor
    pure magicWand = Distance magicWand
    Distance a *> Distance b = Distance b  -- Просто возвращаем второй. 
```

Предельно просто: оператор `*>` разрывает цепочку передачи значения между функторами. Например, если мы напишем так:

```haskell
main :: IO ()
main =  
    print $ pure totalSum <*> Distance 19.78
                          <*> Distance 1.6
                          <*> Distance 289.0
                          *>  Distance 2.0  -- Цепочка уже разорвалась!
    where totalSum arg1 arg2 arg3 = arg1 + arg2 + arg3
```

ответом будет:

```bash
Distance 2.0
```

Так получилось потому, что значение типа `Distance`, возвращённое третьим по счёту оператором `<*>`, поступило на вход оператору `*>` и было благополучно забыто. Ведь мы помним, что оператор `*>` всего лишь возвращает свой второй операнд, в нашем случае функтор `Distance 2.0`.

Вы спросите, в чём же смысл такого оператора, если он ничего не извлекает из своего левого операнда? Смысл есть тогда, когда извлекать нечего. И чтобы продемонстрировать это, открою вам тайну: тип `IO` - это не только монада, но и аппликативный функтор. А если быть совсем честным, все стандартные монады являются АФ.

### Играемся с монадами

Вспомним пример с получением двух строк от пользователя:

```haskell
obtainTwoTextsFromUser :: IO String
obtainTwoTextsFromUser = do
    putStrLn "Enter your text, please: "
    firstText <- getLine
    putStrLn "One more, please: "
    secondText <- getLine
    return $ firstText ++ secondText 

main :: IO ()
main = do
    twoTexts <- obtainTwoTextsFromUser
    putStrLn $ "You said " ++ twoTexts
```

Обратите внимание: в теле функции `obtainTwoTextsFromUser` мы явно "извлекаем" ассоциированные с `IO`-монадами строки, `firstText` и `secondText`. Перепишем эту функцию, помня о том, что `IO` - это АФ:

```haskell
obtainTwoTextsFromUser :: IO String
obtainTwoTextsFromUser =
    (++) <$> getFirstText <*> getSecondText  -- Складываем строки.  
    where getFirstText = putStrLn "Enter your text, please: " *> getLine
          getSecondText = putStrLn "One more, please: " *> getLine
```

Теперь разберёмся. Начнём с `getFirstText`:

```haskell
getFirstText = putStrLn "Enter your text, please: " *> getLine
```

Как мы помним, функция `putStrLn` возвращает значение типа `IO ()`, следовательно, после её завершения этот код станет таким:

```haskell
getFirstText = IO () *> getLine
```

Теперь вы понимаете, почему здесь используется оператор `*>`. Поскольку из значения типа `IO ()` ничего нельзя извлечь, оно игнорируется, и мы просто переходим к функции `getLine`. Она, получив от пользователя текст, возвращает значение типа `IO String`, и теперь этот код можно изобразить так:

```haskell
getFirstText = IO () *> IO String
```

Значение типа `IO String` связывается с идентификатором `getFirstText`. И то же самое происходит с `getSecondText`. Следовательно, после получения двух текстов от пользователя, код приобретёт вот такой вид:

```haskell
obtainTwoTextsFromUser :: IO String  
obtainTwoTextsFromUser =
    (++) <$> IO String <*> IO String
```

Ну а тут уже всё как обычно: функция `++` пробегается по двум АФ, забирает их строки, складывает их, и в итоге функция `obtainTwoTextsFromUser` возвращает значение `IO String`, уже содержащее в себе оба пользовательских текста.

Теперь мы узнали, что `<*>` может протаскивать функцию в том числе и через результаты работы функций с побочными эффектами.

### Родственники

Кстати, у вас не возникло чувство дежавю? Мы взяли функцию, обернули её в некую обёртку, прогнали через цепочку неких сущностей, попутно извлекая из них какие-то значения, а в итоге общий результат вернули в той же обёртке. Всё это мы уже видели в монадическом механизме! Взгляните хотя бы на метод `pure`: это же клон метода `return`.

АФ и монады действительно близкие родственники. Во-первых, и первые и вторые формализуют "цепочечный механизм", а во-вторых, как уже было сказано ранее, все стандартные монады являются АФ.

Однако следует помнить, что связь между монадами и АФ односторонняя: монады являются АФ, но не наоборот. Поэтому не рекомендуется использовать монады там, где достаточно возможностей функторов. Так что если вам нужно, например, произвести некое действие с элементами списка, вы _можете_ вспомнить о его монадической природе и написать так:

```haskell
main :: IO ()
main = print $ [1, 2, 3] >>= \number -> return $ number * 2
```

но лучше вспомнить о функторной природе списка и написать проще:

```haskell
import Control.Applicative 

main :: IO ()
main = print $ (*2) <$> [1, 2, 3]
```

Вот, собственно, и всё. Теперь вы знаете, что такое аппликативные функторы.
