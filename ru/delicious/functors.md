Функторы
--------

Поговорим о функторах, одной из важных концепций языка Haskell. На самом деле мы их уже использовали, осталось лишь разобраться в сути.

### Разбираемся

Функторами называют такие типы, значения которых могут быть маппированы (mapped over). Помните стандартную функцию `map`, позволяющую последовательно применить функцию к каждому элементу списка? Вот это тот самый случай.

Все функторы представлены стандартным классом `Functor`:

```haskell
class Functor f where
    fmap :: (a -> b) -> f a -> f b
```

Перед нами один-единственный метод `fmap`, который говорит: "Дайте мне функцию, принимающую значение `a` и возвращающую значение `b`, а ещё дайте значение `a` в функторной обёртке, а я верну вам значение `b` в такой же функторной обёртке". Многие стандартные типы являются функторами.

### Зачем это нам

Функция `fmap` - это волшебница. Она говорит: "Дайте мне ~~волшебную палочку~~ функцию и _нечто_, а я прикоснусь функцией к этому _нечто_ и изменю его". Это нечто и есть функтор.

Разумеется, говоря об изменении, я выражаюсь концептуально. Если мы видим строку:

```haskell
fmap toLower ['A'..'Z']
```

мы можем выразиться технически точно: "Функция `fmap` последовательно применит функцию `toLower` к каждому элементу списка, в результате чего будет сконструирован новый список со значениями, являющимися результатом применения функции `toLower` к элементам изначального списка".

Но так слишком длинно. Поэтому мы можем выразиться концептуально: "Функция `fmap` прикоснулась функцией `toLower` к списку и изменила его". В этом и заключается фундаментальный смысл функторов: посредством функции `fmap` мы прикасаемся к ним некой другой функцией и изменяем их.

Более того, такое изменение может касаться не только содержимого функтора, но и его типа. Например, если взять функтор типа `[Char]` и прикоснуться к нему такой функцией:

```haskell
fmap toLower ['A'..'Z']
```

на выходе у нас тоже получится функтор того же типа `[Char]`. Однако если прикоснуться такой функцией:

```haskell
fmap digitToInt ['1'..'9']
```

на выходе у нас получится функтор типа `[Int]`.

### Создаём свой

Путь это будет год:

```haskell
data Year value = Year value
                  deriving Show
```

Тип `Year` содержит в себе год. Параметризация в данном случае весьма полезна: значение года может быть задано как числом, так и строкой. И поскольку значение года может (с концептуальной точки зрения) меняться, сделаем тип `Year` функторным:

```haskell
instance Functor Year where
    fmap magicWand (Year value) = Year (magicWand value)
```

Функция `magicWand` будет прикасаться не к году, а к его реальному содержимому. Например так:

```haskell
increase :: Int -> Int
increase year = year + 1

main :: IO ()
main =
    print $ fmap increase year
    where year = Year 1981
```

Мы определили функцию `increase`, увеличивающую значение года на один. Казалось бы, зачем делать тип `Year` функторным? Ведь мы могли бы определить функцию, работающую с этим типом напрямую. Однако в этом случае мы жёстко привяжемся к типу `Year`. А фундаментальное преимущество функтора как раз в том и заключается, что функция, изменяющая его содержимое, ничего не знает о самом функторе.

Следовательно, в качестве волшебной палочки, прикасающейся к нашему году, могут выступать совершенно посторонние функции. Это и открывает перед нами огромный творческий простор.

### Инфиксная форма

В стандартном модуле `Data.Functor` определён оператор необычного вида `<$>`, являющийся инфиксным аналогом функции `fmap`. Чуток перепишем наш пример с годом:

```haskell
import Data.Functor

... 

main :: IO ()
main =
    print $ increase <$> year
    where year = Year 1981
```

Результат тот же самый, но инфиксная форма способна сделать код более читабельным.

Вот, теперь вы знаете о функторах. Рассматривайте их тоже как своего рода проектный паттерн, унифицирующий применение разных функций к разным значениям.
