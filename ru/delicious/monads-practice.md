Монады: практика
----------------

Зачем же ради соединения вычислений в последовательную цепочку обматывать эти вычисления в какие-то монадические обёртки?

Главная цель такого подхода: гибкость и упрощение кода. Приступим.

### Разоблачение списков

Списки в Haskell - это тоже монады. Рассмотрим, какую пользу нам может принести этот факт.

Начнём со строки. Она ведь есть ни что иное, как `[Char]`, а это значит, она тоже является монадой. Помните наш пример про исправление URL? Напишем нечто похожее:

```haskell
import Data.Char 

toLowerCase = return . toLower

underlineSpaces char = return (if char == ' ' then '_' else char)

main :: IO ()
main =
    print $ name >>= toLowerCase >>= underlineSpaces
    where name = "Lorem ipsuM"
```

На выходе будет:

```bash
lorem_ipsum
```

Проанализируем. Наше внимание приковывает вот эта строка:

```haskell
name >>= toLowerCase >>= underlineSpaces
```

В глаза бросаются операторы компоновки, а это значит, перед нами монадический конвейер. Слева в него въезжает наша строка name, то есть монада `[Char]`, и едет по нему. А за конвейером её ждут два работника, `toLowerCase` и `underlineSpaces`, каждый из которых вносит в `name` свои изменения.

Вы спросите, в чём же тут соль? Чем это отличается от функций композиции и применения, рассмотренных нами в главе о функциональных цепочках? Ведь там мы тоже конструировали конвейер из трёх функций:

```haskell
addPrefix . encodeAllSpaces . makeItLowerCase $ url
```

Однако отличия имеются, и главное из них в том, что эти три функции работают со строкой, а функции `toLowerCase` и `underlineSpaces` работают с _элементом_ строки. Взгляните:

```haskell
toLowerCase = return . toLower
```

Эта функция ожидает на вход символ, а не строку, ведь стандартная функция `toLower` применяется к значению типа `Char`. И это очень важное свойство функций, компонуемых в монадическую цепочку: они работают со значением, содержащимся в монаде, а не с самой монадой. Поскольку в данном случае монадой является `[Char]`, функция `toLowerCase` работает только с `Char`, извлекаемым из списка оператором компоновки. Понятно, что оператор компоновки, определённый для списка, подразумевает "прогон" монадной функции через _все_ элементы этого списка.

Монадическая цепочка предоставляет нам большую гибкость, ведь функции `toLowerCase` и `underlineSpaces` вообще не знают о том, что работают в конечном итоге со строкой. А значит, эти функции можно соединять для работы с самыми разными монадами, содержащими в себе значения типа `Char`.

Кстати, важное уточнение: функции такого рода могут работать только с монадами, о чём красноречиво говорит функция `return`. Взглянем на определение ещё раз:

```haskell
toLowerCase = return . toLower
```

Функция говорит нам: "Да, я работаю с аргументом типа `Char`, но в конце своей работы я, с помощью функции `return`, возвращаю итоговое значение типа `Char` обратно в какую-то монаду". А вот в какую именно - это уже неважно. Поэтому мы можем написать, например, так:

```haskell
import Data.Char

main :: IO ()
main =
    print $ name >>= toLowerCase
    where name = Just 'A'
```

Кстати, чтобы это заработало, откройте файл `Real.cabal`, найдите в нём секцию `executable Real` и допишите в ней новый параметр:

```haskell
    extensions:          NoMonomorphismRestriction
```

Функция `toLowerCase` остаётся в счастливом неведении о том, что теперь она работает уже не со списком символов, а с монадой Maybe, содержащей в себе символ. И поэтому функция `return` в теле функции `toLowerCase` завернёт итоговый символ уже не списочную монаду, а в монаду `Maybe`. Таким образом, функцию, задуманную для работы с одной монадой, можно использовать для работы с другими.

### Меняем тип

Ещё один пример:

```haskell
import Data.Char

main :: IO ()
main =
    print $ numbers >>= toRealNumbers
    where numbers = "1234567890"
          toRealNumbers = return . digitToInt
```

На выходе нас ждёт:

```bash
[1,2,3,4,5,6,7,8,9,0]
```

Здесь произошло изменение типа монады. Функция `toRealNumbers` превращает символ в его цифровое представление. И вновь оператор компоновки и функция `return` сделали своё красивое дело: на вход была подана монада `[Char]`, а на выходе получили монаду `[Int]`. Таким образом, на протяжении всей цепочки монадическая обёртка остаётся неизменной, а вот наполнение этой обёртки может изменять не только своё значение, но и свой тип.

### Зеркальная компоновка

В стандартном пакете `Prelude` определён ещё один монадический оператор, который можно назвать "зеркальной компоновкой". Всё то же самое, но справа налево. Вот как это будет выглядеть в нашем примере:

```haskell
import Data.Char

main :: IO ()
main =
    print $ toLowerCase =<< underlineSpaces =<< name
    where name = "Lorem ipsuM"
```

Мы просто развернули оператор компоновки наоборот, и теперь значение `name` заезжает в конвейер справа налево. Лично мне классический вариант кажется более удобным, так что выбор между обычной и зеркальной компоновкой - это вопрос эстетический.

Монадические цепочки - красивый и гибкий инструмент связки вычислений. Как мы смогли убедиться, аналогия с Unix-каналом оказалась достаточно точной.
