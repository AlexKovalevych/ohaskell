Монады: практика
----------------

Зачем же ради соединения вычислений в последовательную цепочку обматывать эти вычисления в какие-то монадические обёртки?

Главная цель такого подхода: гибкость и упрощение кода. Приступим.

### Разоблачение списков

Списки в Haskell - это тоже монады. Рассмотрим, какую пользу нам может принести этот факт.

Начнём со строки. Она ведь есть ни что иное, как [Char], а это значит, она тоже является монадой. Помните наш пример про исправление URL? Напишем нечто похожее:

 

import Data.Char

 

toLowerCase = return . toLower

underlineSpaces char = return (if char == ' ' then '_' else char)

 

main :: IO ()

main =

    print $ name \>>= toLowerCase \>>= underlineSpaces

    where name = "Lorem ipsuM"

 

На выходе будет:

 

lorem_ipsum

 

Проанализируем. Наше внимание приковывает вот эта строка:

 

name \>>= toLowerCase \>>= underlineSpaces

 

В глаза бросаются операторы компоновки, а это значит, перед нами монадический конвейер. Слева в него въезжает наша строка name, то есть монада [Char], и едет по нему. А за конвейером её ждут два работника, toLowerCase и underlineSpaces, каждый из которых вносит в name свои изменения.

Вы спросите, в чём же тут соль? Чем это отличается от функций композиции и применения, рассмотренных нами ранее[22](#ftn22)? Ведь там мы тоже конструировали конвейер из трёх функций:

 

addPrefix . encodeAllSpaces . makeItLowerCase $ url

 

Однако отличия имеются, и главное из них в том, что эти три функции работают со строкой, а функции toLowerCase и underlineSpaces работают с элементом строки. Взгляните:

 

toLowerCase = return . toLower

 

Эта функция ожидает на вход символ, а не строку, ведь функция toLower применяется к значению типа Char. И это очень важное свойство функций, компонуемых в монадическую цепочку: они работают со значением, содержащимся в монаде, а не с самой монадой. Поскольку в данном случае монадой является [Char], функция toLowerCase работает только с Char, извлекаемым из списка оператором компоновки. Понятно, что оператор компоновки, определённый для списка, подразумевает "прогон" монадной функции через все элементы этого списка.

Монадическая цепочка предоставляет нам большую гибкость, ведь функции toLowerCase и underlineSpaces вообще не знают о том, что работают они в конечном итоге со строкой. А значит, эти функции можно соединять для работы с самыми разными монадами, содержащими в себе значение(я) типа Char.

Кстати, важное уточнение: функции такого рода могут работать только с монадами, о чём красноречиво говорит функция return. Взглянем на определение ещё раз:

 

toLowerCase = return . toLower

 

Функция говорит нам: "Да, я работаю с аргументом типа Char, но в конце своей работы я, с помощью функции return, возвращаю итоговое значение типа Char обратно в какую-то монаду". А вот в какую именно - это уже неважно. Поэтому мы можем написать, например, так:

 

import Data.Char

 

main :: IO ()

main =

    print $ name \>>= toLowerCase

    where name = Just 'A'

 

Кстати, чтобы это заработало, откройте файл Real.cabal, найдите в нём секцию executable Real и допишите в ней новый параметр:

 

    extensions:          NoMonomorphismRestriction

 

Функция  toLowerCase остаётся в счастливом неведении о том, что теперь она фактически работает уже не со списком символов, а с монадой Maybe[23](#ftn23), содержащей в себе символ. И поэтому функция return в теле функции toLowerCase завернёт итоговый символ уже не списочную монаду, а в монаду Maybe. Именно поэтому я и сказал выше, что функцию, задуманную для работы с одной монадой, можно использовать для работы с другими.

### Меняем тип

Ещё один пример:

 

import Data.Char

 

main :: IO ()

main =

    print $ numbers \>>= toRealNumbers

    where numbers = "1234567890"

           toRealNumbers = return . digitToInt

 

На выходе нас ждёт:

 

[1,2,3,4,5,6,7,8,9,0]

 

Здесь произошло изменение типа монады. Функция toRealNumbers превращает символ в его цифровое представление. И вновь оператор компоновки и функция return сделали своё красивое дело: на вход была подана монада [Char], а на выходе получили монаду [Int]. Таким образом, на протяжении всей цепочки монадическая обёртка остаётся неизменной[24](#ftn24), а вот наполнение этой обёртки может изменять не только своё значение, но и свой тип.

### Зеркальная компоновка

В стандартном пакете Prelude определён ещё один монадический оператор, который можно назвать "зеркальной компоновкой". Всё то же самое, но справа налево. Вот как это будет выглядеть в нашем примере:

 

import Data.Char

 

main :: IO ()

main =

    print $ toLowerCase =\<\< underlineSpaces =\<\< name

    where name = "Lorem ipsuM"

 

Мы просто развернули оператор компоновки наоборот, и теперь значение name заезжает в конвейер справа налево. Лично мне классический вариант кажется более удобным, так что выбор между обычной и зеркальной компоновкой - это вопрос эстетический.

Монадические цепочки - красивый и гибкий инструмент связки вычислений. Как мы смогли убедиться, аналогия с Unix-каналом оказалась достаточно точной.
